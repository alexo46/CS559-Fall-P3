(async () => {
  (function() {
    const t = document.createElement("link").relList;
    if (t && t.supports && t.supports("modulepreload")) return;
    for (const i of document.querySelectorAll('link[rel="modulepreload"]')) n(i);
    new MutationObserver((i) => {
      for (const s of i) if (s.type === "childList") for (const a of s.addedNodes) a.tagName === "LINK" && a.rel === "modulepreload" && n(a);
    }).observe(document, {
      childList: true,
      subtree: true
    });
    function e(i) {
      const s = {};
      return i.integrity && (s.integrity = i.integrity), i.referrerPolicy && (s.referrerPolicy = i.referrerPolicy), i.crossOrigin === "use-credentials" ? s.credentials = "include" : i.crossOrigin === "anonymous" ? s.credentials = "omit" : s.credentials = "same-origin", s;
    }
    function n(i) {
      if (i.ep) return;
      i.ep = true;
      const s = e(i);
      fetch(i.href, s);
    }
  })();
  const Ic = "165", Wi = {
    ROTATE: 0,
    DOLLY: 1,
    PAN: 2
  }, ji = {
    ROTATE: 0,
    PAN: 1,
    DOLLY_PAN: 2,
    DOLLY_ROTATE: 3
  }, gp = 0, Ll = 1, wp = 2, au = 1, ou = 2, Kn = 3, Jn = 0, nn = 1, Mn = 2, vi = 0, gr = 1, Dl = 2, Nl = 3, Ul = 4, bp = 5, Ui = 100, yp = 101, vp = 102, xp = 103, Sp = 104, Mp = 200, Ep = 201, Tp = 202, Ap = 203, wc = 204, bc = 205, Rp = 206, Cp = 207, Pp = 208, Ip = 209, Lp = 210, Dp = 211, Np = 212, Up = 213, Fp = 214, Op = 0, Bp = 1, zp = 2, pa = 3, kp = 4, Hp = 5, Gp = 6, Vp = 7, cu = 0, Wp = 1, jp = 2, xi = 0, Xp = 1, qp = 2, Kp = 3, lu = 4, Yp = 5, Zp = 6, $p = 7, Fl = "attached", Jp = "detached", hu = 300, vr = 301, xr = 302, yc = 303, vc = 304, Oa = 306, Oi = 1e3, wi = 1001, fa = 1002, en = 1003, du = 1004, ts = 1005, dn = 1006, da = 1007, Zn = 1008, Si = 1009, Qp = 1010, tf = 1011, _a = 1012, uu = 1013, Sr = 1014, Dn = 1015, Ba = 1016, pu = 1017, fu = 1018, Mr = 1020, ef = 35902, nf = 1021, rf = 1022, Tn = 1023, sf = 1024, af = 1025, wr = 1026, Er = 1027, _u = 1028, mu = 1029, of = 1030, gu = 1031, wu = 1033, yo = 33776, vo = 33777, xo = 33778, So = 33779, Ol = 35840, Bl = 35841, zl = 35842, kl = 35843, Hl = 36196, Gl = 37492, Vl = 37496, Wl = 37808, jl = 37809, Xl = 37810, ql = 37811, Kl = 37812, Yl = 37813, Zl = 37814, $l = 37815, Jl = 37816, Ql = 37817, th = 37818, eh = 37819, nh = 37820, ih = 37821, Mo = 36492, rh = 36494, sh = 36495, cf = 36283, ah = 36284, oh = 36285, ch = 36286, cs = 2300, ls = 2301, Eo = 2302, lh = 2400, hh = 2401, dh = 2402, lf = 2500, hf = 0, bu = 1, xc = 2, df = 3200, uf = 3201, yu = 0, pf = 1, gi = "", Ke = "srgb", je = "srgb-linear", Lc = "display-p3", za = "display-p3-linear", ma = "linear", me = "srgb", ga = "rec709", wa = "p3", Xi = 7680, uh = 519, ff = 512, _f = 513, mf = 514, vu = 515, gf = 516, wf = 517, bf = 518, yf = 519, Sc = 35044, ph = "300 es", $n = 2e3, ba = 2001;
  class Gi {
    addEventListener(t, e) {
      this._listeners === void 0 && (this._listeners = {});
      const n = this._listeners;
      n[t] === void 0 && (n[t] = []), n[t].indexOf(e) === -1 && n[t].push(e);
    }
    hasEventListener(t, e) {
      if (this._listeners === void 0) return false;
      const n = this._listeners;
      return n[t] !== void 0 && n[t].indexOf(e) !== -1;
    }
    removeEventListener(t, e) {
      if (this._listeners === void 0) return;
      const i = this._listeners[t];
      if (i !== void 0) {
        const s = i.indexOf(e);
        s !== -1 && i.splice(s, 1);
      }
    }
    dispatchEvent(t) {
      if (this._listeners === void 0) return;
      const n = this._listeners[t.type];
      if (n !== void 0) {
        t.target = this;
        const i = n.slice(0);
        for (let s = 0, a = i.length; s < a; s++) i[s].call(this, t);
        t.target = null;
      }
    }
  }
  const Xe = [
    "00",
    "01",
    "02",
    "03",
    "04",
    "05",
    "06",
    "07",
    "08",
    "09",
    "0a",
    "0b",
    "0c",
    "0d",
    "0e",
    "0f",
    "10",
    "11",
    "12",
    "13",
    "14",
    "15",
    "16",
    "17",
    "18",
    "19",
    "1a",
    "1b",
    "1c",
    "1d",
    "1e",
    "1f",
    "20",
    "21",
    "22",
    "23",
    "24",
    "25",
    "26",
    "27",
    "28",
    "29",
    "2a",
    "2b",
    "2c",
    "2d",
    "2e",
    "2f",
    "30",
    "31",
    "32",
    "33",
    "34",
    "35",
    "36",
    "37",
    "38",
    "39",
    "3a",
    "3b",
    "3c",
    "3d",
    "3e",
    "3f",
    "40",
    "41",
    "42",
    "43",
    "44",
    "45",
    "46",
    "47",
    "48",
    "49",
    "4a",
    "4b",
    "4c",
    "4d",
    "4e",
    "4f",
    "50",
    "51",
    "52",
    "53",
    "54",
    "55",
    "56",
    "57",
    "58",
    "59",
    "5a",
    "5b",
    "5c",
    "5d",
    "5e",
    "5f",
    "60",
    "61",
    "62",
    "63",
    "64",
    "65",
    "66",
    "67",
    "68",
    "69",
    "6a",
    "6b",
    "6c",
    "6d",
    "6e",
    "6f",
    "70",
    "71",
    "72",
    "73",
    "74",
    "75",
    "76",
    "77",
    "78",
    "79",
    "7a",
    "7b",
    "7c",
    "7d",
    "7e",
    "7f",
    "80",
    "81",
    "82",
    "83",
    "84",
    "85",
    "86",
    "87",
    "88",
    "89",
    "8a",
    "8b",
    "8c",
    "8d",
    "8e",
    "8f",
    "90",
    "91",
    "92",
    "93",
    "94",
    "95",
    "96",
    "97",
    "98",
    "99",
    "9a",
    "9b",
    "9c",
    "9d",
    "9e",
    "9f",
    "a0",
    "a1",
    "a2",
    "a3",
    "a4",
    "a5",
    "a6",
    "a7",
    "a8",
    "a9",
    "aa",
    "ab",
    "ac",
    "ad",
    "ae",
    "af",
    "b0",
    "b1",
    "b2",
    "b3",
    "b4",
    "b5",
    "b6",
    "b7",
    "b8",
    "b9",
    "ba",
    "bb",
    "bc",
    "bd",
    "be",
    "bf",
    "c0",
    "c1",
    "c2",
    "c3",
    "c4",
    "c5",
    "c6",
    "c7",
    "c8",
    "c9",
    "ca",
    "cb",
    "cc",
    "cd",
    "ce",
    "cf",
    "d0",
    "d1",
    "d2",
    "d3",
    "d4",
    "d5",
    "d6",
    "d7",
    "d8",
    "d9",
    "da",
    "db",
    "dc",
    "dd",
    "de",
    "df",
    "e0",
    "e1",
    "e2",
    "e3",
    "e4",
    "e5",
    "e6",
    "e7",
    "e8",
    "e9",
    "ea",
    "eb",
    "ec",
    "ed",
    "ee",
    "ef",
    "f0",
    "f1",
    "f2",
    "f3",
    "f4",
    "f5",
    "f6",
    "f7",
    "f8",
    "f9",
    "fa",
    "fb",
    "fc",
    "fd",
    "fe",
    "ff"
  ];
  let fh = 1234567;
  const is = Math.PI / 180, Tr = 180 / Math.PI;
  function An() {
    const r = Math.random() * 4294967295 | 0, t = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, n = Math.random() * 4294967295 | 0;
    return (Xe[r & 255] + Xe[r >> 8 & 255] + Xe[r >> 16 & 255] + Xe[r >> 24 & 255] + "-" + Xe[t & 255] + Xe[t >> 8 & 255] + "-" + Xe[t >> 16 & 15 | 64] + Xe[t >> 24 & 255] + "-" + Xe[e & 63 | 128] + Xe[e >> 8 & 255] + "-" + Xe[e >> 16 & 255] + Xe[e >> 24 & 255] + Xe[n & 255] + Xe[n >> 8 & 255] + Xe[n >> 16 & 255] + Xe[n >> 24 & 255]).toLowerCase();
  }
  function Ge(r, t, e) {
    return Math.max(t, Math.min(e, r));
  }
  function Dc(r, t) {
    return (r % t + t) % t;
  }
  function vf(r, t, e, n, i) {
    return n + (r - t) * (i - n) / (e - t);
  }
  function xf(r, t, e) {
    return r !== t ? (e - r) / (t - r) : 0;
  }
  function rs(r, t, e) {
    return (1 - e) * r + e * t;
  }
  function Sf(r, t, e, n) {
    return rs(r, t, 1 - Math.exp(-e * n));
  }
  function Mf(r, t = 1) {
    return t - Math.abs(Dc(r, t * 2) - t);
  }
  function Ef(r, t, e) {
    return r <= t ? 0 : r >= e ? 1 : (r = (r - t) / (e - t), r * r * (3 - 2 * r));
  }
  function Tf(r, t, e) {
    return r <= t ? 0 : r >= e ? 1 : (r = (r - t) / (e - t), r * r * r * (r * (r * 6 - 15) + 10));
  }
  function Af(r, t) {
    return r + Math.floor(Math.random() * (t - r + 1));
  }
  function Rf(r, t) {
    return r + Math.random() * (t - r);
  }
  function Cf(r) {
    return r * (0.5 - Math.random());
  }
  function Pf(r) {
    r !== void 0 && (fh = r);
    let t = fh += 1831565813;
    return t = Math.imul(t ^ t >>> 15, t | 1), t ^= t + Math.imul(t ^ t >>> 7, t | 61), ((t ^ t >>> 14) >>> 0) / 4294967296;
  }
  function If(r) {
    return r * is;
  }
  function Lf(r) {
    return r * Tr;
  }
  function Df(r) {
    return (r & r - 1) === 0 && r !== 0;
  }
  function Nf(r) {
    return Math.pow(2, Math.ceil(Math.log(r) / Math.LN2));
  }
  function Uf(r) {
    return Math.pow(2, Math.floor(Math.log(r) / Math.LN2));
  }
  function Ff(r, t, e, n, i) {
    const s = Math.cos, a = Math.sin, o = s(e / 2), c = a(e / 2), l = s((t + n) / 2), h = a((t + n) / 2), d = s((t - n) / 2), u = a((t - n) / 2), p = s((n - t) / 2), w = a((n - t) / 2);
    switch (i) {
      case "XYX":
        r.set(o * h, c * d, c * u, o * l);
        break;
      case "YZY":
        r.set(c * u, o * h, c * d, o * l);
        break;
      case "ZXZ":
        r.set(c * d, c * u, o * h, o * l);
        break;
      case "XZX":
        r.set(o * h, c * w, c * p, o * l);
        break;
      case "YXY":
        r.set(c * p, o * h, c * w, o * l);
        break;
      case "ZYZ":
        r.set(c * w, c * p, o * h, o * l);
        break;
      default:
        console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + i);
    }
  }
  function En(r, t) {
    switch (t.constructor) {
      case Float32Array:
        return r;
      case Uint32Array:
        return r / 4294967295;
      case Uint16Array:
        return r / 65535;
      case Uint8Array:
        return r / 255;
      case Int32Array:
        return Math.max(r / 2147483647, -1);
      case Int16Array:
        return Math.max(r / 32767, -1);
      case Int8Array:
        return Math.max(r / 127, -1);
      default:
        throw new Error("Invalid component type.");
    }
  }
  function ae(r, t) {
    switch (t.constructor) {
      case Float32Array:
        return r;
      case Uint32Array:
        return Math.round(r * 4294967295);
      case Uint16Array:
        return Math.round(r * 65535);
      case Uint8Array:
        return Math.round(r * 255);
      case Int32Array:
        return Math.round(r * 2147483647);
      case Int16Array:
        return Math.round(r * 32767);
      case Int8Array:
        return Math.round(r * 127);
      default:
        throw new Error("Invalid component type.");
    }
  }
  const we = {
    DEG2RAD: is,
    RAD2DEG: Tr,
    generateUUID: An,
    clamp: Ge,
    euclideanModulo: Dc,
    mapLinear: vf,
    inverseLerp: xf,
    lerp: rs,
    damp: Sf,
    pingpong: Mf,
    smoothstep: Ef,
    smootherstep: Tf,
    randInt: Af,
    randFloat: Rf,
    randFloatSpread: Cf,
    seededRandom: Pf,
    degToRad: If,
    radToDeg: Lf,
    isPowerOfTwo: Df,
    ceilPowerOfTwo: Nf,
    floorPowerOfTwo: Uf,
    setQuaternionFromProperEuler: Ff,
    normalize: ae,
    denormalize: En
  };
  class vt {
    constructor(t = 0, e = 0) {
      vt.prototype.isVector2 = true, this.x = t, this.y = e;
    }
    get width() {
      return this.x;
    }
    set width(t) {
      this.x = t;
    }
    get height() {
      return this.y;
    }
    set height(t) {
      this.y = t;
    }
    set(t, e) {
      return this.x = t, this.y = e, this;
    }
    setScalar(t) {
      return this.x = t, this.y = t, this;
    }
    setX(t) {
      return this.x = t, this;
    }
    setY(t) {
      return this.y = t, this;
    }
    setComponent(t, e) {
      switch (t) {
        case 0:
          this.x = e;
          break;
        case 1:
          this.y = e;
          break;
        default:
          throw new Error("index is out of range: " + t);
      }
      return this;
    }
    getComponent(t) {
      switch (t) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        default:
          throw new Error("index is out of range: " + t);
      }
    }
    clone() {
      return new this.constructor(this.x, this.y);
    }
    copy(t) {
      return this.x = t.x, this.y = t.y, this;
    }
    add(t) {
      return this.x += t.x, this.y += t.y, this;
    }
    addScalar(t) {
      return this.x += t, this.y += t, this;
    }
    addVectors(t, e) {
      return this.x = t.x + e.x, this.y = t.y + e.y, this;
    }
    addScaledVector(t, e) {
      return this.x += t.x * e, this.y += t.y * e, this;
    }
    sub(t) {
      return this.x -= t.x, this.y -= t.y, this;
    }
    subScalar(t) {
      return this.x -= t, this.y -= t, this;
    }
    subVectors(t, e) {
      return this.x = t.x - e.x, this.y = t.y - e.y, this;
    }
    multiply(t) {
      return this.x *= t.x, this.y *= t.y, this;
    }
    multiplyScalar(t) {
      return this.x *= t, this.y *= t, this;
    }
    divide(t) {
      return this.x /= t.x, this.y /= t.y, this;
    }
    divideScalar(t) {
      return this.multiplyScalar(1 / t);
    }
    applyMatrix3(t) {
      const e = this.x, n = this.y, i = t.elements;
      return this.x = i[0] * e + i[3] * n + i[6], this.y = i[1] * e + i[4] * n + i[7], this;
    }
    min(t) {
      return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this;
    }
    max(t) {
      return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this;
    }
    clamp(t, e) {
      return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this;
    }
    clampScalar(t, e) {
      return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this;
    }
    clampLength(t, e) {
      const n = this.length();
      return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)));
    }
    floor() {
      return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
    }
    ceil() {
      return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
    }
    round() {
      return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
    }
    roundToZero() {
      return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this;
    }
    negate() {
      return this.x = -this.x, this.y = -this.y, this;
    }
    dot(t) {
      return this.x * t.x + this.y * t.y;
    }
    cross(t) {
      return this.x * t.y - this.y * t.x;
    }
    lengthSq() {
      return this.x * this.x + this.y * this.y;
    }
    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    }
    manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y);
    }
    normalize() {
      return this.divideScalar(this.length() || 1);
    }
    angle() {
      return Math.atan2(-this.y, -this.x) + Math.PI;
    }
    angleTo(t) {
      const e = Math.sqrt(this.lengthSq() * t.lengthSq());
      if (e === 0) return Math.PI / 2;
      const n = this.dot(t) / e;
      return Math.acos(Ge(n, -1, 1));
    }
    distanceTo(t) {
      return Math.sqrt(this.distanceToSquared(t));
    }
    distanceToSquared(t) {
      const e = this.x - t.x, n = this.y - t.y;
      return e * e + n * n;
    }
    manhattanDistanceTo(t) {
      return Math.abs(this.x - t.x) + Math.abs(this.y - t.y);
    }
    setLength(t) {
      return this.normalize().multiplyScalar(t);
    }
    lerp(t, e) {
      return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this;
    }
    lerpVectors(t, e, n) {
      return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this;
    }
    equals(t) {
      return t.x === this.x && t.y === this.y;
    }
    fromArray(t, e = 0) {
      return this.x = t[e], this.y = t[e + 1], this;
    }
    toArray(t = [], e = 0) {
      return t[e] = this.x, t[e + 1] = this.y, t;
    }
    fromBufferAttribute(t, e) {
      return this.x = t.getX(e), this.y = t.getY(e), this;
    }
    rotateAround(t, e) {
      const n = Math.cos(e), i = Math.sin(e), s = this.x - t.x, a = this.y - t.y;
      return this.x = s * n - a * i + t.x, this.y = s * i + a * n + t.y, this;
    }
    random() {
      return this.x = Math.random(), this.y = Math.random(), this;
    }
    *[Symbol.iterator]() {
      yield this.x, yield this.y;
    }
  }
  class Vt {
    constructor(t, e, n, i, s, a, o, c, l) {
      Vt.prototype.isMatrix3 = true, this.elements = [
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1
      ], t !== void 0 && this.set(t, e, n, i, s, a, o, c, l);
    }
    set(t, e, n, i, s, a, o, c, l) {
      const h = this.elements;
      return h[0] = t, h[1] = i, h[2] = o, h[3] = e, h[4] = s, h[5] = c, h[6] = n, h[7] = a, h[8] = l, this;
    }
    identity() {
      return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
    }
    copy(t) {
      const e = this.elements, n = t.elements;
      return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], this;
    }
    extractBasis(t, e, n) {
      return t.setFromMatrix3Column(this, 0), e.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this;
    }
    setFromMatrix4(t) {
      const e = t.elements;
      return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this;
    }
    multiply(t) {
      return this.multiplyMatrices(this, t);
    }
    premultiply(t) {
      return this.multiplyMatrices(t, this);
    }
    multiplyMatrices(t, e) {
      const n = t.elements, i = e.elements, s = this.elements, a = n[0], o = n[3], c = n[6], l = n[1], h = n[4], d = n[7], u = n[2], p = n[5], w = n[8], b = i[0], m = i[3], _ = i[6], E = i[1], v = i[4], T = i[7], O = i[2], R = i[5], P = i[8];
      return s[0] = a * b + o * E + c * O, s[3] = a * m + o * v + c * R, s[6] = a * _ + o * T + c * P, s[1] = l * b + h * E + d * O, s[4] = l * m + h * v + d * R, s[7] = l * _ + h * T + d * P, s[2] = u * b + p * E + w * O, s[5] = u * m + p * v + w * R, s[8] = u * _ + p * T + w * P, this;
    }
    multiplyScalar(t) {
      const e = this.elements;
      return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[2] *= t, e[5] *= t, e[8] *= t, this;
    }
    determinant() {
      const t = this.elements, e = t[0], n = t[1], i = t[2], s = t[3], a = t[4], o = t[5], c = t[6], l = t[7], h = t[8];
      return e * a * h - e * o * l - n * s * h + n * o * c + i * s * l - i * a * c;
    }
    invert() {
      const t = this.elements, e = t[0], n = t[1], i = t[2], s = t[3], a = t[4], o = t[5], c = t[6], l = t[7], h = t[8], d = h * a - o * l, u = o * c - h * s, p = l * s - a * c, w = e * d + n * u + i * p;
      if (w === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
      const b = 1 / w;
      return t[0] = d * b, t[1] = (i * l - h * n) * b, t[2] = (o * n - i * a) * b, t[3] = u * b, t[4] = (h * e - i * c) * b, t[5] = (i * s - o * e) * b, t[6] = p * b, t[7] = (n * c - l * e) * b, t[8] = (a * e - n * s) * b, this;
    }
    transpose() {
      let t;
      const e = this.elements;
      return t = e[1], e[1] = e[3], e[3] = t, t = e[2], e[2] = e[6], e[6] = t, t = e[5], e[5] = e[7], e[7] = t, this;
    }
    getNormalMatrix(t) {
      return this.setFromMatrix4(t).invert().transpose();
    }
    transposeIntoArray(t) {
      const e = this.elements;
      return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this;
    }
    setUvTransform(t, e, n, i, s, a, o) {
      const c = Math.cos(s), l = Math.sin(s);
      return this.set(n * c, n * l, -n * (c * a + l * o) + a + t, -i * l, i * c, -i * (-l * a + c * o) + o + e, 0, 0, 1), this;
    }
    scale(t, e) {
      return this.premultiply(To.makeScale(t, e)), this;
    }
    rotate(t) {
      return this.premultiply(To.makeRotation(-t)), this;
    }
    translate(t, e) {
      return this.premultiply(To.makeTranslation(t, e)), this;
    }
    makeTranslation(t, e) {
      return t.isVector2 ? this.set(1, 0, t.x, 0, 1, t.y, 0, 0, 1) : this.set(1, 0, t, 0, 1, e, 0, 0, 1), this;
    }
    makeRotation(t) {
      const e = Math.cos(t), n = Math.sin(t);
      return this.set(e, -n, 0, n, e, 0, 0, 0, 1), this;
    }
    makeScale(t, e) {
      return this.set(t, 0, 0, 0, e, 0, 0, 0, 1), this;
    }
    equals(t) {
      const e = this.elements, n = t.elements;
      for (let i = 0; i < 9; i++) if (e[i] !== n[i]) return false;
      return true;
    }
    fromArray(t, e = 0) {
      for (let n = 0; n < 9; n++) this.elements[n] = t[n + e];
      return this;
    }
    toArray(t = [], e = 0) {
      const n = this.elements;
      return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t;
    }
    clone() {
      return new this.constructor().fromArray(this.elements);
    }
  }
  const To = new Vt();
  function xu(r) {
    for (let t = r.length - 1; t >= 0; --t) if (r[t] >= 65535) return true;
    return false;
  }
  function hs(r) {
    return document.createElementNS("http://www.w3.org/1999/xhtml", r);
  }
  function Of() {
    const r = hs("canvas");
    return r.style.display = "block", r;
  }
  const _h = {};
  function Nc(r) {
    r in _h || (_h[r] = true, console.warn(r));
  }
  function Bf(r, t, e) {
    return new Promise(function(n, i) {
      function s() {
        switch (r.clientWaitSync(t, r.SYNC_FLUSH_COMMANDS_BIT, 0)) {
          case r.WAIT_FAILED:
            i();
            break;
          case r.TIMEOUT_EXPIRED:
            setTimeout(s, e);
            break;
          default:
            n();
        }
      }
      setTimeout(s, e);
    });
  }
  const mh = new Vt().set(0.8224621, 0.177538, 0, 0.0331941, 0.9668058, 0, 0.0170827, 0.0723974, 0.9105199), gh = new Vt().set(1.2249401, -0.2249404, 0, -0.0420569, 1.0420571, 0, -0.0196376, -0.0786361, 1.0982735), Ts = {
    [je]: {
      transfer: ma,
      primaries: ga,
      toReference: (r) => r,
      fromReference: (r) => r
    },
    [Ke]: {
      transfer: me,
      primaries: ga,
      toReference: (r) => r.convertSRGBToLinear(),
      fromReference: (r) => r.convertLinearToSRGB()
    },
    [za]: {
      transfer: ma,
      primaries: wa,
      toReference: (r) => r.applyMatrix3(gh),
      fromReference: (r) => r.applyMatrix3(mh)
    },
    [Lc]: {
      transfer: me,
      primaries: wa,
      toReference: (r) => r.convertSRGBToLinear().applyMatrix3(gh),
      fromReference: (r) => r.applyMatrix3(mh).convertLinearToSRGB()
    }
  }, zf = /* @__PURE__ */ new Set([
    je,
    za
  ]), ie = {
    enabled: true,
    _workingColorSpace: je,
    get workingColorSpace() {
      return this._workingColorSpace;
    },
    set workingColorSpace(r) {
      if (!zf.has(r)) throw new Error(`Unsupported working color space, "${r}".`);
      this._workingColorSpace = r;
    },
    convert: function(r, t, e) {
      if (this.enabled === false || t === e || !t || !e) return r;
      const n = Ts[t].toReference, i = Ts[e].fromReference;
      return i(n(r));
    },
    fromWorkingColorSpace: function(r, t) {
      return this.convert(r, this._workingColorSpace, t);
    },
    toWorkingColorSpace: function(r, t) {
      return this.convert(r, t, this._workingColorSpace);
    },
    getPrimaries: function(r) {
      return Ts[r].primaries;
    },
    getTransfer: function(r) {
      return r === gi ? ma : Ts[r].transfer;
    }
  };
  function br(r) {
    return r < 0.04045 ? r * 0.0773993808 : Math.pow(r * 0.9478672986 + 0.0521327014, 2.4);
  }
  function Ao(r) {
    return r < 31308e-7 ? r * 12.92 : 1.055 * Math.pow(r, 0.41666) - 0.055;
  }
  let qi;
  class kf {
    static getDataURL(t) {
      if (/^data:/i.test(t.src) || typeof HTMLCanvasElement > "u") return t.src;
      let e;
      if (t instanceof HTMLCanvasElement) e = t;
      else {
        qi === void 0 && (qi = hs("canvas")), qi.width = t.width, qi.height = t.height;
        const n = qi.getContext("2d");
        t instanceof ImageData ? n.putImageData(t, 0, 0) : n.drawImage(t, 0, 0, t.width, t.height), e = qi;
      }
      return e.width > 2048 || e.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", t), e.toDataURL("image/jpeg", 0.6)) : e.toDataURL("image/png");
    }
    static sRGBToLinear(t) {
      if (typeof HTMLImageElement < "u" && t instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && t instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && t instanceof ImageBitmap) {
        const e = hs("canvas");
        e.width = t.width, e.height = t.height;
        const n = e.getContext("2d");
        n.drawImage(t, 0, 0, t.width, t.height);
        const i = n.getImageData(0, 0, t.width, t.height), s = i.data;
        for (let a = 0; a < s.length; a++) s[a] = br(s[a] / 255) * 255;
        return n.putImageData(i, 0, 0), e;
      } else if (t.data) {
        const e = t.data.slice(0);
        for (let n = 0; n < e.length; n++) e instanceof Uint8Array || e instanceof Uint8ClampedArray ? e[n] = Math.floor(br(e[n] / 255) * 255) : e[n] = br(e[n]);
        return {
          data: e,
          width: t.width,
          height: t.height
        };
      } else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), t;
    }
  }
  let Hf = 0;
  class Su {
    constructor(t = null) {
      this.isSource = true, Object.defineProperty(this, "id", {
        value: Hf++
      }), this.uuid = An(), this.data = t, this.dataReady = true, this.version = 0;
    }
    set needsUpdate(t) {
      t === true && this.version++;
    }
    toJSON(t) {
      const e = t === void 0 || typeof t == "string";
      if (!e && t.images[this.uuid] !== void 0) return t.images[this.uuid];
      const n = {
        uuid: this.uuid,
        url: ""
      }, i = this.data;
      if (i !== null) {
        let s;
        if (Array.isArray(i)) {
          s = [];
          for (let a = 0, o = i.length; a < o; a++) i[a].isDataTexture ? s.push(Ro(i[a].image)) : s.push(Ro(i[a]));
        } else s = Ro(i);
        n.url = s;
      }
      return e || (t.images[this.uuid] = n), n;
    }
  }
  function Ro(r) {
    return typeof HTMLImageElement < "u" && r instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && r instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && r instanceof ImageBitmap ? kf.getDataURL(r) : r.data ? {
      data: Array.from(r.data),
      width: r.width,
      height: r.height,
      type: r.data.constructor.name
    } : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
  }
  let Gf = 0;
  class Ne extends Gi {
    constructor(t = Ne.DEFAULT_IMAGE, e = Ne.DEFAULT_MAPPING, n = wi, i = wi, s = dn, a = Zn, o = Tn, c = Si, l = Ne.DEFAULT_ANISOTROPY, h = gi) {
      super(), this.isTexture = true, Object.defineProperty(this, "id", {
        value: Gf++
      }), this.uuid = An(), this.name = "", this.source = new Su(t), this.mipmaps = [], this.mapping = e, this.channel = 0, this.wrapS = n, this.wrapT = i, this.magFilter = s, this.minFilter = a, this.anisotropy = l, this.format = o, this.internalFormat = null, this.type = c, this.offset = new vt(0, 0), this.repeat = new vt(1, 1), this.center = new vt(0, 0), this.rotation = 0, this.matrixAutoUpdate = true, this.matrix = new Vt(), this.generateMipmaps = true, this.premultiplyAlpha = false, this.flipY = true, this.unpackAlignment = 4, this.colorSpace = h, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = false, this.pmremVersion = 0;
    }
    get image() {
      return this.source.data;
    }
    set image(t = null) {
      this.source.data = t;
    }
    updateMatrix() {
      this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(t) {
      return this.name = t.name, this.source = t.source, this.mipmaps = t.mipmaps.slice(0), this.mapping = t.mapping, this.channel = t.channel, this.wrapS = t.wrapS, this.wrapT = t.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this.anisotropy = t.anisotropy, this.format = t.format, this.internalFormat = t.internalFormat, this.type = t.type, this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.center.copy(t.center), this.rotation = t.rotation, this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrix.copy(t.matrix), this.generateMipmaps = t.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY = t.flipY, this.unpackAlignment = t.unpackAlignment, this.colorSpace = t.colorSpace, this.userData = JSON.parse(JSON.stringify(t.userData)), this.needsUpdate = true, this;
    }
    toJSON(t) {
      const e = t === void 0 || typeof t == "string";
      if (!e && t.textures[this.uuid] !== void 0) return t.textures[this.uuid];
      const n = {
        metadata: {
          version: 4.6,
          type: "Texture",
          generator: "Texture.toJSON"
        },
        uuid: this.uuid,
        name: this.name,
        image: this.source.toJSON(t).uuid,
        mapping: this.mapping,
        channel: this.channel,
        repeat: [
          this.repeat.x,
          this.repeat.y
        ],
        offset: [
          this.offset.x,
          this.offset.y
        ],
        center: [
          this.center.x,
          this.center.y
        ],
        rotation: this.rotation,
        wrap: [
          this.wrapS,
          this.wrapT
        ],
        format: this.format,
        internalFormat: this.internalFormat,
        type: this.type,
        colorSpace: this.colorSpace,
        minFilter: this.minFilter,
        magFilter: this.magFilter,
        anisotropy: this.anisotropy,
        flipY: this.flipY,
        generateMipmaps: this.generateMipmaps,
        premultiplyAlpha: this.premultiplyAlpha,
        unpackAlignment: this.unpackAlignment
      };
      return Object.keys(this.userData).length > 0 && (n.userData = this.userData), e || (t.textures[this.uuid] = n), n;
    }
    dispose() {
      this.dispatchEvent({
        type: "dispose"
      });
    }
    transformUv(t) {
      if (this.mapping !== hu) return t;
      if (t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1) switch (this.wrapS) {
        case Oi:
          t.x = t.x - Math.floor(t.x);
          break;
        case wi:
          t.x = t.x < 0 ? 0 : 1;
          break;
        case fa:
          Math.abs(Math.floor(t.x) % 2) === 1 ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x);
          break;
      }
      if (t.y < 0 || t.y > 1) switch (this.wrapT) {
        case Oi:
          t.y = t.y - Math.floor(t.y);
          break;
        case wi:
          t.y = t.y < 0 ? 0 : 1;
          break;
        case fa:
          Math.abs(Math.floor(t.y) % 2) === 1 ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y);
          break;
      }
      return this.flipY && (t.y = 1 - t.y), t;
    }
    set needsUpdate(t) {
      t === true && (this.version++, this.source.needsUpdate = true);
    }
    set needsPMREMUpdate(t) {
      t === true && this.pmremVersion++;
    }
  }
  Ne.DEFAULT_IMAGE = null;
  Ne.DEFAULT_MAPPING = hu;
  Ne.DEFAULT_ANISOTROPY = 1;
  class de {
    constructor(t = 0, e = 0, n = 0, i = 1) {
      de.prototype.isVector4 = true, this.x = t, this.y = e, this.z = n, this.w = i;
    }
    get width() {
      return this.z;
    }
    set width(t) {
      this.z = t;
    }
    get height() {
      return this.w;
    }
    set height(t) {
      this.w = t;
    }
    set(t, e, n, i) {
      return this.x = t, this.y = e, this.z = n, this.w = i, this;
    }
    setScalar(t) {
      return this.x = t, this.y = t, this.z = t, this.w = t, this;
    }
    setX(t) {
      return this.x = t, this;
    }
    setY(t) {
      return this.y = t, this;
    }
    setZ(t) {
      return this.z = t, this;
    }
    setW(t) {
      return this.w = t, this;
    }
    setComponent(t, e) {
      switch (t) {
        case 0:
          this.x = e;
          break;
        case 1:
          this.y = e;
          break;
        case 2:
          this.z = e;
          break;
        case 3:
          this.w = e;
          break;
        default:
          throw new Error("index is out of range: " + t);
      }
      return this;
    }
    getComponent(t) {
      switch (t) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        case 2:
          return this.z;
        case 3:
          return this.w;
        default:
          throw new Error("index is out of range: " + t);
      }
    }
    clone() {
      return new this.constructor(this.x, this.y, this.z, this.w);
    }
    copy(t) {
      return this.x = t.x, this.y = t.y, this.z = t.z, this.w = t.w !== void 0 ? t.w : 1, this;
    }
    add(t) {
      return this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this;
    }
    addScalar(t) {
      return this.x += t, this.y += t, this.z += t, this.w += t, this;
    }
    addVectors(t, e) {
      return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t.w + e.w, this;
    }
    addScaledVector(t, e) {
      return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this.w += t.w * e, this;
    }
    sub(t) {
      return this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this;
    }
    subScalar(t) {
      return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this;
    }
    subVectors(t, e) {
      return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t.w - e.w, this;
    }
    multiply(t) {
      return this.x *= t.x, this.y *= t.y, this.z *= t.z, this.w *= t.w, this;
    }
    multiplyScalar(t) {
      return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this;
    }
    applyMatrix4(t) {
      const e = this.x, n = this.y, i = this.z, s = this.w, a = t.elements;
      return this.x = a[0] * e + a[4] * n + a[8] * i + a[12] * s, this.y = a[1] * e + a[5] * n + a[9] * i + a[13] * s, this.z = a[2] * e + a[6] * n + a[10] * i + a[14] * s, this.w = a[3] * e + a[7] * n + a[11] * i + a[15] * s, this;
    }
    divideScalar(t) {
      return this.multiplyScalar(1 / t);
    }
    setAxisAngleFromQuaternion(t) {
      this.w = 2 * Math.acos(t.w);
      const e = Math.sqrt(1 - t.w * t.w);
      return e < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t.x / e, this.y = t.y / e, this.z = t.z / e), this;
    }
    setAxisAngleFromRotationMatrix(t) {
      let e, n, i, s;
      const c = t.elements, l = c[0], h = c[4], d = c[8], u = c[1], p = c[5], w = c[9], b = c[2], m = c[6], _ = c[10];
      if (Math.abs(h - u) < 0.01 && Math.abs(d - b) < 0.01 && Math.abs(w - m) < 0.01) {
        if (Math.abs(h + u) < 0.1 && Math.abs(d + b) < 0.1 && Math.abs(w + m) < 0.1 && Math.abs(l + p + _ - 3) < 0.1) return this.set(1, 0, 0, 0), this;
        e = Math.PI;
        const v = (l + 1) / 2, T = (p + 1) / 2, O = (_ + 1) / 2, R = (h + u) / 4, P = (d + b) / 4, z = (w + m) / 4;
        return v > T && v > O ? v < 0.01 ? (n = 0, i = 0.707106781, s = 0.707106781) : (n = Math.sqrt(v), i = R / n, s = P / n) : T > O ? T < 0.01 ? (n = 0.707106781, i = 0, s = 0.707106781) : (i = Math.sqrt(T), n = R / i, s = z / i) : O < 0.01 ? (n = 0.707106781, i = 0.707106781, s = 0) : (s = Math.sqrt(O), n = P / s, i = z / s), this.set(n, i, s, e), this;
      }
      let E = Math.sqrt((m - w) * (m - w) + (d - b) * (d - b) + (u - h) * (u - h));
      return Math.abs(E) < 1e-3 && (E = 1), this.x = (m - w) / E, this.y = (d - b) / E, this.z = (u - h) / E, this.w = Math.acos((l + p + _ - 1) / 2), this;
    }
    min(t) {
      return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this;
    }
    max(t) {
      return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this;
    }
    clamp(t, e) {
      return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this.w = Math.max(t.w, Math.min(e.w, this.w)), this;
    }
    clampScalar(t, e) {
      return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this.w = Math.max(t, Math.min(e, this.w)), this;
    }
    clampLength(t, e) {
      const n = this.length();
      return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)));
    }
    floor() {
      return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
    }
    ceil() {
      return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
    }
    round() {
      return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
    }
    roundToZero() {
      return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this;
    }
    negate() {
      return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
    }
    dot(t) {
      return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w;
    }
    lengthSq() {
      return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
    }
    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
    }
    manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
    }
    normalize() {
      return this.divideScalar(this.length() || 1);
    }
    setLength(t) {
      return this.normalize().multiplyScalar(t);
    }
    lerp(t, e) {
      return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this;
    }
    lerpVectors(t, e, n) {
      return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this.z = t.z + (e.z - t.z) * n, this.w = t.w + (e.w - t.w) * n, this;
    }
    equals(t) {
      return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w;
    }
    fromArray(t, e = 0) {
      return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this;
    }
    toArray(t = [], e = 0) {
      return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t;
    }
    fromBufferAttribute(t, e) {
      return this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this.w = t.getW(e), this;
    }
    random() {
      return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
    }
    *[Symbol.iterator]() {
      yield this.x, yield this.y, yield this.z, yield this.w;
    }
  }
  class Vf extends Gi {
    constructor(t = 1, e = 1, n = {}) {
      super(), this.isRenderTarget = true, this.width = t, this.height = e, this.depth = 1, this.scissor = new de(0, 0, t, e), this.scissorTest = false, this.viewport = new de(0, 0, t, e);
      const i = {
        width: t,
        height: e,
        depth: 1
      };
      n = Object.assign({
        generateMipmaps: false,
        internalFormat: null,
        minFilter: dn,
        depthBuffer: true,
        stencilBuffer: false,
        resolveDepthBuffer: true,
        resolveStencilBuffer: true,
        depthTexture: null,
        samples: 0,
        count: 1
      }, n);
      const s = new Ne(i, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.colorSpace);
      s.flipY = false, s.generateMipmaps = n.generateMipmaps, s.internalFormat = n.internalFormat, this.textures = [];
      const a = n.count;
      for (let o = 0; o < a; o++) this.textures[o] = s.clone(), this.textures[o].isRenderTargetTexture = true;
      this.depthBuffer = n.depthBuffer, this.stencilBuffer = n.stencilBuffer, this.resolveDepthBuffer = n.resolveDepthBuffer, this.resolveStencilBuffer = n.resolveStencilBuffer, this.depthTexture = n.depthTexture, this.samples = n.samples;
    }
    get texture() {
      return this.textures[0];
    }
    set texture(t) {
      this.textures[0] = t;
    }
    setSize(t, e, n = 1) {
      if (this.width !== t || this.height !== e || this.depth !== n) {
        this.width = t, this.height = e, this.depth = n;
        for (let i = 0, s = this.textures.length; i < s; i++) this.textures[i].image.width = t, this.textures[i].image.height = e, this.textures[i].image.depth = n;
        this.dispose();
      }
      this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e);
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(t) {
      this.width = t.width, this.height = t.height, this.depth = t.depth, this.scissor.copy(t.scissor), this.scissorTest = t.scissorTest, this.viewport.copy(t.viewport), this.textures.length = 0;
      for (let n = 0, i = t.textures.length; n < i; n++) this.textures[n] = t.textures[n].clone(), this.textures[n].isRenderTargetTexture = true;
      const e = Object.assign({}, t.texture.image);
      return this.texture.source = new Su(e), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, this.resolveDepthBuffer = t.resolveDepthBuffer, this.resolveStencilBuffer = t.resolveStencilBuffer, t.depthTexture !== null && (this.depthTexture = t.depthTexture.clone()), this.samples = t.samples, this;
    }
    dispose() {
      this.dispatchEvent({
        type: "dispose"
      });
    }
  }
  class Bi extends Vf {
    constructor(t = 1, e = 1, n = {}) {
      super(t, e, n), this.isWebGLRenderTarget = true;
    }
  }
  class Mu extends Ne {
    constructor(t = null, e = 1, n = 1, i = 1) {
      super(null), this.isDataArrayTexture = true, this.image = {
        data: t,
        width: e,
        height: n,
        depth: i
      }, this.magFilter = en, this.minFilter = en, this.wrapR = wi, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1, this.layerUpdates = /* @__PURE__ */ new Set();
    }
    addLayerUpdate(t) {
      this.layerUpdates.add(t);
    }
    clearLayerUpdates() {
      this.layerUpdates.clear();
    }
  }
  class Wf extends Ne {
    constructor(t = null, e = 1, n = 1, i = 1) {
      super(null), this.isData3DTexture = true, this.image = {
        data: t,
        width: e,
        height: n,
        depth: i
      }, this.magFilter = en, this.minFilter = en, this.wrapR = wi, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1;
    }
  }
  let Ve = class {
    constructor(t = 0, e = 0, n = 0, i = 1) {
      this.isQuaternion = true, this._x = t, this._y = e, this._z = n, this._w = i;
    }
    static slerpFlat(t, e, n, i, s, a, o) {
      let c = n[i + 0], l = n[i + 1], h = n[i + 2], d = n[i + 3];
      const u = s[a + 0], p = s[a + 1], w = s[a + 2], b = s[a + 3];
      if (o === 0) {
        t[e + 0] = c, t[e + 1] = l, t[e + 2] = h, t[e + 3] = d;
        return;
      }
      if (o === 1) {
        t[e + 0] = u, t[e + 1] = p, t[e + 2] = w, t[e + 3] = b;
        return;
      }
      if (d !== b || c !== u || l !== p || h !== w) {
        let m = 1 - o;
        const _ = c * u + l * p + h * w + d * b, E = _ >= 0 ? 1 : -1, v = 1 - _ * _;
        if (v > Number.EPSILON) {
          const O = Math.sqrt(v), R = Math.atan2(O, _ * E);
          m = Math.sin(m * R) / O, o = Math.sin(o * R) / O;
        }
        const T = o * E;
        if (c = c * m + u * T, l = l * m + p * T, h = h * m + w * T, d = d * m + b * T, m === 1 - o) {
          const O = 1 / Math.sqrt(c * c + l * l + h * h + d * d);
          c *= O, l *= O, h *= O, d *= O;
        }
      }
      t[e] = c, t[e + 1] = l, t[e + 2] = h, t[e + 3] = d;
    }
    static multiplyQuaternionsFlat(t, e, n, i, s, a) {
      const o = n[i], c = n[i + 1], l = n[i + 2], h = n[i + 3], d = s[a], u = s[a + 1], p = s[a + 2], w = s[a + 3];
      return t[e] = o * w + h * d + c * p - l * u, t[e + 1] = c * w + h * u + l * d - o * p, t[e + 2] = l * w + h * p + o * u - c * d, t[e + 3] = h * w - o * d - c * u - l * p, t;
    }
    get x() {
      return this._x;
    }
    set x(t) {
      this._x = t, this._onChangeCallback();
    }
    get y() {
      return this._y;
    }
    set y(t) {
      this._y = t, this._onChangeCallback();
    }
    get z() {
      return this._z;
    }
    set z(t) {
      this._z = t, this._onChangeCallback();
    }
    get w() {
      return this._w;
    }
    set w(t) {
      this._w = t, this._onChangeCallback();
    }
    set(t, e, n, i) {
      return this._x = t, this._y = e, this._z = n, this._w = i, this._onChangeCallback(), this;
    }
    clone() {
      return new this.constructor(this._x, this._y, this._z, this._w);
    }
    copy(t) {
      return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this._onChangeCallback(), this;
    }
    setFromEuler(t, e = true) {
      const n = t._x, i = t._y, s = t._z, a = t._order, o = Math.cos, c = Math.sin, l = o(n / 2), h = o(i / 2), d = o(s / 2), u = c(n / 2), p = c(i / 2), w = c(s / 2);
      switch (a) {
        case "XYZ":
          this._x = u * h * d + l * p * w, this._y = l * p * d - u * h * w, this._z = l * h * w + u * p * d, this._w = l * h * d - u * p * w;
          break;
        case "YXZ":
          this._x = u * h * d + l * p * w, this._y = l * p * d - u * h * w, this._z = l * h * w - u * p * d, this._w = l * h * d + u * p * w;
          break;
        case "ZXY":
          this._x = u * h * d - l * p * w, this._y = l * p * d + u * h * w, this._z = l * h * w + u * p * d, this._w = l * h * d - u * p * w;
          break;
        case "ZYX":
          this._x = u * h * d - l * p * w, this._y = l * p * d + u * h * w, this._z = l * h * w - u * p * d, this._w = l * h * d + u * p * w;
          break;
        case "YZX":
          this._x = u * h * d + l * p * w, this._y = l * p * d + u * h * w, this._z = l * h * w - u * p * d, this._w = l * h * d - u * p * w;
          break;
        case "XZY":
          this._x = u * h * d - l * p * w, this._y = l * p * d - u * h * w, this._z = l * h * w + u * p * d, this._w = l * h * d + u * p * w;
          break;
        default:
          console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + a);
      }
      return e === true && this._onChangeCallback(), this;
    }
    setFromAxisAngle(t, e) {
      const n = e / 2, i = Math.sin(n);
      return this._x = t.x * i, this._y = t.y * i, this._z = t.z * i, this._w = Math.cos(n), this._onChangeCallback(), this;
    }
    setFromRotationMatrix(t) {
      const e = t.elements, n = e[0], i = e[4], s = e[8], a = e[1], o = e[5], c = e[9], l = e[2], h = e[6], d = e[10], u = n + o + d;
      if (u > 0) {
        const p = 0.5 / Math.sqrt(u + 1);
        this._w = 0.25 / p, this._x = (h - c) * p, this._y = (s - l) * p, this._z = (a - i) * p;
      } else if (n > o && n > d) {
        const p = 2 * Math.sqrt(1 + n - o - d);
        this._w = (h - c) / p, this._x = 0.25 * p, this._y = (i + a) / p, this._z = (s + l) / p;
      } else if (o > d) {
        const p = 2 * Math.sqrt(1 + o - n - d);
        this._w = (s - l) / p, this._x = (i + a) / p, this._y = 0.25 * p, this._z = (c + h) / p;
      } else {
        const p = 2 * Math.sqrt(1 + d - n - o);
        this._w = (a - i) / p, this._x = (s + l) / p, this._y = (c + h) / p, this._z = 0.25 * p;
      }
      return this._onChangeCallback(), this;
    }
    setFromUnitVectors(t, e) {
      let n = t.dot(e) + 1;
      return n < Number.EPSILON ? (n = 0, Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y, this._y = t.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -t.z, this._z = t.y, this._w = n)) : (this._x = t.y * e.z - t.z * e.y, this._y = t.z * e.x - t.x * e.z, this._z = t.x * e.y - t.y * e.x, this._w = n), this.normalize();
    }
    angleTo(t) {
      return 2 * Math.acos(Math.abs(Ge(this.dot(t), -1, 1)));
    }
    rotateTowards(t, e) {
      const n = this.angleTo(t);
      if (n === 0) return this;
      const i = Math.min(1, e / n);
      return this.slerp(t, i), this;
    }
    identity() {
      return this.set(0, 0, 0, 1);
    }
    invert() {
      return this.conjugate();
    }
    conjugate() {
      return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
    }
    dot(t) {
      return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w;
    }
    lengthSq() {
      return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
    }
    length() {
      return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
    }
    normalize() {
      let t = this.length();
      return t === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t = 1 / t, this._x = this._x * t, this._y = this._y * t, this._z = this._z * t, this._w = this._w * t), this._onChangeCallback(), this;
    }
    multiply(t) {
      return this.multiplyQuaternions(this, t);
    }
    premultiply(t) {
      return this.multiplyQuaternions(t, this);
    }
    multiplyQuaternions(t, e) {
      const n = t._x, i = t._y, s = t._z, a = t._w, o = e._x, c = e._y, l = e._z, h = e._w;
      return this._x = n * h + a * o + i * l - s * c, this._y = i * h + a * c + s * o - n * l, this._z = s * h + a * l + n * c - i * o, this._w = a * h - n * o - i * c - s * l, this._onChangeCallback(), this;
    }
    slerp(t, e) {
      if (e === 0) return this;
      if (e === 1) return this.copy(t);
      const n = this._x, i = this._y, s = this._z, a = this._w;
      let o = a * t._w + n * t._x + i * t._y + s * t._z;
      if (o < 0 ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, o = -o) : this.copy(t), o >= 1) return this._w = a, this._x = n, this._y = i, this._z = s, this;
      const c = 1 - o * o;
      if (c <= Number.EPSILON) {
        const p = 1 - e;
        return this._w = p * a + e * this._w, this._x = p * n + e * this._x, this._y = p * i + e * this._y, this._z = p * s + e * this._z, this.normalize(), this;
      }
      const l = Math.sqrt(c), h = Math.atan2(l, o), d = Math.sin((1 - e) * h) / l, u = Math.sin(e * h) / l;
      return this._w = a * d + this._w * u, this._x = n * d + this._x * u, this._y = i * d + this._y * u, this._z = s * d + this._z * u, this._onChangeCallback(), this;
    }
    slerpQuaternions(t, e, n) {
      return this.copy(t).slerp(e, n);
    }
    random() {
      const t = 2 * Math.PI * Math.random(), e = 2 * Math.PI * Math.random(), n = Math.random(), i = Math.sqrt(1 - n), s = Math.sqrt(n);
      return this.set(i * Math.sin(t), i * Math.cos(t), s * Math.sin(e), s * Math.cos(e));
    }
    equals(t) {
      return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w;
    }
    fromArray(t, e = 0) {
      return this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this._onChangeCallback(), this;
    }
    toArray(t = [], e = 0) {
      return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t;
    }
    fromBufferAttribute(t, e) {
      return this._x = t.getX(e), this._y = t.getY(e), this._z = t.getZ(e), this._w = t.getW(e), this._onChangeCallback(), this;
    }
    toJSON() {
      return this.toArray();
    }
    _onChange(t) {
      return this._onChangeCallback = t, this;
    }
    _onChangeCallback() {
    }
    *[Symbol.iterator]() {
      yield this._x, yield this._y, yield this._z, yield this._w;
    }
  }, L = class Eu {
    constructor(t = 0, e = 0, n = 0) {
      Eu.prototype.isVector3 = true, this.x = t, this.y = e, this.z = n;
    }
    set(t, e, n) {
      return n === void 0 && (n = this.z), this.x = t, this.y = e, this.z = n, this;
    }
    setScalar(t) {
      return this.x = t, this.y = t, this.z = t, this;
    }
    setX(t) {
      return this.x = t, this;
    }
    setY(t) {
      return this.y = t, this;
    }
    setZ(t) {
      return this.z = t, this;
    }
    setComponent(t, e) {
      switch (t) {
        case 0:
          this.x = e;
          break;
        case 1:
          this.y = e;
          break;
        case 2:
          this.z = e;
          break;
        default:
          throw new Error("index is out of range: " + t);
      }
      return this;
    }
    getComponent(t) {
      switch (t) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        case 2:
          return this.z;
        default:
          throw new Error("index is out of range: " + t);
      }
    }
    clone() {
      return new this.constructor(this.x, this.y, this.z);
    }
    copy(t) {
      return this.x = t.x, this.y = t.y, this.z = t.z, this;
    }
    add(t) {
      return this.x += t.x, this.y += t.y, this.z += t.z, this;
    }
    addScalar(t) {
      return this.x += t, this.y += t, this.z += t, this;
    }
    addVectors(t, e) {
      return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this;
    }
    addScaledVector(t, e) {
      return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this;
    }
    sub(t) {
      return this.x -= t.x, this.y -= t.y, this.z -= t.z, this;
    }
    subScalar(t) {
      return this.x -= t, this.y -= t, this.z -= t, this;
    }
    subVectors(t, e) {
      return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this;
    }
    multiply(t) {
      return this.x *= t.x, this.y *= t.y, this.z *= t.z, this;
    }
    multiplyScalar(t) {
      return this.x *= t, this.y *= t, this.z *= t, this;
    }
    multiplyVectors(t, e) {
      return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this;
    }
    applyEuler(t) {
      return this.applyQuaternion(wh.setFromEuler(t));
    }
    applyAxisAngle(t, e) {
      return this.applyQuaternion(wh.setFromAxisAngle(t, e));
    }
    applyMatrix3(t) {
      const e = this.x, n = this.y, i = this.z, s = t.elements;
      return this.x = s[0] * e + s[3] * n + s[6] * i, this.y = s[1] * e + s[4] * n + s[7] * i, this.z = s[2] * e + s[5] * n + s[8] * i, this;
    }
    applyNormalMatrix(t) {
      return this.applyMatrix3(t).normalize();
    }
    applyMatrix4(t) {
      const e = this.x, n = this.y, i = this.z, s = t.elements, a = 1 / (s[3] * e + s[7] * n + s[11] * i + s[15]);
      return this.x = (s[0] * e + s[4] * n + s[8] * i + s[12]) * a, this.y = (s[1] * e + s[5] * n + s[9] * i + s[13]) * a, this.z = (s[2] * e + s[6] * n + s[10] * i + s[14]) * a, this;
    }
    applyQuaternion(t) {
      const e = this.x, n = this.y, i = this.z, s = t.x, a = t.y, o = t.z, c = t.w, l = 2 * (a * i - o * n), h = 2 * (o * e - s * i), d = 2 * (s * n - a * e);
      return this.x = e + c * l + a * d - o * h, this.y = n + c * h + o * l - s * d, this.z = i + c * d + s * h - a * l, this;
    }
    project(t) {
      return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix);
    }
    unproject(t) {
      return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld);
    }
    transformDirection(t) {
      const e = this.x, n = this.y, i = this.z, s = t.elements;
      return this.x = s[0] * e + s[4] * n + s[8] * i, this.y = s[1] * e + s[5] * n + s[9] * i, this.z = s[2] * e + s[6] * n + s[10] * i, this.normalize();
    }
    divide(t) {
      return this.x /= t.x, this.y /= t.y, this.z /= t.z, this;
    }
    divideScalar(t) {
      return this.multiplyScalar(1 / t);
    }
    min(t) {
      return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this;
    }
    max(t) {
      return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this;
    }
    clamp(t, e) {
      return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this;
    }
    clampScalar(t, e) {
      return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this;
    }
    clampLength(t, e) {
      const n = this.length();
      return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)));
    }
    floor() {
      return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
    }
    ceil() {
      return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
    }
    round() {
      return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
    }
    roundToZero() {
      return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this;
    }
    negate() {
      return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
    }
    dot(t) {
      return this.x * t.x + this.y * t.y + this.z * t.z;
    }
    lengthSq() {
      return this.x * this.x + this.y * this.y + this.z * this.z;
    }
    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    }
    manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
    }
    normalize() {
      return this.divideScalar(this.length() || 1);
    }
    setLength(t) {
      return this.normalize().multiplyScalar(t);
    }
    lerp(t, e) {
      return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this;
    }
    lerpVectors(t, e, n) {
      return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this.z = t.z + (e.z - t.z) * n, this;
    }
    cross(t) {
      return this.crossVectors(this, t);
    }
    crossVectors(t, e) {
      const n = t.x, i = t.y, s = t.z, a = e.x, o = e.y, c = e.z;
      return this.x = i * c - s * o, this.y = s * a - n * c, this.z = n * o - i * a, this;
    }
    projectOnVector(t) {
      const e = t.lengthSq();
      if (e === 0) return this.set(0, 0, 0);
      const n = t.dot(this) / e;
      return this.copy(t).multiplyScalar(n);
    }
    projectOnPlane(t) {
      return Co.copy(this).projectOnVector(t), this.sub(Co);
    }
    reflect(t) {
      return this.sub(Co.copy(t).multiplyScalar(2 * this.dot(t)));
    }
    angleTo(t) {
      const e = Math.sqrt(this.lengthSq() * t.lengthSq());
      if (e === 0) return Math.PI / 2;
      const n = this.dot(t) / e;
      return Math.acos(Ge(n, -1, 1));
    }
    distanceTo(t) {
      return Math.sqrt(this.distanceToSquared(t));
    }
    distanceToSquared(t) {
      const e = this.x - t.x, n = this.y - t.y, i = this.z - t.z;
      return e * e + n * n + i * i;
    }
    manhattanDistanceTo(t) {
      return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z);
    }
    setFromSpherical(t) {
      return this.setFromSphericalCoords(t.radius, t.phi, t.theta);
    }
    setFromSphericalCoords(t, e, n) {
      const i = Math.sin(e) * t;
      return this.x = i * Math.sin(n), this.y = Math.cos(e) * t, this.z = i * Math.cos(n), this;
    }
    setFromCylindrical(t) {
      return this.setFromCylindricalCoords(t.radius, t.theta, t.y);
    }
    setFromCylindricalCoords(t, e, n) {
      return this.x = t * Math.sin(e), this.y = n, this.z = t * Math.cos(e), this;
    }
    setFromMatrixPosition(t) {
      const e = t.elements;
      return this.x = e[12], this.y = e[13], this.z = e[14], this;
    }
    setFromMatrixScale(t) {
      const e = this.setFromMatrixColumn(t, 0).length(), n = this.setFromMatrixColumn(t, 1).length(), i = this.setFromMatrixColumn(t, 2).length();
      return this.x = e, this.y = n, this.z = i, this;
    }
    setFromMatrixColumn(t, e) {
      return this.fromArray(t.elements, e * 4);
    }
    setFromMatrix3Column(t, e) {
      return this.fromArray(t.elements, e * 3);
    }
    setFromEuler(t) {
      return this.x = t._x, this.y = t._y, this.z = t._z, this;
    }
    setFromColor(t) {
      return this.x = t.r, this.y = t.g, this.z = t.b, this;
    }
    equals(t) {
      return t.x === this.x && t.y === this.y && t.z === this.z;
    }
    fromArray(t, e = 0) {
      return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this;
    }
    toArray(t = [], e = 0) {
      return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t;
    }
    fromBufferAttribute(t, e) {
      return this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this;
    }
    random() {
      return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
    }
    randomDirection() {
      const t = Math.random() * Math.PI * 2, e = Math.random() * 2 - 1, n = Math.sqrt(1 - e * e);
      return this.x = n * Math.cos(t), this.y = e, this.z = n * Math.sin(t), this;
    }
    *[Symbol.iterator]() {
      yield this.x, yield this.y, yield this.z;
    }
  };
  const Co = new L(), wh = new Ve();
  class Fn {
    constructor(t = new L(1 / 0, 1 / 0, 1 / 0), e = new L(-1 / 0, -1 / 0, -1 / 0)) {
      this.isBox3 = true, this.min = t, this.max = e;
    }
    set(t, e) {
      return this.min.copy(t), this.max.copy(e), this;
    }
    setFromArray(t) {
      this.makeEmpty();
      for (let e = 0, n = t.length; e < n; e += 3) this.expandByPoint(bn.fromArray(t, e));
      return this;
    }
    setFromBufferAttribute(t) {
      this.makeEmpty();
      for (let e = 0, n = t.count; e < n; e++) this.expandByPoint(bn.fromBufferAttribute(t, e));
      return this;
    }
    setFromPoints(t) {
      this.makeEmpty();
      for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
      return this;
    }
    setFromCenterAndSize(t, e) {
      const n = bn.copy(e).multiplyScalar(0.5);
      return this.min.copy(t).sub(n), this.max.copy(t).add(n), this;
    }
    setFromObject(t, e = false) {
      return this.makeEmpty(), this.expandByObject(t, e);
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(t) {
      return this.min.copy(t.min), this.max.copy(t.max), this;
    }
    makeEmpty() {
      return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
    }
    isEmpty() {
      return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
    }
    getCenter(t) {
      return this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(0.5);
    }
    getSize(t) {
      return this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min);
    }
    expandByPoint(t) {
      return this.min.min(t), this.max.max(t), this;
    }
    expandByVector(t) {
      return this.min.sub(t), this.max.add(t), this;
    }
    expandByScalar(t) {
      return this.min.addScalar(-t), this.max.addScalar(t), this;
    }
    expandByObject(t, e = false) {
      t.updateWorldMatrix(false, false);
      const n = t.geometry;
      if (n !== void 0) {
        const s = n.getAttribute("position");
        if (e === true && s !== void 0 && t.isInstancedMesh !== true) for (let a = 0, o = s.count; a < o; a++) t.isMesh === true ? t.getVertexPosition(a, bn) : bn.fromBufferAttribute(s, a), bn.applyMatrix4(t.matrixWorld), this.expandByPoint(bn);
        else t.boundingBox !== void 0 ? (t.boundingBox === null && t.computeBoundingBox(), As.copy(t.boundingBox)) : (n.boundingBox === null && n.computeBoundingBox(), As.copy(n.boundingBox)), As.applyMatrix4(t.matrixWorld), this.union(As);
      }
      const i = t.children;
      for (let s = 0, a = i.length; s < a; s++) this.expandByObject(i[s], e);
      return this;
    }
    containsPoint(t) {
      return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z);
    }
    containsBox(t) {
      return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z;
    }
    getParameter(t, e) {
      return e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z));
    }
    intersectsBox(t) {
      return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z);
    }
    intersectsSphere(t) {
      return this.clampPoint(t.center, bn), bn.distanceToSquared(t.center) <= t.radius * t.radius;
    }
    intersectsPlane(t) {
      let e, n;
      return t.normal.x > 0 ? (e = t.normal.x * this.min.x, n = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x, n = t.normal.x * this.min.x), t.normal.y > 0 ? (e += t.normal.y * this.min.y, n += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y, n += t.normal.y * this.min.y), t.normal.z > 0 ? (e += t.normal.z * this.min.z, n += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z, n += t.normal.z * this.min.z), e <= -t.constant && n >= -t.constant;
    }
    intersectsTriangle(t) {
      if (this.isEmpty()) return false;
      this.getCenter(Hr), Rs.subVectors(this.max, Hr), Ki.subVectors(t.a, Hr), Yi.subVectors(t.b, Hr), Zi.subVectors(t.c, Hr), oi.subVectors(Yi, Ki), ci.subVectors(Zi, Yi), Ai.subVectors(Ki, Zi);
      let e = [
        0,
        -oi.z,
        oi.y,
        0,
        -ci.z,
        ci.y,
        0,
        -Ai.z,
        Ai.y,
        oi.z,
        0,
        -oi.x,
        ci.z,
        0,
        -ci.x,
        Ai.z,
        0,
        -Ai.x,
        -oi.y,
        oi.x,
        0,
        -ci.y,
        ci.x,
        0,
        -Ai.y,
        Ai.x,
        0
      ];
      return !Po(e, Ki, Yi, Zi, Rs) || (e = [
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1
      ], !Po(e, Ki, Yi, Zi, Rs)) ? false : (Cs.crossVectors(oi, ci), e = [
        Cs.x,
        Cs.y,
        Cs.z
      ], Po(e, Ki, Yi, Zi, Rs));
    }
    clampPoint(t, e) {
      return e.copy(t).clamp(this.min, this.max);
    }
    distanceToPoint(t) {
      return this.clampPoint(t, bn).distanceTo(t);
    }
    getBoundingSphere(t) {
      return this.isEmpty() ? t.makeEmpty() : (this.getCenter(t.center), t.radius = this.getSize(bn).length() * 0.5), t;
    }
    intersect(t) {
      return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this;
    }
    union(t) {
      return this.min.min(t.min), this.max.max(t.max), this;
    }
    applyMatrix4(t) {
      return this.isEmpty() ? this : (Hn[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), Hn[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), Hn[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), Hn[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), Hn[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), Hn[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), Hn[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), Hn[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.setFromPoints(Hn), this);
    }
    translate(t) {
      return this.min.add(t), this.max.add(t), this;
    }
    equals(t) {
      return t.min.equals(this.min) && t.max.equals(this.max);
    }
  }
  const Hn = [
    new L(),
    new L(),
    new L(),
    new L(),
    new L(),
    new L(),
    new L(),
    new L()
  ], bn = new L(), As = new Fn(), Ki = new L(), Yi = new L(), Zi = new L(), oi = new L(), ci = new L(), Ai = new L(), Hr = new L(), Rs = new L(), Cs = new L(), Ri = new L();
  function Po(r, t, e, n, i) {
    for (let s = 0, a = r.length - 3; s <= a; s += 3) {
      Ri.fromArray(r, s);
      const o = i.x * Math.abs(Ri.x) + i.y * Math.abs(Ri.y) + i.z * Math.abs(Ri.z), c = t.dot(Ri), l = e.dot(Ri), h = n.dot(Ri);
      if (Math.max(-Math.max(c, l, h), Math.min(c, l, h)) > o) return false;
    }
    return true;
  }
  const jf = new Fn(), Gr = new L(), Io = new L();
  class On {
    constructor(t = new L(), e = -1) {
      this.isSphere = true, this.center = t, this.radius = e;
    }
    set(t, e) {
      return this.center.copy(t), this.radius = e, this;
    }
    setFromPoints(t, e) {
      const n = this.center;
      e !== void 0 ? n.copy(e) : jf.setFromPoints(t).getCenter(n);
      let i = 0;
      for (let s = 0, a = t.length; s < a; s++) i = Math.max(i, n.distanceToSquared(t[s]));
      return this.radius = Math.sqrt(i), this;
    }
    copy(t) {
      return this.center.copy(t.center), this.radius = t.radius, this;
    }
    isEmpty() {
      return this.radius < 0;
    }
    makeEmpty() {
      return this.center.set(0, 0, 0), this.radius = -1, this;
    }
    containsPoint(t) {
      return t.distanceToSquared(this.center) <= this.radius * this.radius;
    }
    distanceToPoint(t) {
      return t.distanceTo(this.center) - this.radius;
    }
    intersectsSphere(t) {
      const e = this.radius + t.radius;
      return t.center.distanceToSquared(this.center) <= e * e;
    }
    intersectsBox(t) {
      return t.intersectsSphere(this);
    }
    intersectsPlane(t) {
      return Math.abs(t.distanceToPoint(this.center)) <= this.radius;
    }
    clampPoint(t, e) {
      const n = this.center.distanceToSquared(t);
      return e.copy(t), n > this.radius * this.radius && (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)), e;
    }
    getBoundingBox(t) {
      return this.isEmpty() ? (t.makeEmpty(), t) : (t.set(this.center, this.center), t.expandByScalar(this.radius), t);
    }
    applyMatrix4(t) {
      return this.center.applyMatrix4(t), this.radius = this.radius * t.getMaxScaleOnAxis(), this;
    }
    translate(t) {
      return this.center.add(t), this;
    }
    expandByPoint(t) {
      if (this.isEmpty()) return this.center.copy(t), this.radius = 0, this;
      Gr.subVectors(t, this.center);
      const e = Gr.lengthSq();
      if (e > this.radius * this.radius) {
        const n = Math.sqrt(e), i = (n - this.radius) * 0.5;
        this.center.addScaledVector(Gr, i / n), this.radius += i;
      }
      return this;
    }
    union(t) {
      return t.isEmpty() ? this : this.isEmpty() ? (this.copy(t), this) : (this.center.equals(t.center) === true ? this.radius = Math.max(this.radius, t.radius) : (Io.subVectors(t.center, this.center).setLength(t.radius), this.expandByPoint(Gr.copy(t.center).add(Io)), this.expandByPoint(Gr.copy(t.center).sub(Io))), this);
    }
    equals(t) {
      return t.center.equals(this.center) && t.radius === this.radius;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  const Gn = new L(), Lo = new L(), Ps = new L(), li = new L(), Do = new L(), Is = new L(), No = new L();
  let bs = class {
    constructor(t = new L(), e = new L(0, 0, -1)) {
      this.origin = t, this.direction = e;
    }
    set(t, e) {
      return this.origin.copy(t), this.direction.copy(e), this;
    }
    copy(t) {
      return this.origin.copy(t.origin), this.direction.copy(t.direction), this;
    }
    at(t, e) {
      return e.copy(this.origin).addScaledVector(this.direction, t);
    }
    lookAt(t) {
      return this.direction.copy(t).sub(this.origin).normalize(), this;
    }
    recast(t) {
      return this.origin.copy(this.at(t, Gn)), this;
    }
    closestPointToPoint(t, e) {
      e.subVectors(t, this.origin);
      const n = e.dot(this.direction);
      return n < 0 ? e.copy(this.origin) : e.copy(this.origin).addScaledVector(this.direction, n);
    }
    distanceToPoint(t) {
      return Math.sqrt(this.distanceSqToPoint(t));
    }
    distanceSqToPoint(t) {
      const e = Gn.subVectors(t, this.origin).dot(this.direction);
      return e < 0 ? this.origin.distanceToSquared(t) : (Gn.copy(this.origin).addScaledVector(this.direction, e), Gn.distanceToSquared(t));
    }
    distanceSqToSegment(t, e, n, i) {
      Lo.copy(t).add(e).multiplyScalar(0.5), Ps.copy(e).sub(t).normalize(), li.copy(this.origin).sub(Lo);
      const s = t.distanceTo(e) * 0.5, a = -this.direction.dot(Ps), o = li.dot(this.direction), c = -li.dot(Ps), l = li.lengthSq(), h = Math.abs(1 - a * a);
      let d, u, p, w;
      if (h > 0) if (d = a * c - o, u = a * o - c, w = s * h, d >= 0) if (u >= -w) if (u <= w) {
        const b = 1 / h;
        d *= b, u *= b, p = d * (d + a * u + 2 * o) + u * (a * d + u + 2 * c) + l;
      } else u = s, d = Math.max(0, -(a * u + o)), p = -d * d + u * (u + 2 * c) + l;
      else u = -s, d = Math.max(0, -(a * u + o)), p = -d * d + u * (u + 2 * c) + l;
      else u <= -w ? (d = Math.max(0, -(-a * s + o)), u = d > 0 ? -s : Math.min(Math.max(-s, -c), s), p = -d * d + u * (u + 2 * c) + l) : u <= w ? (d = 0, u = Math.min(Math.max(-s, -c), s), p = u * (u + 2 * c) + l) : (d = Math.max(0, -(a * s + o)), u = d > 0 ? s : Math.min(Math.max(-s, -c), s), p = -d * d + u * (u + 2 * c) + l);
      else u = a > 0 ? -s : s, d = Math.max(0, -(a * u + o)), p = -d * d + u * (u + 2 * c) + l;
      return n && n.copy(this.origin).addScaledVector(this.direction, d), i && i.copy(Lo).addScaledVector(Ps, u), p;
    }
    intersectSphere(t, e) {
      Gn.subVectors(t.center, this.origin);
      const n = Gn.dot(this.direction), i = Gn.dot(Gn) - n * n, s = t.radius * t.radius;
      if (i > s) return null;
      const a = Math.sqrt(s - i), o = n - a, c = n + a;
      return c < 0 ? null : o < 0 ? this.at(c, e) : this.at(o, e);
    }
    intersectsSphere(t) {
      return this.distanceSqToPoint(t.center) <= t.radius * t.radius;
    }
    distanceToPlane(t) {
      const e = t.normal.dot(this.direction);
      if (e === 0) return t.distanceToPoint(this.origin) === 0 ? 0 : null;
      const n = -(this.origin.dot(t.normal) + t.constant) / e;
      return n >= 0 ? n : null;
    }
    intersectPlane(t, e) {
      const n = this.distanceToPlane(t);
      return n === null ? null : this.at(n, e);
    }
    intersectsPlane(t) {
      const e = t.distanceToPoint(this.origin);
      return e === 0 || t.normal.dot(this.direction) * e < 0;
    }
    intersectBox(t, e) {
      let n, i, s, a, o, c;
      const l = 1 / this.direction.x, h = 1 / this.direction.y, d = 1 / this.direction.z, u = this.origin;
      return l >= 0 ? (n = (t.min.x - u.x) * l, i = (t.max.x - u.x) * l) : (n = (t.max.x - u.x) * l, i = (t.min.x - u.x) * l), h >= 0 ? (s = (t.min.y - u.y) * h, a = (t.max.y - u.y) * h) : (s = (t.max.y - u.y) * h, a = (t.min.y - u.y) * h), n > a || s > i || ((s > n || isNaN(n)) && (n = s), (a < i || isNaN(i)) && (i = a), d >= 0 ? (o = (t.min.z - u.z) * d, c = (t.max.z - u.z) * d) : (o = (t.max.z - u.z) * d, c = (t.min.z - u.z) * d), n > c || o > i) || ((o > n || n !== n) && (n = o), (c < i || i !== i) && (i = c), i < 0) ? null : this.at(n >= 0 ? n : i, e);
    }
    intersectsBox(t) {
      return this.intersectBox(t, Gn) !== null;
    }
    intersectTriangle(t, e, n, i, s) {
      Do.subVectors(e, t), Is.subVectors(n, t), No.crossVectors(Do, Is);
      let a = this.direction.dot(No), o;
      if (a > 0) {
        if (i) return null;
        o = 1;
      } else if (a < 0) o = -1, a = -a;
      else return null;
      li.subVectors(this.origin, t);
      const c = o * this.direction.dot(Is.crossVectors(li, Is));
      if (c < 0) return null;
      const l = o * this.direction.dot(Do.cross(li));
      if (l < 0 || c + l > a) return null;
      const h = -o * li.dot(No);
      return h < 0 ? null : this.at(h / a, s);
    }
    applyMatrix4(t) {
      return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this;
    }
    equals(t) {
      return t.origin.equals(this.origin) && t.direction.equals(this.direction);
    }
    clone() {
      return new this.constructor().copy(this);
    }
  };
  class Ht {
    constructor(t, e, n, i, s, a, o, c, l, h, d, u, p, w, b, m) {
      Ht.prototype.isMatrix4 = true, this.elements = [
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
      ], t !== void 0 && this.set(t, e, n, i, s, a, o, c, l, h, d, u, p, w, b, m);
    }
    set(t, e, n, i, s, a, o, c, l, h, d, u, p, w, b, m) {
      const _ = this.elements;
      return _[0] = t, _[4] = e, _[8] = n, _[12] = i, _[1] = s, _[5] = a, _[9] = o, _[13] = c, _[2] = l, _[6] = h, _[10] = d, _[14] = u, _[3] = p, _[7] = w, _[11] = b, _[15] = m, this;
    }
    identity() {
      return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
    }
    clone() {
      return new Ht().fromArray(this.elements);
    }
    copy(t) {
      const e = this.elements, n = t.elements;
      return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], e[9] = n[9], e[10] = n[10], e[11] = n[11], e[12] = n[12], e[13] = n[13], e[14] = n[14], e[15] = n[15], this;
    }
    copyPosition(t) {
      const e = this.elements, n = t.elements;
      return e[12] = n[12], e[13] = n[13], e[14] = n[14], this;
    }
    setFromMatrix3(t) {
      const e = t.elements;
      return this.set(e[0], e[3], e[6], 0, e[1], e[4], e[7], 0, e[2], e[5], e[8], 0, 0, 0, 0, 1), this;
    }
    extractBasis(t, e, n) {
      return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this;
    }
    makeBasis(t, e, n) {
      return this.set(t.x, e.x, n.x, 0, t.y, e.y, n.y, 0, t.z, e.z, n.z, 0, 0, 0, 0, 1), this;
    }
    extractRotation(t) {
      const e = this.elements, n = t.elements, i = 1 / $i.setFromMatrixColumn(t, 0).length(), s = 1 / $i.setFromMatrixColumn(t, 1).length(), a = 1 / $i.setFromMatrixColumn(t, 2).length();
      return e[0] = n[0] * i, e[1] = n[1] * i, e[2] = n[2] * i, e[3] = 0, e[4] = n[4] * s, e[5] = n[5] * s, e[6] = n[6] * s, e[7] = 0, e[8] = n[8] * a, e[9] = n[9] * a, e[10] = n[10] * a, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this;
    }
    makeRotationFromEuler(t) {
      const e = this.elements, n = t.x, i = t.y, s = t.z, a = Math.cos(n), o = Math.sin(n), c = Math.cos(i), l = Math.sin(i), h = Math.cos(s), d = Math.sin(s);
      if (t.order === "XYZ") {
        const u = a * h, p = a * d, w = o * h, b = o * d;
        e[0] = c * h, e[4] = -c * d, e[8] = l, e[1] = p + w * l, e[5] = u - b * l, e[9] = -o * c, e[2] = b - u * l, e[6] = w + p * l, e[10] = a * c;
      } else if (t.order === "YXZ") {
        const u = c * h, p = c * d, w = l * h, b = l * d;
        e[0] = u + b * o, e[4] = w * o - p, e[8] = a * l, e[1] = a * d, e[5] = a * h, e[9] = -o, e[2] = p * o - w, e[6] = b + u * o, e[10] = a * c;
      } else if (t.order === "ZXY") {
        const u = c * h, p = c * d, w = l * h, b = l * d;
        e[0] = u - b * o, e[4] = -a * d, e[8] = w + p * o, e[1] = p + w * o, e[5] = a * h, e[9] = b - u * o, e[2] = -a * l, e[6] = o, e[10] = a * c;
      } else if (t.order === "ZYX") {
        const u = a * h, p = a * d, w = o * h, b = o * d;
        e[0] = c * h, e[4] = w * l - p, e[8] = u * l + b, e[1] = c * d, e[5] = b * l + u, e[9] = p * l - w, e[2] = -l, e[6] = o * c, e[10] = a * c;
      } else if (t.order === "YZX") {
        const u = a * c, p = a * l, w = o * c, b = o * l;
        e[0] = c * h, e[4] = b - u * d, e[8] = w * d + p, e[1] = d, e[5] = a * h, e[9] = -o * h, e[2] = -l * h, e[6] = p * d + w, e[10] = u - b * d;
      } else if (t.order === "XZY") {
        const u = a * c, p = a * l, w = o * c, b = o * l;
        e[0] = c * h, e[4] = -d, e[8] = l * h, e[1] = u * d + b, e[5] = a * h, e[9] = p * d - w, e[2] = w * d - p, e[6] = o * h, e[10] = b * d + u;
      }
      return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this;
    }
    makeRotationFromQuaternion(t) {
      return this.compose(Xf, t, qf);
    }
    lookAt(t, e, n) {
      const i = this.elements;
      return ln.subVectors(t, e), ln.lengthSq() === 0 && (ln.z = 1), ln.normalize(), hi.crossVectors(n, ln), hi.lengthSq() === 0 && (Math.abs(n.z) === 1 ? ln.x += 1e-4 : ln.z += 1e-4, ln.normalize(), hi.crossVectors(n, ln)), hi.normalize(), Ls.crossVectors(ln, hi), i[0] = hi.x, i[4] = Ls.x, i[8] = ln.x, i[1] = hi.y, i[5] = Ls.y, i[9] = ln.y, i[2] = hi.z, i[6] = Ls.z, i[10] = ln.z, this;
    }
    multiply(t) {
      return this.multiplyMatrices(this, t);
    }
    premultiply(t) {
      return this.multiplyMatrices(t, this);
    }
    multiplyMatrices(t, e) {
      const n = t.elements, i = e.elements, s = this.elements, a = n[0], o = n[4], c = n[8], l = n[12], h = n[1], d = n[5], u = n[9], p = n[13], w = n[2], b = n[6], m = n[10], _ = n[14], E = n[3], v = n[7], T = n[11], O = n[15], R = i[0], P = i[4], z = i[8], A = i[12], S = i[1], F = i[5], W = i[9], V = i[13], Z = i[2], tt = i[6], Y = i[10], J = i[14], $ = i[3], ut = i[7], mt = i[11], gt = i[15];
      return s[0] = a * R + o * S + c * Z + l * $, s[4] = a * P + o * F + c * tt + l * ut, s[8] = a * z + o * W + c * Y + l * mt, s[12] = a * A + o * V + c * J + l * gt, s[1] = h * R + d * S + u * Z + p * $, s[5] = h * P + d * F + u * tt + p * ut, s[9] = h * z + d * W + u * Y + p * mt, s[13] = h * A + d * V + u * J + p * gt, s[2] = w * R + b * S + m * Z + _ * $, s[6] = w * P + b * F + m * tt + _ * ut, s[10] = w * z + b * W + m * Y + _ * mt, s[14] = w * A + b * V + m * J + _ * gt, s[3] = E * R + v * S + T * Z + O * $, s[7] = E * P + v * F + T * tt + O * ut, s[11] = E * z + v * W + T * Y + O * mt, s[15] = E * A + v * V + T * J + O * gt, this;
    }
    multiplyScalar(t) {
      const e = this.elements;
      return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this;
    }
    determinant() {
      const t = this.elements, e = t[0], n = t[4], i = t[8], s = t[12], a = t[1], o = t[5], c = t[9], l = t[13], h = t[2], d = t[6], u = t[10], p = t[14], w = t[3], b = t[7], m = t[11], _ = t[15];
      return w * (+s * c * d - i * l * d - s * o * u + n * l * u + i * o * p - n * c * p) + b * (+e * c * p - e * l * u + s * a * u - i * a * p + i * l * h - s * c * h) + m * (+e * l * d - e * o * p - s * a * d + n * a * p + s * o * h - n * l * h) + _ * (-i * o * h - e * c * d + e * o * u + i * a * d - n * a * u + n * c * h);
    }
    transpose() {
      const t = this.elements;
      let e;
      return e = t[1], t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this;
    }
    setPosition(t, e, n) {
      const i = this.elements;
      return t.isVector3 ? (i[12] = t.x, i[13] = t.y, i[14] = t.z) : (i[12] = t, i[13] = e, i[14] = n), this;
    }
    invert() {
      const t = this.elements, e = t[0], n = t[1], i = t[2], s = t[3], a = t[4], o = t[5], c = t[6], l = t[7], h = t[8], d = t[9], u = t[10], p = t[11], w = t[12], b = t[13], m = t[14], _ = t[15], E = d * m * l - b * u * l + b * c * p - o * m * p - d * c * _ + o * u * _, v = w * u * l - h * m * l - w * c * p + a * m * p + h * c * _ - a * u * _, T = h * b * l - w * d * l + w * o * p - a * b * p - h * o * _ + a * d * _, O = w * d * c - h * b * c - w * o * u + a * b * u + h * o * m - a * d * m, R = e * E + n * v + i * T + s * O;
      if (R === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
      const P = 1 / R;
      return t[0] = E * P, t[1] = (b * u * s - d * m * s - b * i * p + n * m * p + d * i * _ - n * u * _) * P, t[2] = (o * m * s - b * c * s + b * i * l - n * m * l - o * i * _ + n * c * _) * P, t[3] = (d * c * s - o * u * s - d * i * l + n * u * l + o * i * p - n * c * p) * P, t[4] = v * P, t[5] = (h * m * s - w * u * s + w * i * p - e * m * p - h * i * _ + e * u * _) * P, t[6] = (w * c * s - a * m * s - w * i * l + e * m * l + a * i * _ - e * c * _) * P, t[7] = (a * u * s - h * c * s + h * i * l - e * u * l - a * i * p + e * c * p) * P, t[8] = T * P, t[9] = (w * d * s - h * b * s - w * n * p + e * b * p + h * n * _ - e * d * _) * P, t[10] = (a * b * s - w * o * s + w * n * l - e * b * l - a * n * _ + e * o * _) * P, t[11] = (h * o * s - a * d * s - h * n * l + e * d * l + a * n * p - e * o * p) * P, t[12] = O * P, t[13] = (h * b * i - w * d * i + w * n * u - e * b * u - h * n * m + e * d * m) * P, t[14] = (w * o * i - a * b * i - w * n * c + e * b * c + a * n * m - e * o * m) * P, t[15] = (a * d * i - h * o * i + h * n * c - e * d * c - a * n * u + e * o * u) * P, this;
    }
    scale(t) {
      const e = this.elements, n = t.x, i = t.y, s = t.z;
      return e[0] *= n, e[4] *= i, e[8] *= s, e[1] *= n, e[5] *= i, e[9] *= s, e[2] *= n, e[6] *= i, e[10] *= s, e[3] *= n, e[7] *= i, e[11] *= s, this;
    }
    getMaxScaleOnAxis() {
      const t = this.elements, e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2], n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6], i = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
      return Math.sqrt(Math.max(e, n, i));
    }
    makeTranslation(t, e, n) {
      return t.isVector3 ? this.set(1, 0, 0, t.x, 0, 1, 0, t.y, 0, 0, 1, t.z, 0, 0, 0, 1) : this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1), this;
    }
    makeRotationX(t) {
      const e = Math.cos(t), n = Math.sin(t);
      return this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1), this;
    }
    makeRotationY(t) {
      const e = Math.cos(t), n = Math.sin(t);
      return this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1), this;
    }
    makeRotationZ(t) {
      const e = Math.cos(t), n = Math.sin(t);
      return this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
    }
    makeRotationAxis(t, e) {
      const n = Math.cos(e), i = Math.sin(e), s = 1 - n, a = t.x, o = t.y, c = t.z, l = s * a, h = s * o;
      return this.set(l * a + n, l * o - i * c, l * c + i * o, 0, l * o + i * c, h * o + n, h * c - i * a, 0, l * c - i * o, h * c + i * a, s * c * c + n, 0, 0, 0, 0, 1), this;
    }
    makeScale(t, e, n) {
      return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this;
    }
    makeShear(t, e, n, i, s, a) {
      return this.set(1, n, s, 0, t, 1, a, 0, e, i, 1, 0, 0, 0, 0, 1), this;
    }
    compose(t, e, n) {
      const i = this.elements, s = e._x, a = e._y, o = e._z, c = e._w, l = s + s, h = a + a, d = o + o, u = s * l, p = s * h, w = s * d, b = a * h, m = a * d, _ = o * d, E = c * l, v = c * h, T = c * d, O = n.x, R = n.y, P = n.z;
      return i[0] = (1 - (b + _)) * O, i[1] = (p + T) * O, i[2] = (w - v) * O, i[3] = 0, i[4] = (p - T) * R, i[5] = (1 - (u + _)) * R, i[6] = (m + E) * R, i[7] = 0, i[8] = (w + v) * P, i[9] = (m - E) * P, i[10] = (1 - (u + b)) * P, i[11] = 0, i[12] = t.x, i[13] = t.y, i[14] = t.z, i[15] = 1, this;
    }
    decompose(t, e, n) {
      const i = this.elements;
      let s = $i.set(i[0], i[1], i[2]).length();
      const a = $i.set(i[4], i[5], i[6]).length(), o = $i.set(i[8], i[9], i[10]).length();
      this.determinant() < 0 && (s = -s), t.x = i[12], t.y = i[13], t.z = i[14], yn.copy(this);
      const l = 1 / s, h = 1 / a, d = 1 / o;
      return yn.elements[0] *= l, yn.elements[1] *= l, yn.elements[2] *= l, yn.elements[4] *= h, yn.elements[5] *= h, yn.elements[6] *= h, yn.elements[8] *= d, yn.elements[9] *= d, yn.elements[10] *= d, e.setFromRotationMatrix(yn), n.x = s, n.y = a, n.z = o, this;
    }
    makePerspective(t, e, n, i, s, a, o = $n) {
      const c = this.elements, l = 2 * s / (e - t), h = 2 * s / (n - i), d = (e + t) / (e - t), u = (n + i) / (n - i);
      let p, w;
      if (o === $n) p = -(a + s) / (a - s), w = -2 * a * s / (a - s);
      else if (o === ba) p = -a / (a - s), w = -a * s / (a - s);
      else throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + o);
      return c[0] = l, c[4] = 0, c[8] = d, c[12] = 0, c[1] = 0, c[5] = h, c[9] = u, c[13] = 0, c[2] = 0, c[6] = 0, c[10] = p, c[14] = w, c[3] = 0, c[7] = 0, c[11] = -1, c[15] = 0, this;
    }
    makeOrthographic(t, e, n, i, s, a, o = $n) {
      const c = this.elements, l = 1 / (e - t), h = 1 / (n - i), d = 1 / (a - s), u = (e + t) * l, p = (n + i) * h;
      let w, b;
      if (o === $n) w = (a + s) * d, b = -2 * d;
      else if (o === ba) w = s * d, b = -1 * d;
      else throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + o);
      return c[0] = 2 * l, c[4] = 0, c[8] = 0, c[12] = -u, c[1] = 0, c[5] = 2 * h, c[9] = 0, c[13] = -p, c[2] = 0, c[6] = 0, c[10] = b, c[14] = -w, c[3] = 0, c[7] = 0, c[11] = 0, c[15] = 1, this;
    }
    equals(t) {
      const e = this.elements, n = t.elements;
      for (let i = 0; i < 16; i++) if (e[i] !== n[i]) return false;
      return true;
    }
    fromArray(t, e = 0) {
      for (let n = 0; n < 16; n++) this.elements[n] = t[n + e];
      return this;
    }
    toArray(t = [], e = 0) {
      const n = this.elements;
      return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t[e + 9] = n[9], t[e + 10] = n[10], t[e + 11] = n[11], t[e + 12] = n[12], t[e + 13] = n[13], t[e + 14] = n[14], t[e + 15] = n[15], t;
    }
  }
  const $i = new L(), yn = new Ht(), Xf = new L(0, 0, 0), qf = new L(1, 1, 1), hi = new L(), Ls = new L(), ln = new L(), bh = new Ht(), yh = new Ve();
  class Pn {
    constructor(t = 0, e = 0, n = 0, i = Pn.DEFAULT_ORDER) {
      this.isEuler = true, this._x = t, this._y = e, this._z = n, this._order = i;
    }
    get x() {
      return this._x;
    }
    set x(t) {
      this._x = t, this._onChangeCallback();
    }
    get y() {
      return this._y;
    }
    set y(t) {
      this._y = t, this._onChangeCallback();
    }
    get z() {
      return this._z;
    }
    set z(t) {
      this._z = t, this._onChangeCallback();
    }
    get order() {
      return this._order;
    }
    set order(t) {
      this._order = t, this._onChangeCallback();
    }
    set(t, e, n, i = this._order) {
      return this._x = t, this._y = e, this._z = n, this._order = i, this._onChangeCallback(), this;
    }
    clone() {
      return new this.constructor(this._x, this._y, this._z, this._order);
    }
    copy(t) {
      return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this._onChangeCallback(), this;
    }
    setFromRotationMatrix(t, e = this._order, n = true) {
      const i = t.elements, s = i[0], a = i[4], o = i[8], c = i[1], l = i[5], h = i[9], d = i[2], u = i[6], p = i[10];
      switch (e) {
        case "XYZ":
          this._y = Math.asin(Ge(o, -1, 1)), Math.abs(o) < 0.9999999 ? (this._x = Math.atan2(-h, p), this._z = Math.atan2(-a, s)) : (this._x = Math.atan2(u, l), this._z = 0);
          break;
        case "YXZ":
          this._x = Math.asin(-Ge(h, -1, 1)), Math.abs(h) < 0.9999999 ? (this._y = Math.atan2(o, p), this._z = Math.atan2(c, l)) : (this._y = Math.atan2(-d, s), this._z = 0);
          break;
        case "ZXY":
          this._x = Math.asin(Ge(u, -1, 1)), Math.abs(u) < 0.9999999 ? (this._y = Math.atan2(-d, p), this._z = Math.atan2(-a, l)) : (this._y = 0, this._z = Math.atan2(c, s));
          break;
        case "ZYX":
          this._y = Math.asin(-Ge(d, -1, 1)), Math.abs(d) < 0.9999999 ? (this._x = Math.atan2(u, p), this._z = Math.atan2(c, s)) : (this._x = 0, this._z = Math.atan2(-a, l));
          break;
        case "YZX":
          this._z = Math.asin(Ge(c, -1, 1)), Math.abs(c) < 0.9999999 ? (this._x = Math.atan2(-h, l), this._y = Math.atan2(-d, s)) : (this._x = 0, this._y = Math.atan2(o, p));
          break;
        case "XZY":
          this._z = Math.asin(-Ge(a, -1, 1)), Math.abs(a) < 0.9999999 ? (this._x = Math.atan2(u, l), this._y = Math.atan2(o, s)) : (this._x = Math.atan2(-h, p), this._y = 0);
          break;
        default:
          console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + e);
      }
      return this._order = e, n === true && this._onChangeCallback(), this;
    }
    setFromQuaternion(t, e, n) {
      return bh.makeRotationFromQuaternion(t), this.setFromRotationMatrix(bh, e, n);
    }
    setFromVector3(t, e = this._order) {
      return this.set(t.x, t.y, t.z, e);
    }
    reorder(t) {
      return yh.setFromEuler(this), this.setFromQuaternion(yh, t);
    }
    equals(t) {
      return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order;
    }
    fromArray(t) {
      return this._x = t[0], this._y = t[1], this._z = t[2], t[3] !== void 0 && (this._order = t[3]), this._onChangeCallback(), this;
    }
    toArray(t = [], e = 0) {
      return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t;
    }
    _onChange(t) {
      return this._onChangeCallback = t, this;
    }
    _onChangeCallback() {
    }
    *[Symbol.iterator]() {
      yield this._x, yield this._y, yield this._z, yield this._order;
    }
  }
  Pn.DEFAULT_ORDER = "XYZ";
  class Tu {
    constructor() {
      this.mask = 1;
    }
    set(t) {
      this.mask = (1 << t | 0) >>> 0;
    }
    enable(t) {
      this.mask |= 1 << t | 0;
    }
    enableAll() {
      this.mask = -1;
    }
    toggle(t) {
      this.mask ^= 1 << t | 0;
    }
    disable(t) {
      this.mask &= ~(1 << t | 0);
    }
    disableAll() {
      this.mask = 0;
    }
    test(t) {
      return (this.mask & t.mask) !== 0;
    }
    isEnabled(t) {
      return (this.mask & (1 << t | 0)) !== 0;
    }
  }
  let Kf = 0;
  const vh = new L(), Ji = new Ve(), Vn = new Ht(), Ds = new L(), Vr = new L(), Yf = new L(), Zf = new Ve(), xh = new L(1, 0, 0), Sh = new L(0, 1, 0), Mh = new L(0, 0, 1), Eh = {
    type: "added"
  }, $f = {
    type: "removed"
  }, Qi = {
    type: "childadded",
    child: null
  }, Uo = {
    type: "childremoved",
    child: null
  };
  class _e extends Gi {
    constructor() {
      super(), this.isObject3D = true, Object.defineProperty(this, "id", {
        value: Kf++
      }), this.uuid = An(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = _e.DEFAULT_UP.clone();
      const t = new L(), e = new Pn(), n = new Ve(), i = new L(1, 1, 1);
      function s() {
        n.setFromEuler(e, false);
      }
      function a() {
        e.setFromQuaternion(n, void 0, false);
      }
      e._onChange(s), n._onChange(a), Object.defineProperties(this, {
        position: {
          configurable: true,
          enumerable: true,
          value: t
        },
        rotation: {
          configurable: true,
          enumerable: true,
          value: e
        },
        quaternion: {
          configurable: true,
          enumerable: true,
          value: n
        },
        scale: {
          configurable: true,
          enumerable: true,
          value: i
        },
        modelViewMatrix: {
          value: new Ht()
        },
        normalMatrix: {
          value: new Vt()
        }
      }), this.matrix = new Ht(), this.matrixWorld = new Ht(), this.matrixAutoUpdate = _e.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldAutoUpdate = _e.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.matrixWorldNeedsUpdate = false, this.layers = new Tu(), this.visible = true, this.castShadow = false, this.receiveShadow = false, this.frustumCulled = true, this.renderOrder = 0, this.animations = [], this.userData = {};
    }
    onBeforeShadow() {
    }
    onAfterShadow() {
    }
    onBeforeRender() {
    }
    onAfterRender() {
    }
    applyMatrix4(t) {
      this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(t), this.matrix.decompose(this.position, this.quaternion, this.scale);
    }
    applyQuaternion(t) {
      return this.quaternion.premultiply(t), this;
    }
    setRotationFromAxisAngle(t, e) {
      this.quaternion.setFromAxisAngle(t, e);
    }
    setRotationFromEuler(t) {
      this.quaternion.setFromEuler(t, true);
    }
    setRotationFromMatrix(t) {
      this.quaternion.setFromRotationMatrix(t);
    }
    setRotationFromQuaternion(t) {
      this.quaternion.copy(t);
    }
    rotateOnAxis(t, e) {
      return Ji.setFromAxisAngle(t, e), this.quaternion.multiply(Ji), this;
    }
    rotateOnWorldAxis(t, e) {
      return Ji.setFromAxisAngle(t, e), this.quaternion.premultiply(Ji), this;
    }
    rotateX(t) {
      return this.rotateOnAxis(xh, t);
    }
    rotateY(t) {
      return this.rotateOnAxis(Sh, t);
    }
    rotateZ(t) {
      return this.rotateOnAxis(Mh, t);
    }
    translateOnAxis(t, e) {
      return vh.copy(t).applyQuaternion(this.quaternion), this.position.add(vh.multiplyScalar(e)), this;
    }
    translateX(t) {
      return this.translateOnAxis(xh, t);
    }
    translateY(t) {
      return this.translateOnAxis(Sh, t);
    }
    translateZ(t) {
      return this.translateOnAxis(Mh, t);
    }
    localToWorld(t) {
      return this.updateWorldMatrix(true, false), t.applyMatrix4(this.matrixWorld);
    }
    worldToLocal(t) {
      return this.updateWorldMatrix(true, false), t.applyMatrix4(Vn.copy(this.matrixWorld).invert());
    }
    lookAt(t, e, n) {
      t.isVector3 ? Ds.copy(t) : Ds.set(t, e, n);
      const i = this.parent;
      this.updateWorldMatrix(true, false), Vr.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? Vn.lookAt(Vr, Ds, this.up) : Vn.lookAt(Ds, Vr, this.up), this.quaternion.setFromRotationMatrix(Vn), i && (Vn.extractRotation(i.matrixWorld), Ji.setFromRotationMatrix(Vn), this.quaternion.premultiply(Ji.invert()));
    }
    add(t) {
      if (arguments.length > 1) {
        for (let e = 0; e < arguments.length; e++) this.add(arguments[e]);
        return this;
      }
      return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this) : (t && t.isObject3D ? (t.removeFromParent(), t.parent = this, this.children.push(t), t.dispatchEvent(Eh), Qi.child = t, this.dispatchEvent(Qi), Qi.child = null) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t), this);
    }
    remove(t) {
      if (arguments.length > 1) {
        for (let n = 0; n < arguments.length; n++) this.remove(arguments[n]);
        return this;
      }
      const e = this.children.indexOf(t);
      return e !== -1 && (t.parent = null, this.children.splice(e, 1), t.dispatchEvent($f), Uo.child = t, this.dispatchEvent(Uo), Uo.child = null), this;
    }
    removeFromParent() {
      const t = this.parent;
      return t !== null && t.remove(this), this;
    }
    clear() {
      return this.remove(...this.children);
    }
    attach(t) {
      return this.updateWorldMatrix(true, false), Vn.copy(this.matrixWorld).invert(), t.parent !== null && (t.parent.updateWorldMatrix(true, false), Vn.multiply(t.parent.matrixWorld)), t.applyMatrix4(Vn), t.removeFromParent(), t.parent = this, this.children.push(t), t.updateWorldMatrix(false, true), t.dispatchEvent(Eh), Qi.child = t, this.dispatchEvent(Qi), Qi.child = null, this;
    }
    getObjectById(t) {
      return this.getObjectByProperty("id", t);
    }
    getObjectByName(t) {
      return this.getObjectByProperty("name", t);
    }
    getObjectByProperty(t, e) {
      if (this[t] === e) return this;
      for (let n = 0, i = this.children.length; n < i; n++) {
        const a = this.children[n].getObjectByProperty(t, e);
        if (a !== void 0) return a;
      }
    }
    getObjectsByProperty(t, e, n = []) {
      this[t] === e && n.push(this);
      const i = this.children;
      for (let s = 0, a = i.length; s < a; s++) i[s].getObjectsByProperty(t, e, n);
      return n;
    }
    getWorldPosition(t) {
      return this.updateWorldMatrix(true, false), t.setFromMatrixPosition(this.matrixWorld);
    }
    getWorldQuaternion(t) {
      return this.updateWorldMatrix(true, false), this.matrixWorld.decompose(Vr, t, Yf), t;
    }
    getWorldScale(t) {
      return this.updateWorldMatrix(true, false), this.matrixWorld.decompose(Vr, Zf, t), t;
    }
    getWorldDirection(t) {
      this.updateWorldMatrix(true, false);
      const e = this.matrixWorld.elements;
      return t.set(e[8], e[9], e[10]).normalize();
    }
    raycast() {
    }
    traverse(t) {
      t(this);
      const e = this.children;
      for (let n = 0, i = e.length; n < i; n++) e[n].traverse(t);
    }
    traverseVisible(t) {
      if (this.visible === false) return;
      t(this);
      const e = this.children;
      for (let n = 0, i = e.length; n < i; n++) e[n].traverseVisible(t);
    }
    traverseAncestors(t) {
      const e = this.parent;
      e !== null && (t(e), e.traverseAncestors(t));
    }
    updateMatrix() {
      this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = true;
    }
    updateMatrixWorld(t) {
      this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = false, t = true);
      const e = this.children;
      for (let n = 0, i = e.length; n < i; n++) {
        const s = e[n];
        (s.matrixWorldAutoUpdate === true || t === true) && s.updateMatrixWorld(t);
      }
    }
    updateWorldMatrix(t, e) {
      const n = this.parent;
      if (t === true && n !== null && n.matrixWorldAutoUpdate === true && n.updateWorldMatrix(true, false), this.matrixAutoUpdate && this.updateMatrix(), this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), e === true) {
        const i = this.children;
        for (let s = 0, a = i.length; s < a; s++) {
          const o = i[s];
          o.matrixWorldAutoUpdate === true && o.updateWorldMatrix(false, true);
        }
      }
    }
    toJSON(t) {
      const e = t === void 0 || typeof t == "string", n = {};
      e && (t = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {},
        nodes: {}
      }, n.metadata = {
        version: 4.6,
        type: "Object",
        generator: "Object3D.toJSON"
      });
      const i = {};
      i.uuid = this.uuid, i.type = this.type, this.name !== "" && (i.name = this.name), this.castShadow === true && (i.castShadow = true), this.receiveShadow === true && (i.receiveShadow = true), this.visible === false && (i.visible = false), this.frustumCulled === false && (i.frustumCulled = false), this.renderOrder !== 0 && (i.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (i.userData = this.userData), i.layers = this.layers.mask, i.matrix = this.matrix.toArray(), i.up = this.up.toArray(), this.matrixAutoUpdate === false && (i.matrixAutoUpdate = false), this.isInstancedMesh && (i.type = "InstancedMesh", i.count = this.count, i.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (i.instanceColor = this.instanceColor.toJSON())), this.isBatchedMesh && (i.type = "BatchedMesh", i.perObjectFrustumCulled = this.perObjectFrustumCulled, i.sortObjects = this.sortObjects, i.drawRanges = this._drawRanges, i.reservedRanges = this._reservedRanges, i.visibility = this._visibility, i.active = this._active, i.bounds = this._bounds.map((o) => ({
        boxInitialized: o.boxInitialized,
        boxMin: o.box.min.toArray(),
        boxMax: o.box.max.toArray(),
        sphereInitialized: o.sphereInitialized,
        sphereRadius: o.sphere.radius,
        sphereCenter: o.sphere.center.toArray()
      })), i.maxGeometryCount = this._maxGeometryCount, i.maxVertexCount = this._maxVertexCount, i.maxIndexCount = this._maxIndexCount, i.geometryInitialized = this._geometryInitialized, i.geometryCount = this._geometryCount, i.matricesTexture = this._matricesTexture.toJSON(t), this._colorsTexture !== null && (i.colorsTexture = this._colorsTexture.toJSON(t)), this.boundingSphere !== null && (i.boundingSphere = {
        center: i.boundingSphere.center.toArray(),
        radius: i.boundingSphere.radius
      }), this.boundingBox !== null && (i.boundingBox = {
        min: i.boundingBox.min.toArray(),
        max: i.boundingBox.max.toArray()
      }));
      function s(o, c) {
        return o[c.uuid] === void 0 && (o[c.uuid] = c.toJSON(t)), c.uuid;
      }
      if (this.isScene) this.background && (this.background.isColor ? i.background = this.background.toJSON() : this.background.isTexture && (i.background = this.background.toJSON(t).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== true && (i.environment = this.environment.toJSON(t).uuid);
      else if (this.isMesh || this.isLine || this.isPoints) {
        i.geometry = s(t.geometries, this.geometry);
        const o = this.geometry.parameters;
        if (o !== void 0 && o.shapes !== void 0) {
          const c = o.shapes;
          if (Array.isArray(c)) for (let l = 0, h = c.length; l < h; l++) {
            const d = c[l];
            s(t.shapes, d);
          }
          else s(t.shapes, c);
        }
      }
      if (this.isSkinnedMesh && (i.bindMode = this.bindMode, i.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (s(t.skeletons, this.skeleton), i.skeleton = this.skeleton.uuid)), this.material !== void 0) if (Array.isArray(this.material)) {
        const o = [];
        for (let c = 0, l = this.material.length; c < l; c++) o.push(s(t.materials, this.material[c]));
        i.material = o;
      } else i.material = s(t.materials, this.material);
      if (this.children.length > 0) {
        i.children = [];
        for (let o = 0; o < this.children.length; o++) i.children.push(this.children[o].toJSON(t).object);
      }
      if (this.animations.length > 0) {
        i.animations = [];
        for (let o = 0; o < this.animations.length; o++) {
          const c = this.animations[o];
          i.animations.push(s(t.animations, c));
        }
      }
      if (e) {
        const o = a(t.geometries), c = a(t.materials), l = a(t.textures), h = a(t.images), d = a(t.shapes), u = a(t.skeletons), p = a(t.animations), w = a(t.nodes);
        o.length > 0 && (n.geometries = o), c.length > 0 && (n.materials = c), l.length > 0 && (n.textures = l), h.length > 0 && (n.images = h), d.length > 0 && (n.shapes = d), u.length > 0 && (n.skeletons = u), p.length > 0 && (n.animations = p), w.length > 0 && (n.nodes = w);
      }
      return n.object = i, n;
      function a(o) {
        const c = [];
        for (const l in o) {
          const h = o[l];
          delete h.metadata, c.push(h);
        }
        return c;
      }
    }
    clone(t) {
      return new this.constructor().copy(this, t);
    }
    copy(t, e = true) {
      if (this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.rotation.order = t.rotation.order, this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldAutoUpdate = t.matrixWorldAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.animations = t.animations.slice(), this.userData = JSON.parse(JSON.stringify(t.userData)), e === true) for (let n = 0; n < t.children.length; n++) {
        const i = t.children[n];
        this.add(i.clone());
      }
      return this;
    }
  }
  _e.DEFAULT_UP = new L(0, 1, 0);
  _e.DEFAULT_MATRIX_AUTO_UPDATE = true;
  _e.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = true;
  const vn = new L(), Wn = new L(), Fo = new L(), jn = new L(), tr = new L(), er = new L(), Th = new L(), Oo = new L(), Bo = new L(), zo = new L();
  let es = class _r {
    constructor(t = new L(), e = new L(), n = new L()) {
      this.a = t, this.b = e, this.c = n;
    }
    static getNormal(t, e, n, i) {
      i.subVectors(n, e), vn.subVectors(t, e), i.cross(vn);
      const s = i.lengthSq();
      return s > 0 ? i.multiplyScalar(1 / Math.sqrt(s)) : i.set(0, 0, 0);
    }
    static getBarycoord(t, e, n, i, s) {
      vn.subVectors(i, e), Wn.subVectors(n, e), Fo.subVectors(t, e);
      const a = vn.dot(vn), o = vn.dot(Wn), c = vn.dot(Fo), l = Wn.dot(Wn), h = Wn.dot(Fo), d = a * l - o * o;
      if (d === 0) return s.set(0, 0, 0), null;
      const u = 1 / d, p = (l * c - o * h) * u, w = (a * h - o * c) * u;
      return s.set(1 - p - w, w, p);
    }
    static containsPoint(t, e, n, i) {
      return this.getBarycoord(t, e, n, i, jn) === null ? false : jn.x >= 0 && jn.y >= 0 && jn.x + jn.y <= 1;
    }
    static getInterpolation(t, e, n, i, s, a, o, c) {
      return this.getBarycoord(t, e, n, i, jn) === null ? (c.x = 0, c.y = 0, "z" in c && (c.z = 0), "w" in c && (c.w = 0), null) : (c.setScalar(0), c.addScaledVector(s, jn.x), c.addScaledVector(a, jn.y), c.addScaledVector(o, jn.z), c);
    }
    static isFrontFacing(t, e, n, i) {
      return vn.subVectors(n, e), Wn.subVectors(t, e), vn.cross(Wn).dot(i) < 0;
    }
    set(t, e, n) {
      return this.a.copy(t), this.b.copy(e), this.c.copy(n), this;
    }
    setFromPointsAndIndices(t, e, n, i) {
      return this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[i]), this;
    }
    setFromAttributeAndIndices(t, e, n, i) {
      return this.a.fromBufferAttribute(t, e), this.b.fromBufferAttribute(t, n), this.c.fromBufferAttribute(t, i), this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(t) {
      return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this;
    }
    getArea() {
      return vn.subVectors(this.c, this.b), Wn.subVectors(this.a, this.b), vn.cross(Wn).length() * 0.5;
    }
    getMidpoint(t) {
      return t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
    }
    getNormal(t) {
      return _r.getNormal(this.a, this.b, this.c, t);
    }
    getPlane(t) {
      return t.setFromCoplanarPoints(this.a, this.b, this.c);
    }
    getBarycoord(t, e) {
      return _r.getBarycoord(t, this.a, this.b, this.c, e);
    }
    getInterpolation(t, e, n, i, s) {
      return _r.getInterpolation(t, this.a, this.b, this.c, e, n, i, s);
    }
    containsPoint(t) {
      return _r.containsPoint(t, this.a, this.b, this.c);
    }
    isFrontFacing(t) {
      return _r.isFrontFacing(this.a, this.b, this.c, t);
    }
    intersectsBox(t) {
      return t.intersectsTriangle(this);
    }
    closestPointToPoint(t, e) {
      const n = this.a, i = this.b, s = this.c;
      let a, o;
      tr.subVectors(i, n), er.subVectors(s, n), Oo.subVectors(t, n);
      const c = tr.dot(Oo), l = er.dot(Oo);
      if (c <= 0 && l <= 0) return e.copy(n);
      Bo.subVectors(t, i);
      const h = tr.dot(Bo), d = er.dot(Bo);
      if (h >= 0 && d <= h) return e.copy(i);
      const u = c * d - h * l;
      if (u <= 0 && c >= 0 && h <= 0) return a = c / (c - h), e.copy(n).addScaledVector(tr, a);
      zo.subVectors(t, s);
      const p = tr.dot(zo), w = er.dot(zo);
      if (w >= 0 && p <= w) return e.copy(s);
      const b = p * l - c * w;
      if (b <= 0 && l >= 0 && w <= 0) return o = l / (l - w), e.copy(n).addScaledVector(er, o);
      const m = h * w - p * d;
      if (m <= 0 && d - h >= 0 && p - w >= 0) return Th.subVectors(s, i), o = (d - h) / (d - h + (p - w)), e.copy(i).addScaledVector(Th, o);
      const _ = 1 / (m + b + u);
      return a = b * _, o = u * _, e.copy(n).addScaledVector(tr, a).addScaledVector(er, o);
    }
    equals(t) {
      return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c);
    }
  };
  const Au = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
  }, di = {
    h: 0,
    s: 0,
    l: 0
  }, Ns = {
    h: 0,
    s: 0,
    l: 0
  };
  function ko(r, t, e) {
    return e < 0 && (e += 1), e > 1 && (e -= 1), e < 1 / 6 ? r + (t - r) * 6 * e : e < 1 / 2 ? t : e < 2 / 3 ? r + (t - r) * 6 * (2 / 3 - e) : r;
  }
  class Ct {
    constructor(t, e, n) {
      return this.isColor = true, this.r = 1, this.g = 1, this.b = 1, this.set(t, e, n);
    }
    set(t, e, n) {
      if (e === void 0 && n === void 0) {
        const i = t;
        i && i.isColor ? this.copy(i) : typeof i == "number" ? this.setHex(i) : typeof i == "string" && this.setStyle(i);
      } else this.setRGB(t, e, n);
      return this;
    }
    setScalar(t) {
      return this.r = t, this.g = t, this.b = t, this;
    }
    setHex(t, e = Ke) {
      return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (t & 255) / 255, ie.toWorkingColorSpace(this, e), this;
    }
    setRGB(t, e, n, i = ie.workingColorSpace) {
      return this.r = t, this.g = e, this.b = n, ie.toWorkingColorSpace(this, i), this;
    }
    setHSL(t, e, n, i = ie.workingColorSpace) {
      if (t = Dc(t, 1), e = Ge(e, 0, 1), n = Ge(n, 0, 1), e === 0) this.r = this.g = this.b = n;
      else {
        const s = n <= 0.5 ? n * (1 + e) : n + e - n * e, a = 2 * n - s;
        this.r = ko(a, s, t + 1 / 3), this.g = ko(a, s, t), this.b = ko(a, s, t - 1 / 3);
      }
      return ie.toWorkingColorSpace(this, i), this;
    }
    setStyle(t, e = Ke) {
      function n(s) {
        s !== void 0 && parseFloat(s) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.");
      }
      let i;
      if (i = /^(\w+)\(([^\)]*)\)/.exec(t)) {
        let s;
        const a = i[1], o = i[2];
        switch (a) {
          case "rgb":
          case "rgba":
            if (s = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o)) return n(s[4]), this.setRGB(Math.min(255, parseInt(s[1], 10)) / 255, Math.min(255, parseInt(s[2], 10)) / 255, Math.min(255, parseInt(s[3], 10)) / 255, e);
            if (s = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o)) return n(s[4]), this.setRGB(Math.min(100, parseInt(s[1], 10)) / 100, Math.min(100, parseInt(s[2], 10)) / 100, Math.min(100, parseInt(s[3], 10)) / 100, e);
            break;
          case "hsl":
          case "hsla":
            if (s = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o)) return n(s[4]), this.setHSL(parseFloat(s[1]) / 360, parseFloat(s[2]) / 100, parseFloat(s[3]) / 100, e);
            break;
          default:
            console.warn("THREE.Color: Unknown color model " + t);
        }
      } else if (i = /^\#([A-Fa-f\d]+)$/.exec(t)) {
        const s = i[1], a = s.length;
        if (a === 3) return this.setRGB(parseInt(s.charAt(0), 16) / 15, parseInt(s.charAt(1), 16) / 15, parseInt(s.charAt(2), 16) / 15, e);
        if (a === 6) return this.setHex(parseInt(s, 16), e);
        console.warn("THREE.Color: Invalid hex color " + t);
      } else if (t && t.length > 0) return this.setColorName(t, e);
      return this;
    }
    setColorName(t, e = Ke) {
      const n = Au[t.toLowerCase()];
      return n !== void 0 ? this.setHex(n, e) : console.warn("THREE.Color: Unknown color " + t), this;
    }
    clone() {
      return new this.constructor(this.r, this.g, this.b);
    }
    copy(t) {
      return this.r = t.r, this.g = t.g, this.b = t.b, this;
    }
    copySRGBToLinear(t) {
      return this.r = br(t.r), this.g = br(t.g), this.b = br(t.b), this;
    }
    copyLinearToSRGB(t) {
      return this.r = Ao(t.r), this.g = Ao(t.g), this.b = Ao(t.b), this;
    }
    convertSRGBToLinear() {
      return this.copySRGBToLinear(this), this;
    }
    convertLinearToSRGB() {
      return this.copyLinearToSRGB(this), this;
    }
    getHex(t = Ke) {
      return ie.fromWorkingColorSpace(qe.copy(this), t), Math.round(Ge(qe.r * 255, 0, 255)) * 65536 + Math.round(Ge(qe.g * 255, 0, 255)) * 256 + Math.round(Ge(qe.b * 255, 0, 255));
    }
    getHexString(t = Ke) {
      return ("000000" + this.getHex(t).toString(16)).slice(-6);
    }
    getHSL(t, e = ie.workingColorSpace) {
      ie.fromWorkingColorSpace(qe.copy(this), e);
      const n = qe.r, i = qe.g, s = qe.b, a = Math.max(n, i, s), o = Math.min(n, i, s);
      let c, l;
      const h = (o + a) / 2;
      if (o === a) c = 0, l = 0;
      else {
        const d = a - o;
        switch (l = h <= 0.5 ? d / (a + o) : d / (2 - a - o), a) {
          case n:
            c = (i - s) / d + (i < s ? 6 : 0);
            break;
          case i:
            c = (s - n) / d + 2;
            break;
          case s:
            c = (n - i) / d + 4;
            break;
        }
        c /= 6;
      }
      return t.h = c, t.s = l, t.l = h, t;
    }
    getRGB(t, e = ie.workingColorSpace) {
      return ie.fromWorkingColorSpace(qe.copy(this), e), t.r = qe.r, t.g = qe.g, t.b = qe.b, t;
    }
    getStyle(t = Ke) {
      ie.fromWorkingColorSpace(qe.copy(this), t);
      const e = qe.r, n = qe.g, i = qe.b;
      return t !== Ke ? `color(${t} ${e.toFixed(3)} ${n.toFixed(3)} ${i.toFixed(3)})` : `rgb(${Math.round(e * 255)},${Math.round(n * 255)},${Math.round(i * 255)})`;
    }
    offsetHSL(t, e, n) {
      return this.getHSL(di), this.setHSL(di.h + t, di.s + e, di.l + n);
    }
    add(t) {
      return this.r += t.r, this.g += t.g, this.b += t.b, this;
    }
    addColors(t, e) {
      return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this;
    }
    addScalar(t) {
      return this.r += t, this.g += t, this.b += t, this;
    }
    sub(t) {
      return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g), this.b = Math.max(0, this.b - t.b), this;
    }
    multiply(t) {
      return this.r *= t.r, this.g *= t.g, this.b *= t.b, this;
    }
    multiplyScalar(t) {
      return this.r *= t, this.g *= t, this.b *= t, this;
    }
    lerp(t, e) {
      return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this;
    }
    lerpColors(t, e, n) {
      return this.r = t.r + (e.r - t.r) * n, this.g = t.g + (e.g - t.g) * n, this.b = t.b + (e.b - t.b) * n, this;
    }
    lerpHSL(t, e) {
      this.getHSL(di), t.getHSL(Ns);
      const n = rs(di.h, Ns.h, e), i = rs(di.s, Ns.s, e), s = rs(di.l, Ns.l, e);
      return this.setHSL(n, i, s), this;
    }
    setFromVector3(t) {
      return this.r = t.x, this.g = t.y, this.b = t.z, this;
    }
    applyMatrix3(t) {
      const e = this.r, n = this.g, i = this.b, s = t.elements;
      return this.r = s[0] * e + s[3] * n + s[6] * i, this.g = s[1] * e + s[4] * n + s[7] * i, this.b = s[2] * e + s[5] * n + s[8] * i, this;
    }
    equals(t) {
      return t.r === this.r && t.g === this.g && t.b === this.b;
    }
    fromArray(t, e = 0) {
      return this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this;
    }
    toArray(t = [], e = 0) {
      return t[e] = this.r, t[e + 1] = this.g, t[e + 2] = this.b, t;
    }
    fromBufferAttribute(t, e) {
      return this.r = t.getX(e), this.g = t.getY(e), this.b = t.getZ(e), this;
    }
    toJSON() {
      return this.getHex();
    }
    *[Symbol.iterator]() {
      yield this.r, yield this.g, yield this.b;
    }
  }
  const qe = new Ct();
  Ct.NAMES = Au;
  let Jf = 0;
  class Rn extends Gi {
    constructor() {
      super(), this.isMaterial = true, Object.defineProperty(this, "id", {
        value: Jf++
      }), this.uuid = An(), this.name = "", this.type = "Material", this.blending = gr, this.side = Jn, this.vertexColors = false, this.opacity = 1, this.transparent = false, this.alphaHash = false, this.blendSrc = wc, this.blendDst = bc, this.blendEquation = Ui, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.blendColor = new Ct(0, 0, 0), this.blendAlpha = 0, this.depthFunc = pa, this.depthTest = true, this.depthWrite = true, this.stencilWriteMask = 255, this.stencilFunc = uh, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = Xi, this.stencilZFail = Xi, this.stencilZPass = Xi, this.stencilWrite = false, this.clippingPlanes = null, this.clipIntersection = false, this.clipShadows = false, this.shadowSide = null, this.colorWrite = true, this.precision = null, this.polygonOffset = false, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = false, this.alphaToCoverage = false, this.premultipliedAlpha = false, this.forceSinglePass = false, this.visible = true, this.toneMapped = true, this.userData = {}, this.version = 0, this._alphaTest = 0;
    }
    get alphaTest() {
      return this._alphaTest;
    }
    set alphaTest(t) {
      this._alphaTest > 0 != t > 0 && this.version++, this._alphaTest = t;
    }
    onBuild() {
    }
    onBeforeRender() {
    }
    onBeforeCompile() {
    }
    customProgramCacheKey() {
      return this.onBeforeCompile.toString();
    }
    setValues(t) {
      if (t !== void 0) for (const e in t) {
        const n = t[e];
        if (n === void 0) {
          console.warn(`THREE.Material: parameter '${e}' has value of undefined.`);
          continue;
        }
        const i = this[e];
        if (i === void 0) {
          console.warn(`THREE.Material: '${e}' is not a property of THREE.${this.type}.`);
          continue;
        }
        i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : this[e] = n;
      }
    }
    toJSON(t) {
      const e = t === void 0 || typeof t == "string";
      e && (t = {
        textures: {},
        images: {}
      });
      const n = {
        metadata: {
          version: 4.6,
          type: "Material",
          generator: "Material.toJSON"
        }
      };
      n.uuid = this.uuid, n.type = this.type, this.name !== "" && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), this.roughness !== void 0 && (n.roughness = this.roughness), this.metalness !== void 0 && (n.metalness = this.metalness), this.sheen !== void 0 && (n.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (n.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1 && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (n.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (n.shininess = this.shininess), this.clearcoat !== void 0 && (n.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.dispersion !== void 0 && (n.dispersion = this.dispersion), this.iridescence !== void 0 && (n.iridescence = this.iridescence), this.iridescenceIOR !== void 0 && (n.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (n.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (n.iridescenceMap = this.iridescenceMap.toJSON(t).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (n.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(t).uuid), this.anisotropy !== void 0 && (n.anisotropy = this.anisotropy), this.anisotropyRotation !== void 0 && (n.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (n.anisotropyMap = this.anisotropyMap.toJSON(t).uuid), this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(t).uuid, n.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(t).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(t).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(t).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(t).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(t).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(t).uuid), this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(t).uuid, this.combine !== void 0 && (n.combine = this.combine)), this.envMapRotation !== void 0 && (n.envMapRotation = this.envMapRotation.toArray()), this.envMapIntensity !== void 0 && (n.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (n.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (n.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(t).uuid), this.transmission !== void 0 && (n.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(t).uuid), this.thickness !== void 0 && (n.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(t).uuid), this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (n.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (n.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (n.size = this.size), this.shadowSide !== null && (n.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (n.sizeAttenuation = this.sizeAttenuation), this.blending !== gr && (n.blending = this.blending), this.side !== Jn && (n.side = this.side), this.vertexColors === true && (n.vertexColors = true), this.opacity < 1 && (n.opacity = this.opacity), this.transparent === true && (n.transparent = true), this.blendSrc !== wc && (n.blendSrc = this.blendSrc), this.blendDst !== bc && (n.blendDst = this.blendDst), this.blendEquation !== Ui && (n.blendEquation = this.blendEquation), this.blendSrcAlpha !== null && (n.blendSrcAlpha = this.blendSrcAlpha), this.blendDstAlpha !== null && (n.blendDstAlpha = this.blendDstAlpha), this.blendEquationAlpha !== null && (n.blendEquationAlpha = this.blendEquationAlpha), this.blendColor && this.blendColor.isColor && (n.blendColor = this.blendColor.getHex()), this.blendAlpha !== 0 && (n.blendAlpha = this.blendAlpha), this.depthFunc !== pa && (n.depthFunc = this.depthFunc), this.depthTest === false && (n.depthTest = this.depthTest), this.depthWrite === false && (n.depthWrite = this.depthWrite), this.colorWrite === false && (n.colorWrite = this.colorWrite), this.stencilWriteMask !== 255 && (n.stencilWriteMask = this.stencilWriteMask), this.stencilFunc !== uh && (n.stencilFunc = this.stencilFunc), this.stencilRef !== 0 && (n.stencilRef = this.stencilRef), this.stencilFuncMask !== 255 && (n.stencilFuncMask = this.stencilFuncMask), this.stencilFail !== Xi && (n.stencilFail = this.stencilFail), this.stencilZFail !== Xi && (n.stencilZFail = this.stencilZFail), this.stencilZPass !== Xi && (n.stencilZPass = this.stencilZPass), this.stencilWrite === true && (n.stencilWrite = this.stencilWrite), this.rotation !== void 0 && this.rotation !== 0 && (n.rotation = this.rotation), this.polygonOffset === true && (n.polygonOffset = true), this.polygonOffsetFactor !== 0 && (n.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (n.linewidth = this.linewidth), this.dashSize !== void 0 && (n.dashSize = this.dashSize), this.gapSize !== void 0 && (n.gapSize = this.gapSize), this.scale !== void 0 && (n.scale = this.scale), this.dithering === true && (n.dithering = true), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), this.alphaHash === true && (n.alphaHash = true), this.alphaToCoverage === true && (n.alphaToCoverage = true), this.premultipliedAlpha === true && (n.premultipliedAlpha = true), this.forceSinglePass === true && (n.forceSinglePass = true), this.wireframe === true && (n.wireframe = true), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (n.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (n.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === true && (n.flatShading = true), this.visible === false && (n.visible = false), this.toneMapped === false && (n.toneMapped = false), this.fog === false && (n.fog = false), Object.keys(this.userData).length > 0 && (n.userData = this.userData);
      function i(s) {
        const a = [];
        for (const o in s) {
          const c = s[o];
          delete c.metadata, a.push(c);
        }
        return a;
      }
      if (e) {
        const s = i(t.textures), a = i(t.images);
        s.length > 0 && (n.textures = s), a.length > 0 && (n.images = a);
      }
      return n;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(t) {
      this.name = t.name, this.blending = t.blending, this.side = t.side, this.vertexColors = t.vertexColors, this.opacity = t.opacity, this.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t.blendEquationAlpha, this.blendColor.copy(t.blendColor), this.blendAlpha = t.blendAlpha, this.depthFunc = t.depthFunc, this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this.stencilWriteMask = t.stencilWriteMask, this.stencilFunc = t.stencilFunc, this.stencilRef = t.stencilRef, this.stencilFuncMask = t.stencilFuncMask, this.stencilFail = t.stencilFail, this.stencilZFail = t.stencilZFail, this.stencilZPass = t.stencilZPass, this.stencilWrite = t.stencilWrite;
      const e = t.clippingPlanes;
      let n = null;
      if (e !== null) {
        const i = e.length;
        n = new Array(i);
        for (let s = 0; s !== i; ++s) n[s] = e[s].clone();
      }
      return this.clippingPlanes = n, this.clipIntersection = t.clipIntersection, this.clipShadows = t.clipShadows, this.shadowSide = t.shadowSide, this.colorWrite = t.colorWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.dithering = t.dithering, this.alphaTest = t.alphaTest, this.alphaHash = t.alphaHash, this.alphaToCoverage = t.alphaToCoverage, this.premultipliedAlpha = t.premultipliedAlpha, this.forceSinglePass = t.forceSinglePass, this.visible = t.visible, this.toneMapped = t.toneMapped, this.userData = JSON.parse(JSON.stringify(t.userData)), this;
    }
    dispose() {
      this.dispatchEvent({
        type: "dispose"
      });
    }
    set needsUpdate(t) {
      t === true && this.version++;
    }
  }
  class Nn extends Rn {
    constructor(t) {
      super(), this.isMeshBasicMaterial = true, this.type = "MeshBasicMaterial", this.color = new Ct(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Pn(), this.combine = cu, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = true, this.setValues(t);
    }
    copy(t) {
      return super.copy(t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapRotation.copy(t.envMapRotation), this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.fog = t.fog, this;
    }
  }
  const Ie = new L(), Us = new vt();
  class rn {
    constructor(t, e, n = false) {
      if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
      this.isBufferAttribute = true, this.name = "", this.array = t, this.itemSize = e, this.count = t !== void 0 ? t.length / e : 0, this.normalized = n, this.usage = Sc, this._updateRange = {
        offset: 0,
        count: -1
      }, this.updateRanges = [], this.gpuType = Dn, this.version = 0;
    }
    onUploadCallback() {
    }
    set needsUpdate(t) {
      t === true && this.version++;
    }
    get updateRange() {
      return Nc("THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."), this._updateRange;
    }
    setUsage(t) {
      return this.usage = t, this;
    }
    addUpdateRange(t, e) {
      this.updateRanges.push({
        start: t,
        count: e
      });
    }
    clearUpdateRanges() {
      this.updateRanges.length = 0;
    }
    copy(t) {
      return this.name = t.name, this.array = new t.array.constructor(t.array), this.itemSize = t.itemSize, this.count = t.count, this.normalized = t.normalized, this.usage = t.usage, this.gpuType = t.gpuType, this;
    }
    copyAt(t, e, n) {
      t *= this.itemSize, n *= e.itemSize;
      for (let i = 0, s = this.itemSize; i < s; i++) this.array[t + i] = e.array[n + i];
      return this;
    }
    copyArray(t) {
      return this.array.set(t), this;
    }
    applyMatrix3(t) {
      if (this.itemSize === 2) for (let e = 0, n = this.count; e < n; e++) Us.fromBufferAttribute(this, e), Us.applyMatrix3(t), this.setXY(e, Us.x, Us.y);
      else if (this.itemSize === 3) for (let e = 0, n = this.count; e < n; e++) Ie.fromBufferAttribute(this, e), Ie.applyMatrix3(t), this.setXYZ(e, Ie.x, Ie.y, Ie.z);
      return this;
    }
    applyMatrix4(t) {
      for (let e = 0, n = this.count; e < n; e++) Ie.fromBufferAttribute(this, e), Ie.applyMatrix4(t), this.setXYZ(e, Ie.x, Ie.y, Ie.z);
      return this;
    }
    applyNormalMatrix(t) {
      for (let e = 0, n = this.count; e < n; e++) Ie.fromBufferAttribute(this, e), Ie.applyNormalMatrix(t), this.setXYZ(e, Ie.x, Ie.y, Ie.z);
      return this;
    }
    transformDirection(t) {
      for (let e = 0, n = this.count; e < n; e++) Ie.fromBufferAttribute(this, e), Ie.transformDirection(t), this.setXYZ(e, Ie.x, Ie.y, Ie.z);
      return this;
    }
    set(t, e = 0) {
      return this.array.set(t, e), this;
    }
    getComponent(t, e) {
      let n = this.array[t * this.itemSize + e];
      return this.normalized && (n = En(n, this.array)), n;
    }
    setComponent(t, e, n) {
      return this.normalized && (n = ae(n, this.array)), this.array[t * this.itemSize + e] = n, this;
    }
    getX(t) {
      let e = this.array[t * this.itemSize];
      return this.normalized && (e = En(e, this.array)), e;
    }
    setX(t, e) {
      return this.normalized && (e = ae(e, this.array)), this.array[t * this.itemSize] = e, this;
    }
    getY(t) {
      let e = this.array[t * this.itemSize + 1];
      return this.normalized && (e = En(e, this.array)), e;
    }
    setY(t, e) {
      return this.normalized && (e = ae(e, this.array)), this.array[t * this.itemSize + 1] = e, this;
    }
    getZ(t) {
      let e = this.array[t * this.itemSize + 2];
      return this.normalized && (e = En(e, this.array)), e;
    }
    setZ(t, e) {
      return this.normalized && (e = ae(e, this.array)), this.array[t * this.itemSize + 2] = e, this;
    }
    getW(t) {
      let e = this.array[t * this.itemSize + 3];
      return this.normalized && (e = En(e, this.array)), e;
    }
    setW(t, e) {
      return this.normalized && (e = ae(e, this.array)), this.array[t * this.itemSize + 3] = e, this;
    }
    setXY(t, e, n) {
      return t *= this.itemSize, this.normalized && (e = ae(e, this.array), n = ae(n, this.array)), this.array[t + 0] = e, this.array[t + 1] = n, this;
    }
    setXYZ(t, e, n, i) {
      return t *= this.itemSize, this.normalized && (e = ae(e, this.array), n = ae(n, this.array), i = ae(i, this.array)), this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = i, this;
    }
    setXYZW(t, e, n, i, s) {
      return t *= this.itemSize, this.normalized && (e = ae(e, this.array), n = ae(n, this.array), i = ae(i, this.array), s = ae(s, this.array)), this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = i, this.array[t + 3] = s, this;
    }
    onUpload(t) {
      return this.onUploadCallback = t, this;
    }
    clone() {
      return new this.constructor(this.array, this.itemSize).copy(this);
    }
    toJSON() {
      const t = {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: Array.from(this.array),
        normalized: this.normalized
      };
      return this.name !== "" && (t.name = this.name), this.usage !== Sc && (t.usage = this.usage), t;
    }
  }
  class Ru extends rn {
    constructor(t, e, n) {
      super(new Uint16Array(t), e, n);
    }
  }
  class Cu extends rn {
    constructor(t, e, n) {
      super(new Uint32Array(t), e, n);
    }
  }
  class We extends rn {
    constructor(t, e, n) {
      super(new Float32Array(t), e, n);
    }
  }
  let Qf = 0;
  const pn = new Ht(), Ho = new _e(), nr = new L(), hn = new Fn(), Wr = new Fn(), Be = new L();
  class sn extends Gi {
    constructor() {
      super(), this.isBufferGeometry = true, Object.defineProperty(this, "id", {
        value: Qf++
      }), this.uuid = An(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = false, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
        start: 0,
        count: 1 / 0
      }, this.userData = {};
    }
    getIndex() {
      return this.index;
    }
    setIndex(t) {
      return Array.isArray(t) ? this.index = new (xu(t) ? Cu : Ru)(t, 1) : this.index = t, this;
    }
    getAttribute(t) {
      return this.attributes[t];
    }
    setAttribute(t, e) {
      return this.attributes[t] = e, this;
    }
    deleteAttribute(t) {
      return delete this.attributes[t], this;
    }
    hasAttribute(t) {
      return this.attributes[t] !== void 0;
    }
    addGroup(t, e, n = 0) {
      this.groups.push({
        start: t,
        count: e,
        materialIndex: n
      });
    }
    clearGroups() {
      this.groups = [];
    }
    setDrawRange(t, e) {
      this.drawRange.start = t, this.drawRange.count = e;
    }
    applyMatrix4(t) {
      const e = this.attributes.position;
      e !== void 0 && (e.applyMatrix4(t), e.needsUpdate = true);
      const n = this.attributes.normal;
      if (n !== void 0) {
        const s = new Vt().getNormalMatrix(t);
        n.applyNormalMatrix(s), n.needsUpdate = true;
      }
      const i = this.attributes.tangent;
      return i !== void 0 && (i.transformDirection(t), i.needsUpdate = true), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
    }
    applyQuaternion(t) {
      return pn.makeRotationFromQuaternion(t), this.applyMatrix4(pn), this;
    }
    rotateX(t) {
      return pn.makeRotationX(t), this.applyMatrix4(pn), this;
    }
    rotateY(t) {
      return pn.makeRotationY(t), this.applyMatrix4(pn), this;
    }
    rotateZ(t) {
      return pn.makeRotationZ(t), this.applyMatrix4(pn), this;
    }
    translate(t, e, n) {
      return pn.makeTranslation(t, e, n), this.applyMatrix4(pn), this;
    }
    scale(t, e, n) {
      return pn.makeScale(t, e, n), this.applyMatrix4(pn), this;
    }
    lookAt(t) {
      return Ho.lookAt(t), Ho.updateMatrix(), this.applyMatrix4(Ho.matrix), this;
    }
    center() {
      return this.computeBoundingBox(), this.boundingBox.getCenter(nr).negate(), this.translate(nr.x, nr.y, nr.z), this;
    }
    setFromPoints(t) {
      const e = [];
      for (let n = 0, i = t.length; n < i; n++) {
        const s = t[n];
        e.push(s.x, s.y, s.z || 0);
      }
      return this.setAttribute("position", new We(e, 3)), this;
    }
    computeBoundingBox() {
      this.boundingBox === null && (this.boundingBox = new Fn());
      const t = this.attributes.position, e = this.morphAttributes.position;
      if (t && t.isGLBufferAttribute) {
        console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this), this.boundingBox.set(new L(-1 / 0, -1 / 0, -1 / 0), new L(1 / 0, 1 / 0, 1 / 0));
        return;
      }
      if (t !== void 0) {
        if (this.boundingBox.setFromBufferAttribute(t), e) for (let n = 0, i = e.length; n < i; n++) {
          const s = e[n];
          hn.setFromBufferAttribute(s), this.morphTargetsRelative ? (Be.addVectors(this.boundingBox.min, hn.min), this.boundingBox.expandByPoint(Be), Be.addVectors(this.boundingBox.max, hn.max), this.boundingBox.expandByPoint(Be)) : (this.boundingBox.expandByPoint(hn.min), this.boundingBox.expandByPoint(hn.max));
        }
      } else this.boundingBox.makeEmpty();
      (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
    }
    computeBoundingSphere() {
      this.boundingSphere === null && (this.boundingSphere = new On());
      const t = this.attributes.position, e = this.morphAttributes.position;
      if (t && t.isGLBufferAttribute) {
        console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this), this.boundingSphere.set(new L(), 1 / 0);
        return;
      }
      if (t) {
        const n = this.boundingSphere.center;
        if (hn.setFromBufferAttribute(t), e) for (let s = 0, a = e.length; s < a; s++) {
          const o = e[s];
          Wr.setFromBufferAttribute(o), this.morphTargetsRelative ? (Be.addVectors(hn.min, Wr.min), hn.expandByPoint(Be), Be.addVectors(hn.max, Wr.max), hn.expandByPoint(Be)) : (hn.expandByPoint(Wr.min), hn.expandByPoint(Wr.max));
        }
        hn.getCenter(n);
        let i = 0;
        for (let s = 0, a = t.count; s < a; s++) Be.fromBufferAttribute(t, s), i = Math.max(i, n.distanceToSquared(Be));
        if (e) for (let s = 0, a = e.length; s < a; s++) {
          const o = e[s], c = this.morphTargetsRelative;
          for (let l = 0, h = o.count; l < h; l++) Be.fromBufferAttribute(o, l), c && (nr.fromBufferAttribute(t, l), Be.add(nr)), i = Math.max(i, n.distanceToSquared(Be));
        }
        this.boundingSphere.radius = Math.sqrt(i), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
      }
    }
    computeTangents() {
      const t = this.index, e = this.attributes;
      if (t === null || e.position === void 0 || e.normal === void 0 || e.uv === void 0) {
        console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
        return;
      }
      const n = e.position, i = e.normal, s = e.uv;
      this.hasAttribute("tangent") === false && this.setAttribute("tangent", new rn(new Float32Array(4 * n.count), 4));
      const a = this.getAttribute("tangent"), o = [], c = [];
      for (let z = 0; z < n.count; z++) o[z] = new L(), c[z] = new L();
      const l = new L(), h = new L(), d = new L(), u = new vt(), p = new vt(), w = new vt(), b = new L(), m = new L();
      function _(z, A, S) {
        l.fromBufferAttribute(n, z), h.fromBufferAttribute(n, A), d.fromBufferAttribute(n, S), u.fromBufferAttribute(s, z), p.fromBufferAttribute(s, A), w.fromBufferAttribute(s, S), h.sub(l), d.sub(l), p.sub(u), w.sub(u);
        const F = 1 / (p.x * w.y - w.x * p.y);
        isFinite(F) && (b.copy(h).multiplyScalar(w.y).addScaledVector(d, -p.y).multiplyScalar(F), m.copy(d).multiplyScalar(p.x).addScaledVector(h, -w.x).multiplyScalar(F), o[z].add(b), o[A].add(b), o[S].add(b), c[z].add(m), c[A].add(m), c[S].add(m));
      }
      let E = this.groups;
      E.length === 0 && (E = [
        {
          start: 0,
          count: t.count
        }
      ]);
      for (let z = 0, A = E.length; z < A; ++z) {
        const S = E[z], F = S.start, W = S.count;
        for (let V = F, Z = F + W; V < Z; V += 3) _(t.getX(V + 0), t.getX(V + 1), t.getX(V + 2));
      }
      const v = new L(), T = new L(), O = new L(), R = new L();
      function P(z) {
        O.fromBufferAttribute(i, z), R.copy(O);
        const A = o[z];
        v.copy(A), v.sub(O.multiplyScalar(O.dot(A))).normalize(), T.crossVectors(R, A);
        const F = T.dot(c[z]) < 0 ? -1 : 1;
        a.setXYZW(z, v.x, v.y, v.z, F);
      }
      for (let z = 0, A = E.length; z < A; ++z) {
        const S = E[z], F = S.start, W = S.count;
        for (let V = F, Z = F + W; V < Z; V += 3) P(t.getX(V + 0)), P(t.getX(V + 1)), P(t.getX(V + 2));
      }
    }
    computeVertexNormals() {
      const t = this.index, e = this.getAttribute("position");
      if (e !== void 0) {
        let n = this.getAttribute("normal");
        if (n === void 0) n = new rn(new Float32Array(e.count * 3), 3), this.setAttribute("normal", n);
        else for (let u = 0, p = n.count; u < p; u++) n.setXYZ(u, 0, 0, 0);
        const i = new L(), s = new L(), a = new L(), o = new L(), c = new L(), l = new L(), h = new L(), d = new L();
        if (t) for (let u = 0, p = t.count; u < p; u += 3) {
          const w = t.getX(u + 0), b = t.getX(u + 1), m = t.getX(u + 2);
          i.fromBufferAttribute(e, w), s.fromBufferAttribute(e, b), a.fromBufferAttribute(e, m), h.subVectors(a, s), d.subVectors(i, s), h.cross(d), o.fromBufferAttribute(n, w), c.fromBufferAttribute(n, b), l.fromBufferAttribute(n, m), o.add(h), c.add(h), l.add(h), n.setXYZ(w, o.x, o.y, o.z), n.setXYZ(b, c.x, c.y, c.z), n.setXYZ(m, l.x, l.y, l.z);
        }
        else for (let u = 0, p = e.count; u < p; u += 3) i.fromBufferAttribute(e, u + 0), s.fromBufferAttribute(e, u + 1), a.fromBufferAttribute(e, u + 2), h.subVectors(a, s), d.subVectors(i, s), h.cross(d), n.setXYZ(u + 0, h.x, h.y, h.z), n.setXYZ(u + 1, h.x, h.y, h.z), n.setXYZ(u + 2, h.x, h.y, h.z);
        this.normalizeNormals(), n.needsUpdate = true;
      }
    }
    normalizeNormals() {
      const t = this.attributes.normal;
      for (let e = 0, n = t.count; e < n; e++) Be.fromBufferAttribute(t, e), Be.normalize(), t.setXYZ(e, Be.x, Be.y, Be.z);
    }
    toNonIndexed() {
      function t(o, c) {
        const l = o.array, h = o.itemSize, d = o.normalized, u = new l.constructor(c.length * h);
        let p = 0, w = 0;
        for (let b = 0, m = c.length; b < m; b++) {
          o.isInterleavedBufferAttribute ? p = c[b] * o.data.stride + o.offset : p = c[b] * h;
          for (let _ = 0; _ < h; _++) u[w++] = l[p++];
        }
        return new rn(u, h, d);
      }
      if (this.index === null) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
      const e = new sn(), n = this.index.array, i = this.attributes;
      for (const o in i) {
        const c = i[o], l = t(c, n);
        e.setAttribute(o, l);
      }
      const s = this.morphAttributes;
      for (const o in s) {
        const c = [], l = s[o];
        for (let h = 0, d = l.length; h < d; h++) {
          const u = l[h], p = t(u, n);
          c.push(p);
        }
        e.morphAttributes[o] = c;
      }
      e.morphTargetsRelative = this.morphTargetsRelative;
      const a = this.groups;
      for (let o = 0, c = a.length; o < c; o++) {
        const l = a[o];
        e.addGroup(l.start, l.count, l.materialIndex);
      }
      return e;
    }
    toJSON() {
      const t = {
        metadata: {
          version: 4.6,
          type: "BufferGeometry",
          generator: "BufferGeometry.toJSON"
        }
      };
      if (t.uuid = this.uuid, t.type = this.type, this.name !== "" && (t.name = this.name), Object.keys(this.userData).length > 0 && (t.userData = this.userData), this.parameters !== void 0) {
        const c = this.parameters;
        for (const l in c) c[l] !== void 0 && (t[l] = c[l]);
        return t;
      }
      t.data = {
        attributes: {}
      };
      const e = this.index;
      e !== null && (t.data.index = {
        type: e.array.constructor.name,
        array: Array.prototype.slice.call(e.array)
      });
      const n = this.attributes;
      for (const c in n) {
        const l = n[c];
        t.data.attributes[c] = l.toJSON(t.data);
      }
      const i = {};
      let s = false;
      for (const c in this.morphAttributes) {
        const l = this.morphAttributes[c], h = [];
        for (let d = 0, u = l.length; d < u; d++) {
          const p = l[d];
          h.push(p.toJSON(t.data));
        }
        h.length > 0 && (i[c] = h, s = true);
      }
      s && (t.data.morphAttributes = i, t.data.morphTargetsRelative = this.morphTargetsRelative);
      const a = this.groups;
      a.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(a)));
      const o = this.boundingSphere;
      return o !== null && (t.data.boundingSphere = {
        center: o.center.toArray(),
        radius: o.radius
      }), t;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(t) {
      this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
      const e = {};
      this.name = t.name;
      const n = t.index;
      n !== null && this.setIndex(n.clone(e));
      const i = t.attributes;
      for (const l in i) {
        const h = i[l];
        this.setAttribute(l, h.clone(e));
      }
      const s = t.morphAttributes;
      for (const l in s) {
        const h = [], d = s[l];
        for (let u = 0, p = d.length; u < p; u++) h.push(d[u].clone(e));
        this.morphAttributes[l] = h;
      }
      this.morphTargetsRelative = t.morphTargetsRelative;
      const a = t.groups;
      for (let l = 0, h = a.length; l < h; l++) {
        const d = a[l];
        this.addGroup(d.start, d.count, d.materialIndex);
      }
      const o = t.boundingBox;
      o !== null && (this.boundingBox = o.clone());
      const c = t.boundingSphere;
      return c !== null && (this.boundingSphere = c.clone()), this.drawRange.start = t.drawRange.start, this.drawRange.count = t.drawRange.count, this.userData = t.userData, this;
    }
    dispose() {
      this.dispatchEvent({
        type: "dispose"
      });
    }
  }
  const Ah = new Ht(), Ci = new bs(), Fs = new On(), Rh = new L(), ir = new L(), rr = new L(), sr = new L(), Go = new L(), Os = new L(), Bs = new vt(), zs = new vt(), ks = new vt(), Ch = new L(), Ph = new L(), Ih = new L(), Hs = new L(), Gs = new L();
  class fe extends _e {
    constructor(t = new sn(), e = new Nn()) {
      super(), this.isMesh = true, this.type = "Mesh", this.geometry = t, this.material = e, this.updateMorphTargets();
    }
    copy(t, e) {
      return super.copy(t, e), t.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = t.morphTargetInfluences.slice()), t.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)), this.material = Array.isArray(t.material) ? t.material.slice() : t.material, this.geometry = t.geometry, this;
    }
    updateMorphTargets() {
      const e = this.geometry.morphAttributes, n = Object.keys(e);
      if (n.length > 0) {
        const i = e[n[0]];
        if (i !== void 0) {
          this.morphTargetInfluences = [], this.morphTargetDictionary = {};
          for (let s = 0, a = i.length; s < a; s++) {
            const o = i[s].name || String(s);
            this.morphTargetInfluences.push(0), this.morphTargetDictionary[o] = s;
          }
        }
      }
    }
    getVertexPosition(t, e) {
      const n = this.geometry, i = n.attributes.position, s = n.morphAttributes.position, a = n.morphTargetsRelative;
      e.fromBufferAttribute(i, t);
      const o = this.morphTargetInfluences;
      if (s && o) {
        Os.set(0, 0, 0);
        for (let c = 0, l = s.length; c < l; c++) {
          const h = o[c], d = s[c];
          h !== 0 && (Go.fromBufferAttribute(d, t), a ? Os.addScaledVector(Go, h) : Os.addScaledVector(Go.sub(e), h));
        }
        e.add(Os);
      }
      return e;
    }
    raycast(t, e) {
      const n = this.geometry, i = this.material, s = this.matrixWorld;
      i !== void 0 && (n.boundingSphere === null && n.computeBoundingSphere(), Fs.copy(n.boundingSphere), Fs.applyMatrix4(s), Ci.copy(t.ray).recast(t.near), !(Fs.containsPoint(Ci.origin) === false && (Ci.intersectSphere(Fs, Rh) === null || Ci.origin.distanceToSquared(Rh) > (t.far - t.near) ** 2)) && (Ah.copy(s).invert(), Ci.copy(t.ray).applyMatrix4(Ah), !(n.boundingBox !== null && Ci.intersectsBox(n.boundingBox) === false) && this._computeIntersections(t, e, Ci)));
    }
    _computeIntersections(t, e, n) {
      let i;
      const s = this.geometry, a = this.material, o = s.index, c = s.attributes.position, l = s.attributes.uv, h = s.attributes.uv1, d = s.attributes.normal, u = s.groups, p = s.drawRange;
      if (o !== null) if (Array.isArray(a)) for (let w = 0, b = u.length; w < b; w++) {
        const m = u[w], _ = a[m.materialIndex], E = Math.max(m.start, p.start), v = Math.min(o.count, Math.min(m.start + m.count, p.start + p.count));
        for (let T = E, O = v; T < O; T += 3) {
          const R = o.getX(T), P = o.getX(T + 1), z = o.getX(T + 2);
          i = Vs(this, _, t, n, l, h, d, R, P, z), i && (i.faceIndex = Math.floor(T / 3), i.face.materialIndex = m.materialIndex, e.push(i));
        }
      }
      else {
        const w = Math.max(0, p.start), b = Math.min(o.count, p.start + p.count);
        for (let m = w, _ = b; m < _; m += 3) {
          const E = o.getX(m), v = o.getX(m + 1), T = o.getX(m + 2);
          i = Vs(this, a, t, n, l, h, d, E, v, T), i && (i.faceIndex = Math.floor(m / 3), e.push(i));
        }
      }
      else if (c !== void 0) if (Array.isArray(a)) for (let w = 0, b = u.length; w < b; w++) {
        const m = u[w], _ = a[m.materialIndex], E = Math.max(m.start, p.start), v = Math.min(c.count, Math.min(m.start + m.count, p.start + p.count));
        for (let T = E, O = v; T < O; T += 3) {
          const R = T, P = T + 1, z = T + 2;
          i = Vs(this, _, t, n, l, h, d, R, P, z), i && (i.faceIndex = Math.floor(T / 3), i.face.materialIndex = m.materialIndex, e.push(i));
        }
      }
      else {
        const w = Math.max(0, p.start), b = Math.min(c.count, p.start + p.count);
        for (let m = w, _ = b; m < _; m += 3) {
          const E = m, v = m + 1, T = m + 2;
          i = Vs(this, a, t, n, l, h, d, E, v, T), i && (i.faceIndex = Math.floor(m / 3), e.push(i));
        }
      }
    }
  }
  function t_(r, t, e, n, i, s, a, o) {
    let c;
    if (t.side === nn ? c = n.intersectTriangle(a, s, i, true, o) : c = n.intersectTriangle(i, s, a, t.side === Jn, o), c === null) return null;
    Gs.copy(o), Gs.applyMatrix4(r.matrixWorld);
    const l = e.ray.origin.distanceTo(Gs);
    return l < e.near || l > e.far ? null : {
      distance: l,
      point: Gs.clone(),
      object: r
    };
  }
  function Vs(r, t, e, n, i, s, a, o, c, l) {
    r.getVertexPosition(o, ir), r.getVertexPosition(c, rr), r.getVertexPosition(l, sr);
    const h = t_(r, t, e, n, ir, rr, sr, Hs);
    if (h) {
      i && (Bs.fromBufferAttribute(i, o), zs.fromBufferAttribute(i, c), ks.fromBufferAttribute(i, l), h.uv = es.getInterpolation(Hs, ir, rr, sr, Bs, zs, ks, new vt())), s && (Bs.fromBufferAttribute(s, o), zs.fromBufferAttribute(s, c), ks.fromBufferAttribute(s, l), h.uv1 = es.getInterpolation(Hs, ir, rr, sr, Bs, zs, ks, new vt())), a && (Ch.fromBufferAttribute(a, o), Ph.fromBufferAttribute(a, c), Ih.fromBufferAttribute(a, l), h.normal = es.getInterpolation(Hs, ir, rr, sr, Ch, Ph, Ih, new L()), h.normal.dot(n.direction) > 0 && h.normal.multiplyScalar(-1));
      const d = {
        a: o,
        b: c,
        c: l,
        normal: new L(),
        materialIndex: 0
      };
      es.getNormal(ir, rr, sr, d.normal), h.face = d;
    }
    return h;
  }
  class Cn extends sn {
    constructor(t = 1, e = 1, n = 1, i = 1, s = 1, a = 1) {
      super(), this.type = "BoxGeometry", this.parameters = {
        width: t,
        height: e,
        depth: n,
        widthSegments: i,
        heightSegments: s,
        depthSegments: a
      };
      const o = this;
      i = Math.floor(i), s = Math.floor(s), a = Math.floor(a);
      const c = [], l = [], h = [], d = [];
      let u = 0, p = 0;
      w("z", "y", "x", -1, -1, n, e, t, a, s, 0), w("z", "y", "x", 1, -1, n, e, -t, a, s, 1), w("x", "z", "y", 1, 1, t, n, e, i, a, 2), w("x", "z", "y", 1, -1, t, n, -e, i, a, 3), w("x", "y", "z", 1, -1, t, e, n, i, s, 4), w("x", "y", "z", -1, -1, t, e, -n, i, s, 5), this.setIndex(c), this.setAttribute("position", new We(l, 3)), this.setAttribute("normal", new We(h, 3)), this.setAttribute("uv", new We(d, 2));
      function w(b, m, _, E, v, T, O, R, P, z, A) {
        const S = T / P, F = O / z, W = T / 2, V = O / 2, Z = R / 2, tt = P + 1, Y = z + 1;
        let J = 0, $ = 0;
        const ut = new L();
        for (let mt = 0; mt < Y; mt++) {
          const gt = mt * F - V;
          for (let qt = 0; qt < tt; qt++) {
            const ee = qt * S - W;
            ut[b] = ee * E, ut[m] = gt * v, ut[_] = Z, l.push(ut.x, ut.y, ut.z), ut[b] = 0, ut[m] = 0, ut[_] = R > 0 ? 1 : -1, h.push(ut.x, ut.y, ut.z), d.push(qt / P), d.push(1 - mt / z), J += 1;
          }
        }
        for (let mt = 0; mt < z; mt++) for (let gt = 0; gt < P; gt++) {
          const qt = u + gt + tt * mt, ee = u + gt + tt * (mt + 1), Q = u + (gt + 1) + tt * (mt + 1), st = u + (gt + 1) + tt * mt;
          c.push(qt, ee, st), c.push(ee, Q, st), $ += 6;
        }
        o.addGroup(p, $, A), p += $, u += J;
      }
    }
    copy(t) {
      return super.copy(t), this.parameters = Object.assign({}, t.parameters), this;
    }
    static fromJSON(t) {
      return new Cn(t.width, t.height, t.depth, t.widthSegments, t.heightSegments, t.depthSegments);
    }
  }
  function Ar(r) {
    const t = {};
    for (const e in r) {
      t[e] = {};
      for (const n in r[e]) {
        const i = r[e][n];
        i && (i.isColor || i.isMatrix3 || i.isMatrix4 || i.isVector2 || i.isVector3 || i.isVector4 || i.isTexture || i.isQuaternion) ? i.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), t[e][n] = null) : t[e][n] = i.clone() : Array.isArray(i) ? t[e][n] = i.slice() : t[e][n] = i;
      }
    }
    return t;
  }
  function Je(r) {
    const t = {};
    for (let e = 0; e < r.length; e++) {
      const n = Ar(r[e]);
      for (const i in n) t[i] = n[i];
    }
    return t;
  }
  function e_(r) {
    const t = [];
    for (let e = 0; e < r.length; e++) t.push(r[e].clone());
    return t;
  }
  function Pu(r) {
    const t = r.getRenderTarget();
    return t === null ? r.outputColorSpace : t.isXRRenderTarget === true ? t.texture.colorSpace : ie.workingColorSpace;
  }
  const Iu = {
    clone: Ar,
    merge: Je
  };
  var n_ = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`, i_ = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
  class Qn extends Rn {
    constructor(t) {
      super(), this.isShaderMaterial = true, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = n_, this.fragmentShader = i_, this.linewidth = 1, this.wireframe = false, this.wireframeLinewidth = 1, this.fog = false, this.lights = false, this.clipping = false, this.forceSinglePass = true, this.extensions = {
        clipCullDistance: false,
        multiDraw: false
      }, this.defaultAttributeValues = {
        color: [
          1,
          1,
          1
        ],
        uv: [
          0,
          0
        ],
        uv1: [
          0,
          0
        ]
      }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = false, this.glslVersion = null, t !== void 0 && this.setValues(t);
    }
    copy(t) {
      return super.copy(t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = Ar(t.uniforms), this.uniformsGroups = e_(t.uniformsGroups), this.defines = Object.assign({}, t.defines), this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.fog = t.fog, this.lights = t.lights, this.clipping = t.clipping, this.extensions = Object.assign({}, t.extensions), this.glslVersion = t.glslVersion, this;
    }
    toJSON(t) {
      const e = super.toJSON(t);
      e.glslVersion = this.glslVersion, e.uniforms = {};
      for (const i in this.uniforms) {
        const a = this.uniforms[i].value;
        a && a.isTexture ? e.uniforms[i] = {
          type: "t",
          value: a.toJSON(t).uuid
        } : a && a.isColor ? e.uniforms[i] = {
          type: "c",
          value: a.getHex()
        } : a && a.isVector2 ? e.uniforms[i] = {
          type: "v2",
          value: a.toArray()
        } : a && a.isVector3 ? e.uniforms[i] = {
          type: "v3",
          value: a.toArray()
        } : a && a.isVector4 ? e.uniforms[i] = {
          type: "v4",
          value: a.toArray()
        } : a && a.isMatrix3 ? e.uniforms[i] = {
          type: "m3",
          value: a.toArray()
        } : a && a.isMatrix4 ? e.uniforms[i] = {
          type: "m4",
          value: a.toArray()
        } : e.uniforms[i] = {
          value: a
        };
      }
      Object.keys(this.defines).length > 0 && (e.defines = this.defines), e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader, e.lights = this.lights, e.clipping = this.clipping;
      const n = {};
      for (const i in this.extensions) this.extensions[i] === true && (n[i] = true);
      return Object.keys(n).length > 0 && (e.extensions = n), e;
    }
  }
  class Lu extends _e {
    constructor() {
      super(), this.isCamera = true, this.type = "Camera", this.matrixWorldInverse = new Ht(), this.projectionMatrix = new Ht(), this.projectionMatrixInverse = new Ht(), this.coordinateSystem = $n;
    }
    copy(t, e) {
      return super.copy(t, e), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this.projectionMatrixInverse.copy(t.projectionMatrixInverse), this.coordinateSystem = t.coordinateSystem, this;
    }
    getWorldDirection(t) {
      return super.getWorldDirection(t).negate();
    }
    updateMatrixWorld(t) {
      super.updateMatrixWorld(t), this.matrixWorldInverse.copy(this.matrixWorld).invert();
    }
    updateWorldMatrix(t, e) {
      super.updateWorldMatrix(t, e), this.matrixWorldInverse.copy(this.matrixWorld).invert();
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  const ui = new L(), Lh = new vt(), Dh = new vt();
  class tn extends Lu {
    constructor(t = 50, e = 1, n = 0.1, i = 2e3) {
      super(), this.isPerspectiveCamera = true, this.type = "PerspectiveCamera", this.fov = t, this.zoom = 1, this.near = n, this.far = i, this.focus = 10, this.aspect = e, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
    }
    copy(t, e) {
      return super.copy(t, e), this.fov = t.fov, this.zoom = t.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this.aspect = t.aspect, this.view = t.view === null ? null : Object.assign({}, t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this;
    }
    setFocalLength(t) {
      const e = 0.5 * this.getFilmHeight() / t;
      this.fov = Tr * 2 * Math.atan(e), this.updateProjectionMatrix();
    }
    getFocalLength() {
      const t = Math.tan(is * 0.5 * this.fov);
      return 0.5 * this.getFilmHeight() / t;
    }
    getEffectiveFOV() {
      return Tr * 2 * Math.atan(Math.tan(is * 0.5 * this.fov) / this.zoom);
    }
    getFilmWidth() {
      return this.filmGauge * Math.min(this.aspect, 1);
    }
    getFilmHeight() {
      return this.filmGauge / Math.max(this.aspect, 1);
    }
    getViewBounds(t, e, n) {
      ui.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse), e.set(ui.x, ui.y).multiplyScalar(-t / ui.z), ui.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse), n.set(ui.x, ui.y).multiplyScalar(-t / ui.z);
    }
    getViewSize(t, e) {
      return this.getViewBounds(t, Lh, Dh), e.subVectors(Dh, Lh);
    }
    setViewOffset(t, e, n, i, s, a) {
      this.aspect = t / e, this.view === null && (this.view = {
        enabled: true,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      }), this.view.enabled = true, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = i, this.view.width = s, this.view.height = a, this.updateProjectionMatrix();
    }
    clearViewOffset() {
      this.view !== null && (this.view.enabled = false), this.updateProjectionMatrix();
    }
    updateProjectionMatrix() {
      const t = this.near;
      let e = t * Math.tan(is * 0.5 * this.fov) / this.zoom, n = 2 * e, i = this.aspect * n, s = -0.5 * i;
      const a = this.view;
      if (this.view !== null && this.view.enabled) {
        const c = a.fullWidth, l = a.fullHeight;
        s += a.offsetX * i / c, e -= a.offsetY * n / l, i *= a.width / c, n *= a.height / l;
      }
      const o = this.filmOffset;
      o !== 0 && (s += t * o / this.getFilmWidth()), this.projectionMatrix.makePerspective(s, s + i, e, e - n, t, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
    }
    toJSON(t) {
      const e = super.toJSON(t);
      return e.object.fov = this.fov, e.object.zoom = this.zoom, e.object.near = this.near, e.object.far = this.far, e.object.focus = this.focus, e.object.aspect = this.aspect, this.view !== null && (e.object.view = Object.assign({}, this.view)), e.object.filmGauge = this.filmGauge, e.object.filmOffset = this.filmOffset, e;
    }
  }
  const ar = -90, or = 1;
  class r_ extends _e {
    constructor(t, e, n) {
      super(), this.type = "CubeCamera", this.renderTarget = n, this.coordinateSystem = null, this.activeMipmapLevel = 0;
      const i = new tn(ar, or, t, e);
      i.layers = this.layers, this.add(i);
      const s = new tn(ar, or, t, e);
      s.layers = this.layers, this.add(s);
      const a = new tn(ar, or, t, e);
      a.layers = this.layers, this.add(a);
      const o = new tn(ar, or, t, e);
      o.layers = this.layers, this.add(o);
      const c = new tn(ar, or, t, e);
      c.layers = this.layers, this.add(c);
      const l = new tn(ar, or, t, e);
      l.layers = this.layers, this.add(l);
    }
    updateCoordinateSystem() {
      const t = this.coordinateSystem, e = this.children.concat(), [n, i, s, a, o, c] = e;
      for (const l of e) this.remove(l);
      if (t === $n) n.up.set(0, 1, 0), n.lookAt(1, 0, 0), i.up.set(0, 1, 0), i.lookAt(-1, 0, 0), s.up.set(0, 0, -1), s.lookAt(0, 1, 0), a.up.set(0, 0, 1), a.lookAt(0, -1, 0), o.up.set(0, 1, 0), o.lookAt(0, 0, 1), c.up.set(0, 1, 0), c.lookAt(0, 0, -1);
      else if (t === ba) n.up.set(0, -1, 0), n.lookAt(-1, 0, 0), i.up.set(0, -1, 0), i.lookAt(1, 0, 0), s.up.set(0, 0, 1), s.lookAt(0, 1, 0), a.up.set(0, 0, -1), a.lookAt(0, -1, 0), o.up.set(0, -1, 0), o.lookAt(0, 0, 1), c.up.set(0, -1, 0), c.lookAt(0, 0, -1);
      else throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + t);
      for (const l of e) this.add(l), l.updateMatrixWorld();
    }
    update(t, e) {
      this.parent === null && this.updateMatrixWorld();
      const { renderTarget: n, activeMipmapLevel: i } = this;
      this.coordinateSystem !== t.coordinateSystem && (this.coordinateSystem = t.coordinateSystem, this.updateCoordinateSystem());
      const [s, a, o, c, l, h] = this.children, d = t.getRenderTarget(), u = t.getActiveCubeFace(), p = t.getActiveMipmapLevel(), w = t.xr.enabled;
      t.xr.enabled = false;
      const b = n.texture.generateMipmaps;
      n.texture.generateMipmaps = false, t.setRenderTarget(n, 0, i), t.render(e, s), t.setRenderTarget(n, 1, i), t.render(e, a), t.setRenderTarget(n, 2, i), t.render(e, o), t.setRenderTarget(n, 3, i), t.render(e, c), t.setRenderTarget(n, 4, i), t.render(e, l), n.texture.generateMipmaps = b, t.setRenderTarget(n, 5, i), t.render(e, h), t.setRenderTarget(d, u, p), t.xr.enabled = w, n.texture.needsPMREMUpdate = true;
    }
  }
  class Du extends Ne {
    constructor(t, e, n, i, s, a, o, c, l, h) {
      t = t !== void 0 ? t : [], e = e !== void 0 ? e : vr, super(t, e, n, i, s, a, o, c, l, h), this.isCubeTexture = true, this.flipY = false;
    }
    get images() {
      return this.image;
    }
    set images(t) {
      this.image = t;
    }
  }
  class s_ extends Bi {
    constructor(t = 1, e = {}) {
      super(t, t, e), this.isWebGLCubeRenderTarget = true;
      const n = {
        width: t,
        height: t,
        depth: 1
      }, i = [
        n,
        n,
        n,
        n,
        n,
        n
      ];
      this.texture = new Du(i, e.mapping, e.wrapS, e.wrapT, e.magFilter, e.minFilter, e.format, e.type, e.anisotropy, e.colorSpace), this.texture.isRenderTargetTexture = true, this.texture.generateMipmaps = e.generateMipmaps !== void 0 ? e.generateMipmaps : false, this.texture.minFilter = e.minFilter !== void 0 ? e.minFilter : dn;
    }
    fromEquirectangularTexture(t, e) {
      this.texture.type = e.type, this.texture.colorSpace = e.colorSpace, this.texture.generateMipmaps = e.generateMipmaps, this.texture.minFilter = e.minFilter, this.texture.magFilter = e.magFilter;
      const n = {
        uniforms: {
          tEquirect: {
            value: null
          }
        },
        vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
        fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
      }, i = new Cn(5, 5, 5), s = new Qn({
        name: "CubemapFromEquirect",
        uniforms: Ar(n.uniforms),
        vertexShader: n.vertexShader,
        fragmentShader: n.fragmentShader,
        side: nn,
        blending: vi
      });
      s.uniforms.tEquirect.value = e;
      const a = new fe(i, s), o = e.minFilter;
      return e.minFilter === Zn && (e.minFilter = dn), new r_(1, 10, this).update(t, a), e.minFilter = o, a.geometry.dispose(), a.material.dispose(), this;
    }
    clear(t, e, n, i) {
      const s = t.getRenderTarget();
      for (let a = 0; a < 6; a++) t.setRenderTarget(this, a), t.clear(e, n, i);
      t.setRenderTarget(s);
    }
  }
  const Vo = new L(), a_ = new L(), o_ = new Vt();
  class mi {
    constructor(t = new L(1, 0, 0), e = 0) {
      this.isPlane = true, this.normal = t, this.constant = e;
    }
    set(t, e) {
      return this.normal.copy(t), this.constant = e, this;
    }
    setComponents(t, e, n, i) {
      return this.normal.set(t, e, n), this.constant = i, this;
    }
    setFromNormalAndCoplanarPoint(t, e) {
      return this.normal.copy(t), this.constant = -e.dot(this.normal), this;
    }
    setFromCoplanarPoints(t, e, n) {
      const i = Vo.subVectors(n, e).cross(a_.subVectors(t, e)).normalize();
      return this.setFromNormalAndCoplanarPoint(i, t), this;
    }
    copy(t) {
      return this.normal.copy(t.normal), this.constant = t.constant, this;
    }
    normalize() {
      const t = 1 / this.normal.length();
      return this.normal.multiplyScalar(t), this.constant *= t, this;
    }
    negate() {
      return this.constant *= -1, this.normal.negate(), this;
    }
    distanceToPoint(t) {
      return this.normal.dot(t) + this.constant;
    }
    distanceToSphere(t) {
      return this.distanceToPoint(t.center) - t.radius;
    }
    projectPoint(t, e) {
      return e.copy(t).addScaledVector(this.normal, -this.distanceToPoint(t));
    }
    intersectLine(t, e) {
      const n = t.delta(Vo), i = this.normal.dot(n);
      if (i === 0) return this.distanceToPoint(t.start) === 0 ? e.copy(t.start) : null;
      const s = -(t.start.dot(this.normal) + this.constant) / i;
      return s < 0 || s > 1 ? null : e.copy(t.start).addScaledVector(n, s);
    }
    intersectsLine(t) {
      const e = this.distanceToPoint(t.start), n = this.distanceToPoint(t.end);
      return e < 0 && n > 0 || n < 0 && e > 0;
    }
    intersectsBox(t) {
      return t.intersectsPlane(this);
    }
    intersectsSphere(t) {
      return t.intersectsPlane(this);
    }
    coplanarPoint(t) {
      return t.copy(this.normal).multiplyScalar(-this.constant);
    }
    applyMatrix4(t, e) {
      const n = e || o_.getNormalMatrix(t), i = this.coplanarPoint(Vo).applyMatrix4(t), s = this.normal.applyMatrix3(n).normalize();
      return this.constant = -i.dot(s), this;
    }
    translate(t) {
      return this.constant -= t.dot(this.normal), this;
    }
    equals(t) {
      return t.normal.equals(this.normal) && t.constant === this.constant;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  const Pi = new On(), Ws = new L();
  class Uc {
    constructor(t = new mi(), e = new mi(), n = new mi(), i = new mi(), s = new mi(), a = new mi()) {
      this.planes = [
        t,
        e,
        n,
        i,
        s,
        a
      ];
    }
    set(t, e, n, i, s, a) {
      const o = this.planes;
      return o[0].copy(t), o[1].copy(e), o[2].copy(n), o[3].copy(i), o[4].copy(s), o[5].copy(a), this;
    }
    copy(t) {
      const e = this.planes;
      for (let n = 0; n < 6; n++) e[n].copy(t.planes[n]);
      return this;
    }
    setFromProjectionMatrix(t, e = $n) {
      const n = this.planes, i = t.elements, s = i[0], a = i[1], o = i[2], c = i[3], l = i[4], h = i[5], d = i[6], u = i[7], p = i[8], w = i[9], b = i[10], m = i[11], _ = i[12], E = i[13], v = i[14], T = i[15];
      if (n[0].setComponents(c - s, u - l, m - p, T - _).normalize(), n[1].setComponents(c + s, u + l, m + p, T + _).normalize(), n[2].setComponents(c + a, u + h, m + w, T + E).normalize(), n[3].setComponents(c - a, u - h, m - w, T - E).normalize(), n[4].setComponents(c - o, u - d, m - b, T - v).normalize(), e === $n) n[5].setComponents(c + o, u + d, m + b, T + v).normalize();
      else if (e === ba) n[5].setComponents(o, d, b, v).normalize();
      else throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + e);
      return this;
    }
    intersectsObject(t) {
      if (t.boundingSphere !== void 0) t.boundingSphere === null && t.computeBoundingSphere(), Pi.copy(t.boundingSphere).applyMatrix4(t.matrixWorld);
      else {
        const e = t.geometry;
        e.boundingSphere === null && e.computeBoundingSphere(), Pi.copy(e.boundingSphere).applyMatrix4(t.matrixWorld);
      }
      return this.intersectsSphere(Pi);
    }
    intersectsSprite(t) {
      return Pi.center.set(0, 0, 0), Pi.radius = 0.7071067811865476, Pi.applyMatrix4(t.matrixWorld), this.intersectsSphere(Pi);
    }
    intersectsSphere(t) {
      const e = this.planes, n = t.center, i = -t.radius;
      for (let s = 0; s < 6; s++) if (e[s].distanceToPoint(n) < i) return false;
      return true;
    }
    intersectsBox(t) {
      const e = this.planes;
      for (let n = 0; n < 6; n++) {
        const i = e[n];
        if (Ws.x = i.normal.x > 0 ? t.max.x : t.min.x, Ws.y = i.normal.y > 0 ? t.max.y : t.min.y, Ws.z = i.normal.z > 0 ? t.max.z : t.min.z, i.distanceToPoint(Ws) < 0) return false;
      }
      return true;
    }
    containsPoint(t) {
      const e = this.planes;
      for (let n = 0; n < 6; n++) if (e[n].distanceToPoint(t) < 0) return false;
      return true;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  function Nu() {
    let r = null, t = false, e = null, n = null;
    function i(s, a) {
      e(s, a), n = r.requestAnimationFrame(i);
    }
    return {
      start: function() {
        t !== true && e !== null && (n = r.requestAnimationFrame(i), t = true);
      },
      stop: function() {
        r.cancelAnimationFrame(n), t = false;
      },
      setAnimationLoop: function(s) {
        e = s;
      },
      setContext: function(s) {
        r = s;
      }
    };
  }
  function c_(r) {
    const t = /* @__PURE__ */ new WeakMap();
    function e(o, c) {
      const l = o.array, h = o.usage, d = l.byteLength, u = r.createBuffer();
      r.bindBuffer(c, u), r.bufferData(c, l, h), o.onUploadCallback();
      let p;
      if (l instanceof Float32Array) p = r.FLOAT;
      else if (l instanceof Uint16Array) o.isFloat16BufferAttribute ? p = r.HALF_FLOAT : p = r.UNSIGNED_SHORT;
      else if (l instanceof Int16Array) p = r.SHORT;
      else if (l instanceof Uint32Array) p = r.UNSIGNED_INT;
      else if (l instanceof Int32Array) p = r.INT;
      else if (l instanceof Int8Array) p = r.BYTE;
      else if (l instanceof Uint8Array) p = r.UNSIGNED_BYTE;
      else if (l instanceof Uint8ClampedArray) p = r.UNSIGNED_BYTE;
      else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + l);
      return {
        buffer: u,
        type: p,
        bytesPerElement: l.BYTES_PER_ELEMENT,
        version: o.version,
        size: d
      };
    }
    function n(o, c, l) {
      const h = c.array, d = c._updateRange, u = c.updateRanges;
      if (r.bindBuffer(l, o), d.count === -1 && u.length === 0 && r.bufferSubData(l, 0, h), u.length !== 0) {
        for (let p = 0, w = u.length; p < w; p++) {
          const b = u[p];
          r.bufferSubData(l, b.start * h.BYTES_PER_ELEMENT, h, b.start, b.count);
        }
        c.clearUpdateRanges();
      }
      d.count !== -1 && (r.bufferSubData(l, d.offset * h.BYTES_PER_ELEMENT, h, d.offset, d.count), d.count = -1), c.onUploadCallback();
    }
    function i(o) {
      return o.isInterleavedBufferAttribute && (o = o.data), t.get(o);
    }
    function s(o) {
      o.isInterleavedBufferAttribute && (o = o.data);
      const c = t.get(o);
      c && (r.deleteBuffer(c.buffer), t.delete(o));
    }
    function a(o, c) {
      if (o.isGLBufferAttribute) {
        const h = t.get(o);
        (!h || h.version < o.version) && t.set(o, {
          buffer: o.buffer,
          type: o.type,
          bytesPerElement: o.elementSize,
          version: o.version
        });
        return;
      }
      o.isInterleavedBufferAttribute && (o = o.data);
      const l = t.get(o);
      if (l === void 0) t.set(o, e(o, c));
      else if (l.version < o.version) {
        if (l.size !== o.array.byteLength) throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
        n(l.buffer, o, c), l.version = o.version;
      }
    }
    return {
      get: i,
      remove: s,
      update: a
    };
  }
  class ys extends sn {
    constructor(t = 1, e = 1, n = 1, i = 1) {
      super(), this.type = "PlaneGeometry", this.parameters = {
        width: t,
        height: e,
        widthSegments: n,
        heightSegments: i
      };
      const s = t / 2, a = e / 2, o = Math.floor(n), c = Math.floor(i), l = o + 1, h = c + 1, d = t / o, u = e / c, p = [], w = [], b = [], m = [];
      for (let _ = 0; _ < h; _++) {
        const E = _ * u - a;
        for (let v = 0; v < l; v++) {
          const T = v * d - s;
          w.push(T, -E, 0), b.push(0, 0, 1), m.push(v / o), m.push(1 - _ / c);
        }
      }
      for (let _ = 0; _ < c; _++) for (let E = 0; E < o; E++) {
        const v = E + l * _, T = E + l * (_ + 1), O = E + 1 + l * (_ + 1), R = E + 1 + l * _;
        p.push(v, T, R), p.push(T, O, R);
      }
      this.setIndex(p), this.setAttribute("position", new We(w, 3)), this.setAttribute("normal", new We(b, 3)), this.setAttribute("uv", new We(m, 2));
    }
    copy(t) {
      return super.copy(t), this.parameters = Object.assign({}, t.parameters), this;
    }
    static fromJSON(t) {
      return new ys(t.width, t.height, t.widthSegments, t.heightSegments);
    }
  }
  var l_ = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`, h_ = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`, d_ = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`, u_ = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, p_ = `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`, f_ = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`, __ = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`, m_ = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`, g_ = `#ifdef USE_BATCHING
	attribute float batchId;
	uniform highp sampler2D batchingTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`, w_ = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( batchId );
#endif`, b_ = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`, y_ = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`, v_ = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`, x_ = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`, S_ = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`, M_ = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`, E_ = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`, T_ = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`, A_ = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`, R_ = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`, C_ = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`, P_ = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`, I_ = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( batchId );
	vColor.xyz *= batchingColor.xyz;
#endif`, L_ = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`, D_ = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`, N_ = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`, U_ = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`, F_ = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`, O_ = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`, B_ = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`, z_ = "gl_FragColor = linearToOutputTexel( gl_FragColor );", k_ = `
const mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(
	vec3( 0.8224621, 0.177538, 0.0 ),
	vec3( 0.0331941, 0.9668058, 0.0 ),
	vec3( 0.0170827, 0.0723974, 0.9105199 )
);
const mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(
	vec3( 1.2249401, - 0.2249404, 0.0 ),
	vec3( - 0.0420569, 1.0420571, 0.0 ),
	vec3( - 0.0196376, - 0.0786361, 1.0982735 )
);
vec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {
	return vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );
}
vec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {
	return vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );
}
vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return sRGBTransferOETF( value );
}`, H_ = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`, G_ = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`, V_ = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`, W_ = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`, j_ = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`, X_ = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`, q_ = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`, K_ = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`, Y_ = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`, Z_ = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`, $_ = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`, J_ = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`, Q_ = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`, tm = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`, em = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`, nm = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`, im = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`, rm = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`, sm = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`, am = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`, om = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`, cm = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`, lm = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`, hm = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`, dm = `#if defined( USE_LOGDEPTHBUF )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`, um = `#if defined( USE_LOGDEPTHBUF )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, pm = `#ifdef USE_LOGDEPTHBUF
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, fm = `#ifdef USE_LOGDEPTHBUF
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`, _m = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`, mm = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`, gm = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`, wm = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, bm = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`, ym = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`, vm = `#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`, xm = `#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`, Sm = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`, Mm = `#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`, Em = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`, Tm = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`, Am = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`, Rm = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, Cm = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, Pm = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`, Im = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`, Lm = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`, Dm = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`, Nm = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`, Um = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`, Fm = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`, Om = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`, Bm = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`, zm = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`, km = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`, Hm = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`, Gm = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`, Vm = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`, Wm = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return shadow;
	}
#endif`, jm = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`, Xm = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`, qm = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`, Km = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`, Ym = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`, Zm = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`, $m = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`, Jm = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`, Qm = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`, tg = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`, eg = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`, ng = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`, ig = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
		
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
		
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		
		#else
		
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`, rg = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, sg = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, ag = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`, og = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
  const cg = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`, lg = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, hg = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, dg = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, ug = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, pg = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, fg = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`, _g = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`, mg = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`, gg = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`, wg = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`, bg = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, yg = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, vg = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, xg = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`, Sg = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, Mg = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, Eg = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, Tg = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`, Ag = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, Rg = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`, Cg = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`, Pg = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, Ig = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, Lg = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`, Dg = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, Ng = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, Ug = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, Fg = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`, Og = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, Bg = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, zg = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, kg = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, Hg = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, Gt = {
    alphahash_fragment: l_,
    alphahash_pars_fragment: h_,
    alphamap_fragment: d_,
    alphamap_pars_fragment: u_,
    alphatest_fragment: p_,
    alphatest_pars_fragment: f_,
    aomap_fragment: __,
    aomap_pars_fragment: m_,
    batching_pars_vertex: g_,
    batching_vertex: w_,
    begin_vertex: b_,
    beginnormal_vertex: y_,
    bsdfs: v_,
    iridescence_fragment: x_,
    bumpmap_pars_fragment: S_,
    clipping_planes_fragment: M_,
    clipping_planes_pars_fragment: E_,
    clipping_planes_pars_vertex: T_,
    clipping_planes_vertex: A_,
    color_fragment: R_,
    color_pars_fragment: C_,
    color_pars_vertex: P_,
    color_vertex: I_,
    common: L_,
    cube_uv_reflection_fragment: D_,
    defaultnormal_vertex: N_,
    displacementmap_pars_vertex: U_,
    displacementmap_vertex: F_,
    emissivemap_fragment: O_,
    emissivemap_pars_fragment: B_,
    colorspace_fragment: z_,
    colorspace_pars_fragment: k_,
    envmap_fragment: H_,
    envmap_common_pars_fragment: G_,
    envmap_pars_fragment: V_,
    envmap_pars_vertex: W_,
    envmap_physical_pars_fragment: em,
    envmap_vertex: j_,
    fog_vertex: X_,
    fog_pars_vertex: q_,
    fog_fragment: K_,
    fog_pars_fragment: Y_,
    gradientmap_pars_fragment: Z_,
    lightmap_pars_fragment: $_,
    lights_lambert_fragment: J_,
    lights_lambert_pars_fragment: Q_,
    lights_pars_begin: tm,
    lights_toon_fragment: nm,
    lights_toon_pars_fragment: im,
    lights_phong_fragment: rm,
    lights_phong_pars_fragment: sm,
    lights_physical_fragment: am,
    lights_physical_pars_fragment: om,
    lights_fragment_begin: cm,
    lights_fragment_maps: lm,
    lights_fragment_end: hm,
    logdepthbuf_fragment: dm,
    logdepthbuf_pars_fragment: um,
    logdepthbuf_pars_vertex: pm,
    logdepthbuf_vertex: fm,
    map_fragment: _m,
    map_pars_fragment: mm,
    map_particle_fragment: gm,
    map_particle_pars_fragment: wm,
    metalnessmap_fragment: bm,
    metalnessmap_pars_fragment: ym,
    morphinstance_vertex: vm,
    morphcolor_vertex: xm,
    morphnormal_vertex: Sm,
    morphtarget_pars_vertex: Mm,
    morphtarget_vertex: Em,
    normal_fragment_begin: Tm,
    normal_fragment_maps: Am,
    normal_pars_fragment: Rm,
    normal_pars_vertex: Cm,
    normal_vertex: Pm,
    normalmap_pars_fragment: Im,
    clearcoat_normal_fragment_begin: Lm,
    clearcoat_normal_fragment_maps: Dm,
    clearcoat_pars_fragment: Nm,
    iridescence_pars_fragment: Um,
    opaque_fragment: Fm,
    packing: Om,
    premultiplied_alpha_fragment: Bm,
    project_vertex: zm,
    dithering_fragment: km,
    dithering_pars_fragment: Hm,
    roughnessmap_fragment: Gm,
    roughnessmap_pars_fragment: Vm,
    shadowmap_pars_fragment: Wm,
    shadowmap_pars_vertex: jm,
    shadowmap_vertex: Xm,
    shadowmask_pars_fragment: qm,
    skinbase_vertex: Km,
    skinning_pars_vertex: Ym,
    skinning_vertex: Zm,
    skinnormal_vertex: $m,
    specularmap_fragment: Jm,
    specularmap_pars_fragment: Qm,
    tonemapping_fragment: tg,
    tonemapping_pars_fragment: eg,
    transmission_fragment: ng,
    transmission_pars_fragment: ig,
    uv_pars_fragment: rg,
    uv_pars_vertex: sg,
    uv_vertex: ag,
    worldpos_vertex: og,
    background_vert: cg,
    background_frag: lg,
    backgroundCube_vert: hg,
    backgroundCube_frag: dg,
    cube_vert: ug,
    cube_frag: pg,
    depth_vert: fg,
    depth_frag: _g,
    distanceRGBA_vert: mg,
    distanceRGBA_frag: gg,
    equirect_vert: wg,
    equirect_frag: bg,
    linedashed_vert: yg,
    linedashed_frag: vg,
    meshbasic_vert: xg,
    meshbasic_frag: Sg,
    meshlambert_vert: Mg,
    meshlambert_frag: Eg,
    meshmatcap_vert: Tg,
    meshmatcap_frag: Ag,
    meshnormal_vert: Rg,
    meshnormal_frag: Cg,
    meshphong_vert: Pg,
    meshphong_frag: Ig,
    meshphysical_vert: Lg,
    meshphysical_frag: Dg,
    meshtoon_vert: Ng,
    meshtoon_frag: Ug,
    points_vert: Fg,
    points_frag: Og,
    shadow_vert: Bg,
    shadow_frag: zg,
    sprite_vert: kg,
    sprite_frag: Hg
  }, dt = {
    common: {
      diffuse: {
        value: new Ct(16777215)
      },
      opacity: {
        value: 1
      },
      map: {
        value: null
      },
      mapTransform: {
        value: new Vt()
      },
      alphaMap: {
        value: null
      },
      alphaMapTransform: {
        value: new Vt()
      },
      alphaTest: {
        value: 0
      }
    },
    specularmap: {
      specularMap: {
        value: null
      },
      specularMapTransform: {
        value: new Vt()
      }
    },
    envmap: {
      envMap: {
        value: null
      },
      envMapRotation: {
        value: new Vt()
      },
      flipEnvMap: {
        value: -1
      },
      reflectivity: {
        value: 1
      },
      ior: {
        value: 1.5
      },
      refractionRatio: {
        value: 0.98
      }
    },
    aomap: {
      aoMap: {
        value: null
      },
      aoMapIntensity: {
        value: 1
      },
      aoMapTransform: {
        value: new Vt()
      }
    },
    lightmap: {
      lightMap: {
        value: null
      },
      lightMapIntensity: {
        value: 1
      },
      lightMapTransform: {
        value: new Vt()
      }
    },
    bumpmap: {
      bumpMap: {
        value: null
      },
      bumpMapTransform: {
        value: new Vt()
      },
      bumpScale: {
        value: 1
      }
    },
    normalmap: {
      normalMap: {
        value: null
      },
      normalMapTransform: {
        value: new Vt()
      },
      normalScale: {
        value: new vt(1, 1)
      }
    },
    displacementmap: {
      displacementMap: {
        value: null
      },
      displacementMapTransform: {
        value: new Vt()
      },
      displacementScale: {
        value: 1
      },
      displacementBias: {
        value: 0
      }
    },
    emissivemap: {
      emissiveMap: {
        value: null
      },
      emissiveMapTransform: {
        value: new Vt()
      }
    },
    metalnessmap: {
      metalnessMap: {
        value: null
      },
      metalnessMapTransform: {
        value: new Vt()
      }
    },
    roughnessmap: {
      roughnessMap: {
        value: null
      },
      roughnessMapTransform: {
        value: new Vt()
      }
    },
    gradientmap: {
      gradientMap: {
        value: null
      }
    },
    fog: {
      fogDensity: {
        value: 25e-5
      },
      fogNear: {
        value: 1
      },
      fogFar: {
        value: 2e3
      },
      fogColor: {
        value: new Ct(16777215)
      }
    },
    lights: {
      ambientLightColor: {
        value: []
      },
      lightProbe: {
        value: []
      },
      directionalLights: {
        value: [],
        properties: {
          direction: {},
          color: {}
        }
      },
      directionalLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {}
        }
      },
      directionalShadowMap: {
        value: []
      },
      directionalShadowMatrix: {
        value: []
      },
      spotLights: {
        value: [],
        properties: {
          color: {},
          position: {},
          direction: {},
          distance: {},
          coneCos: {},
          penumbraCos: {},
          decay: {}
        }
      },
      spotLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {}
        }
      },
      spotLightMap: {
        value: []
      },
      spotShadowMap: {
        value: []
      },
      spotLightMatrix: {
        value: []
      },
      pointLights: {
        value: [],
        properties: {
          color: {},
          position: {},
          decay: {},
          distance: {}
        }
      },
      pointLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
          shadowCameraNear: {},
          shadowCameraFar: {}
        }
      },
      pointShadowMap: {
        value: []
      },
      pointShadowMatrix: {
        value: []
      },
      hemisphereLights: {
        value: [],
        properties: {
          direction: {},
          skyColor: {},
          groundColor: {}
        }
      },
      rectAreaLights: {
        value: [],
        properties: {
          color: {},
          position: {},
          width: {},
          height: {}
        }
      },
      ltc_1: {
        value: null
      },
      ltc_2: {
        value: null
      }
    },
    points: {
      diffuse: {
        value: new Ct(16777215)
      },
      opacity: {
        value: 1
      },
      size: {
        value: 1
      },
      scale: {
        value: 1
      },
      map: {
        value: null
      },
      alphaMap: {
        value: null
      },
      alphaMapTransform: {
        value: new Vt()
      },
      alphaTest: {
        value: 0
      },
      uvTransform: {
        value: new Vt()
      }
    },
    sprite: {
      diffuse: {
        value: new Ct(16777215)
      },
      opacity: {
        value: 1
      },
      center: {
        value: new vt(0.5, 0.5)
      },
      rotation: {
        value: 0
      },
      map: {
        value: null
      },
      mapTransform: {
        value: new Vt()
      },
      alphaMap: {
        value: null
      },
      alphaMapTransform: {
        value: new Vt()
      },
      alphaTest: {
        value: 0
      }
    }
  }, Ln = {
    basic: {
      uniforms: Je([
        dt.common,
        dt.specularmap,
        dt.envmap,
        dt.aomap,
        dt.lightmap,
        dt.fog
      ]),
      vertexShader: Gt.meshbasic_vert,
      fragmentShader: Gt.meshbasic_frag
    },
    lambert: {
      uniforms: Je([
        dt.common,
        dt.specularmap,
        dt.envmap,
        dt.aomap,
        dt.lightmap,
        dt.emissivemap,
        dt.bumpmap,
        dt.normalmap,
        dt.displacementmap,
        dt.fog,
        dt.lights,
        {
          emissive: {
            value: new Ct(0)
          }
        }
      ]),
      vertexShader: Gt.meshlambert_vert,
      fragmentShader: Gt.meshlambert_frag
    },
    phong: {
      uniforms: Je([
        dt.common,
        dt.specularmap,
        dt.envmap,
        dt.aomap,
        dt.lightmap,
        dt.emissivemap,
        dt.bumpmap,
        dt.normalmap,
        dt.displacementmap,
        dt.fog,
        dt.lights,
        {
          emissive: {
            value: new Ct(0)
          },
          specular: {
            value: new Ct(1118481)
          },
          shininess: {
            value: 30
          }
        }
      ]),
      vertexShader: Gt.meshphong_vert,
      fragmentShader: Gt.meshphong_frag
    },
    standard: {
      uniforms: Je([
        dt.common,
        dt.envmap,
        dt.aomap,
        dt.lightmap,
        dt.emissivemap,
        dt.bumpmap,
        dt.normalmap,
        dt.displacementmap,
        dt.roughnessmap,
        dt.metalnessmap,
        dt.fog,
        dt.lights,
        {
          emissive: {
            value: new Ct(0)
          },
          roughness: {
            value: 1
          },
          metalness: {
            value: 0
          },
          envMapIntensity: {
            value: 1
          }
        }
      ]),
      vertexShader: Gt.meshphysical_vert,
      fragmentShader: Gt.meshphysical_frag
    },
    toon: {
      uniforms: Je([
        dt.common,
        dt.aomap,
        dt.lightmap,
        dt.emissivemap,
        dt.bumpmap,
        dt.normalmap,
        dt.displacementmap,
        dt.gradientmap,
        dt.fog,
        dt.lights,
        {
          emissive: {
            value: new Ct(0)
          }
        }
      ]),
      vertexShader: Gt.meshtoon_vert,
      fragmentShader: Gt.meshtoon_frag
    },
    matcap: {
      uniforms: Je([
        dt.common,
        dt.bumpmap,
        dt.normalmap,
        dt.displacementmap,
        dt.fog,
        {
          matcap: {
            value: null
          }
        }
      ]),
      vertexShader: Gt.meshmatcap_vert,
      fragmentShader: Gt.meshmatcap_frag
    },
    points: {
      uniforms: Je([
        dt.points,
        dt.fog
      ]),
      vertexShader: Gt.points_vert,
      fragmentShader: Gt.points_frag
    },
    dashed: {
      uniforms: Je([
        dt.common,
        dt.fog,
        {
          scale: {
            value: 1
          },
          dashSize: {
            value: 1
          },
          totalSize: {
            value: 2
          }
        }
      ]),
      vertexShader: Gt.linedashed_vert,
      fragmentShader: Gt.linedashed_frag
    },
    depth: {
      uniforms: Je([
        dt.common,
        dt.displacementmap
      ]),
      vertexShader: Gt.depth_vert,
      fragmentShader: Gt.depth_frag
    },
    normal: {
      uniforms: Je([
        dt.common,
        dt.bumpmap,
        dt.normalmap,
        dt.displacementmap,
        {
          opacity: {
            value: 1
          }
        }
      ]),
      vertexShader: Gt.meshnormal_vert,
      fragmentShader: Gt.meshnormal_frag
    },
    sprite: {
      uniforms: Je([
        dt.sprite,
        dt.fog
      ]),
      vertexShader: Gt.sprite_vert,
      fragmentShader: Gt.sprite_frag
    },
    background: {
      uniforms: {
        uvTransform: {
          value: new Vt()
        },
        t2D: {
          value: null
        },
        backgroundIntensity: {
          value: 1
        }
      },
      vertexShader: Gt.background_vert,
      fragmentShader: Gt.background_frag
    },
    backgroundCube: {
      uniforms: {
        envMap: {
          value: null
        },
        flipEnvMap: {
          value: -1
        },
        backgroundBlurriness: {
          value: 0
        },
        backgroundIntensity: {
          value: 1
        },
        backgroundRotation: {
          value: new Vt()
        }
      },
      vertexShader: Gt.backgroundCube_vert,
      fragmentShader: Gt.backgroundCube_frag
    },
    cube: {
      uniforms: {
        tCube: {
          value: null
        },
        tFlip: {
          value: -1
        },
        opacity: {
          value: 1
        }
      },
      vertexShader: Gt.cube_vert,
      fragmentShader: Gt.cube_frag
    },
    equirect: {
      uniforms: {
        tEquirect: {
          value: null
        }
      },
      vertexShader: Gt.equirect_vert,
      fragmentShader: Gt.equirect_frag
    },
    distanceRGBA: {
      uniforms: Je([
        dt.common,
        dt.displacementmap,
        {
          referencePosition: {
            value: new L()
          },
          nearDistance: {
            value: 1
          },
          farDistance: {
            value: 1e3
          }
        }
      ]),
      vertexShader: Gt.distanceRGBA_vert,
      fragmentShader: Gt.distanceRGBA_frag
    },
    shadow: {
      uniforms: Je([
        dt.lights,
        dt.fog,
        {
          color: {
            value: new Ct(0)
          },
          opacity: {
            value: 1
          }
        }
      ]),
      vertexShader: Gt.shadow_vert,
      fragmentShader: Gt.shadow_frag
    }
  };
  Ln.physical = {
    uniforms: Je([
      Ln.standard.uniforms,
      {
        clearcoat: {
          value: 0
        },
        clearcoatMap: {
          value: null
        },
        clearcoatMapTransform: {
          value: new Vt()
        },
        clearcoatNormalMap: {
          value: null
        },
        clearcoatNormalMapTransform: {
          value: new Vt()
        },
        clearcoatNormalScale: {
          value: new vt(1, 1)
        },
        clearcoatRoughness: {
          value: 0
        },
        clearcoatRoughnessMap: {
          value: null
        },
        clearcoatRoughnessMapTransform: {
          value: new Vt()
        },
        dispersion: {
          value: 0
        },
        iridescence: {
          value: 0
        },
        iridescenceMap: {
          value: null
        },
        iridescenceMapTransform: {
          value: new Vt()
        },
        iridescenceIOR: {
          value: 1.3
        },
        iridescenceThicknessMinimum: {
          value: 100
        },
        iridescenceThicknessMaximum: {
          value: 400
        },
        iridescenceThicknessMap: {
          value: null
        },
        iridescenceThicknessMapTransform: {
          value: new Vt()
        },
        sheen: {
          value: 0
        },
        sheenColor: {
          value: new Ct(0)
        },
        sheenColorMap: {
          value: null
        },
        sheenColorMapTransform: {
          value: new Vt()
        },
        sheenRoughness: {
          value: 1
        },
        sheenRoughnessMap: {
          value: null
        },
        sheenRoughnessMapTransform: {
          value: new Vt()
        },
        transmission: {
          value: 0
        },
        transmissionMap: {
          value: null
        },
        transmissionMapTransform: {
          value: new Vt()
        },
        transmissionSamplerSize: {
          value: new vt()
        },
        transmissionSamplerMap: {
          value: null
        },
        thickness: {
          value: 0
        },
        thicknessMap: {
          value: null
        },
        thicknessMapTransform: {
          value: new Vt()
        },
        attenuationDistance: {
          value: 0
        },
        attenuationColor: {
          value: new Ct(0)
        },
        specularColor: {
          value: new Ct(1, 1, 1)
        },
        specularColorMap: {
          value: null
        },
        specularColorMapTransform: {
          value: new Vt()
        },
        specularIntensity: {
          value: 1
        },
        specularIntensityMap: {
          value: null
        },
        specularIntensityMapTransform: {
          value: new Vt()
        },
        anisotropyVector: {
          value: new vt()
        },
        anisotropyMap: {
          value: null
        },
        anisotropyMapTransform: {
          value: new Vt()
        }
      }
    ]),
    vertexShader: Gt.meshphysical_vert,
    fragmentShader: Gt.meshphysical_frag
  };
  const js = {
    r: 0,
    b: 0,
    g: 0
  }, Ii = new Pn(), Gg = new Ht();
  function Vg(r, t, e, n, i, s, a) {
    const o = new Ct(0);
    let c = s === true ? 0 : 1, l, h, d = null, u = 0, p = null;
    function w(E) {
      let v = E.isScene === true ? E.background : null;
      return v && v.isTexture && (v = (E.backgroundBlurriness > 0 ? e : t).get(v)), v;
    }
    function b(E) {
      let v = false;
      const T = w(E);
      T === null ? _(o, c) : T && T.isColor && (_(T, 1), v = true);
      const O = r.xr.getEnvironmentBlendMode();
      O === "additive" ? n.buffers.color.setClear(0, 0, 0, 1, a) : O === "alpha-blend" && n.buffers.color.setClear(0, 0, 0, 0, a), (r.autoClear || v) && (n.buffers.depth.setTest(true), n.buffers.depth.setMask(true), n.buffers.color.setMask(true), r.clear(r.autoClearColor, r.autoClearDepth, r.autoClearStencil));
    }
    function m(E, v) {
      const T = w(v);
      T && (T.isCubeTexture || T.mapping === Oa) ? (h === void 0 && (h = new fe(new Cn(1, 1, 1), new Qn({
        name: "BackgroundCubeMaterial",
        uniforms: Ar(Ln.backgroundCube.uniforms),
        vertexShader: Ln.backgroundCube.vertexShader,
        fragmentShader: Ln.backgroundCube.fragmentShader,
        side: nn,
        depthTest: false,
        depthWrite: false,
        fog: false
      })), h.geometry.deleteAttribute("normal"), h.geometry.deleteAttribute("uv"), h.onBeforeRender = function(O, R, P) {
        this.matrixWorld.copyPosition(P.matrixWorld);
      }, Object.defineProperty(h.material, "envMap", {
        get: function() {
          return this.uniforms.envMap.value;
        }
      }), i.update(h)), Ii.copy(v.backgroundRotation), Ii.x *= -1, Ii.y *= -1, Ii.z *= -1, T.isCubeTexture && T.isRenderTargetTexture === false && (Ii.y *= -1, Ii.z *= -1), h.material.uniforms.envMap.value = T, h.material.uniforms.flipEnvMap.value = T.isCubeTexture && T.isRenderTargetTexture === false ? -1 : 1, h.material.uniforms.backgroundBlurriness.value = v.backgroundBlurriness, h.material.uniforms.backgroundIntensity.value = v.backgroundIntensity, h.material.uniforms.backgroundRotation.value.setFromMatrix4(Gg.makeRotationFromEuler(Ii)), h.material.toneMapped = ie.getTransfer(T.colorSpace) !== me, (d !== T || u !== T.version || p !== r.toneMapping) && (h.material.needsUpdate = true, d = T, u = T.version, p = r.toneMapping), h.layers.enableAll(), E.unshift(h, h.geometry, h.material, 0, 0, null)) : T && T.isTexture && (l === void 0 && (l = new fe(new ys(2, 2), new Qn({
        name: "BackgroundMaterial",
        uniforms: Ar(Ln.background.uniforms),
        vertexShader: Ln.background.vertexShader,
        fragmentShader: Ln.background.fragmentShader,
        side: Jn,
        depthTest: false,
        depthWrite: false,
        fog: false
      })), l.geometry.deleteAttribute("normal"), Object.defineProperty(l.material, "map", {
        get: function() {
          return this.uniforms.t2D.value;
        }
      }), i.update(l)), l.material.uniforms.t2D.value = T, l.material.uniforms.backgroundIntensity.value = v.backgroundIntensity, l.material.toneMapped = ie.getTransfer(T.colorSpace) !== me, T.matrixAutoUpdate === true && T.updateMatrix(), l.material.uniforms.uvTransform.value.copy(T.matrix), (d !== T || u !== T.version || p !== r.toneMapping) && (l.material.needsUpdate = true, d = T, u = T.version, p = r.toneMapping), l.layers.enableAll(), E.unshift(l, l.geometry, l.material, 0, 0, null));
    }
    function _(E, v) {
      E.getRGB(js, Pu(r)), n.buffers.color.setClear(js.r, js.g, js.b, v, a);
    }
    return {
      getClearColor: function() {
        return o;
      },
      setClearColor: function(E, v = 1) {
        o.set(E), c = v, _(o, c);
      },
      getClearAlpha: function() {
        return c;
      },
      setClearAlpha: function(E) {
        c = E, _(o, c);
      },
      render: b,
      addToRenderList: m
    };
  }
  function Wg(r, t) {
    const e = r.getParameter(r.MAX_VERTEX_ATTRIBS), n = {}, i = u(null);
    let s = i, a = false;
    function o(S, F, W, V, Z) {
      let tt = false;
      const Y = d(V, W, F);
      s !== Y && (s = Y, l(s.object)), tt = p(S, V, W, Z), tt && w(S, V, W, Z), Z !== null && t.update(Z, r.ELEMENT_ARRAY_BUFFER), (tt || a) && (a = false, T(S, F, W, V), Z !== null && r.bindBuffer(r.ELEMENT_ARRAY_BUFFER, t.get(Z).buffer));
    }
    function c() {
      return r.createVertexArray();
    }
    function l(S) {
      return r.bindVertexArray(S);
    }
    function h(S) {
      return r.deleteVertexArray(S);
    }
    function d(S, F, W) {
      const V = W.wireframe === true;
      let Z = n[S.id];
      Z === void 0 && (Z = {}, n[S.id] = Z);
      let tt = Z[F.id];
      tt === void 0 && (tt = {}, Z[F.id] = tt);
      let Y = tt[V];
      return Y === void 0 && (Y = u(c()), tt[V] = Y), Y;
    }
    function u(S) {
      const F = [], W = [], V = [];
      for (let Z = 0; Z < e; Z++) F[Z] = 0, W[Z] = 0, V[Z] = 0;
      return {
        geometry: null,
        program: null,
        wireframe: false,
        newAttributes: F,
        enabledAttributes: W,
        attributeDivisors: V,
        object: S,
        attributes: {},
        index: null
      };
    }
    function p(S, F, W, V) {
      const Z = s.attributes, tt = F.attributes;
      let Y = 0;
      const J = W.getAttributes();
      for (const $ in J) if (J[$].location >= 0) {
        const mt = Z[$];
        let gt = tt[$];
        if (gt === void 0 && ($ === "instanceMatrix" && S.instanceMatrix && (gt = S.instanceMatrix), $ === "instanceColor" && S.instanceColor && (gt = S.instanceColor)), mt === void 0 || mt.attribute !== gt || gt && mt.data !== gt.data) return true;
        Y++;
      }
      return s.attributesNum !== Y || s.index !== V;
    }
    function w(S, F, W, V) {
      const Z = {}, tt = F.attributes;
      let Y = 0;
      const J = W.getAttributes();
      for (const $ in J) if (J[$].location >= 0) {
        let mt = tt[$];
        mt === void 0 && ($ === "instanceMatrix" && S.instanceMatrix && (mt = S.instanceMatrix), $ === "instanceColor" && S.instanceColor && (mt = S.instanceColor));
        const gt = {};
        gt.attribute = mt, mt && mt.data && (gt.data = mt.data), Z[$] = gt, Y++;
      }
      s.attributes = Z, s.attributesNum = Y, s.index = V;
    }
    function b() {
      const S = s.newAttributes;
      for (let F = 0, W = S.length; F < W; F++) S[F] = 0;
    }
    function m(S) {
      _(S, 0);
    }
    function _(S, F) {
      const W = s.newAttributes, V = s.enabledAttributes, Z = s.attributeDivisors;
      W[S] = 1, V[S] === 0 && (r.enableVertexAttribArray(S), V[S] = 1), Z[S] !== F && (r.vertexAttribDivisor(S, F), Z[S] = F);
    }
    function E() {
      const S = s.newAttributes, F = s.enabledAttributes;
      for (let W = 0, V = F.length; W < V; W++) F[W] !== S[W] && (r.disableVertexAttribArray(W), F[W] = 0);
    }
    function v(S, F, W, V, Z, tt, Y) {
      Y === true ? r.vertexAttribIPointer(S, F, W, Z, tt) : r.vertexAttribPointer(S, F, W, V, Z, tt);
    }
    function T(S, F, W, V) {
      b();
      const Z = V.attributes, tt = W.getAttributes(), Y = F.defaultAttributeValues;
      for (const J in tt) {
        const $ = tt[J];
        if ($.location >= 0) {
          let ut = Z[J];
          if (ut === void 0 && (J === "instanceMatrix" && S.instanceMatrix && (ut = S.instanceMatrix), J === "instanceColor" && S.instanceColor && (ut = S.instanceColor)), ut !== void 0) {
            const mt = ut.normalized, gt = ut.itemSize, qt = t.get(ut);
            if (qt === void 0) continue;
            const ee = qt.buffer, Q = qt.type, st = qt.bytesPerElement, _t = Q === r.INT || Q === r.UNSIGNED_INT || ut.gpuType === uu;
            if (ut.isInterleavedBufferAttribute) {
              const lt = ut.data, kt = lt.stride, Dt = ut.offset;
              if (lt.isInstancedInterleavedBuffer) {
                for (let Kt = 0; Kt < $.locationSize; Kt++) _($.location + Kt, lt.meshPerAttribute);
                S.isInstancedMesh !== true && V._maxInstanceCount === void 0 && (V._maxInstanceCount = lt.meshPerAttribute * lt.count);
              } else for (let Kt = 0; Kt < $.locationSize; Kt++) m($.location + Kt);
              r.bindBuffer(r.ARRAY_BUFFER, ee);
              for (let Kt = 0; Kt < $.locationSize; Kt++) v($.location + Kt, gt / $.locationSize, Q, mt, kt * st, (Dt + gt / $.locationSize * Kt) * st, _t);
            } else {
              if (ut.isInstancedBufferAttribute) {
                for (let lt = 0; lt < $.locationSize; lt++) _($.location + lt, ut.meshPerAttribute);
                S.isInstancedMesh !== true && V._maxInstanceCount === void 0 && (V._maxInstanceCount = ut.meshPerAttribute * ut.count);
              } else for (let lt = 0; lt < $.locationSize; lt++) m($.location + lt);
              r.bindBuffer(r.ARRAY_BUFFER, ee);
              for (let lt = 0; lt < $.locationSize; lt++) v($.location + lt, gt / $.locationSize, Q, mt, gt * st, gt / $.locationSize * lt * st, _t);
            }
          } else if (Y !== void 0) {
            const mt = Y[J];
            if (mt !== void 0) switch (mt.length) {
              case 2:
                r.vertexAttrib2fv($.location, mt);
                break;
              case 3:
                r.vertexAttrib3fv($.location, mt);
                break;
              case 4:
                r.vertexAttrib4fv($.location, mt);
                break;
              default:
                r.vertexAttrib1fv($.location, mt);
            }
          }
        }
      }
      E();
    }
    function O() {
      z();
      for (const S in n) {
        const F = n[S];
        for (const W in F) {
          const V = F[W];
          for (const Z in V) h(V[Z].object), delete V[Z];
          delete F[W];
        }
        delete n[S];
      }
    }
    function R(S) {
      if (n[S.id] === void 0) return;
      const F = n[S.id];
      for (const W in F) {
        const V = F[W];
        for (const Z in V) h(V[Z].object), delete V[Z];
        delete F[W];
      }
      delete n[S.id];
    }
    function P(S) {
      for (const F in n) {
        const W = n[F];
        if (W[S.id] === void 0) continue;
        const V = W[S.id];
        for (const Z in V) h(V[Z].object), delete V[Z];
        delete W[S.id];
      }
    }
    function z() {
      A(), a = true, s !== i && (s = i, l(s.object));
    }
    function A() {
      i.geometry = null, i.program = null, i.wireframe = false;
    }
    return {
      setup: o,
      reset: z,
      resetDefaultState: A,
      dispose: O,
      releaseStatesOfGeometry: R,
      releaseStatesOfProgram: P,
      initAttributes: b,
      enableAttribute: m,
      disableUnusedAttributes: E
    };
  }
  function jg(r, t, e) {
    let n;
    function i(l) {
      n = l;
    }
    function s(l, h) {
      r.drawArrays(n, l, h), e.update(h, n, 1);
    }
    function a(l, h, d) {
      d !== 0 && (r.drawArraysInstanced(n, l, h, d), e.update(h, n, d));
    }
    function o(l, h, d) {
      if (d === 0) return;
      const u = t.get("WEBGL_multi_draw");
      if (u === null) for (let p = 0; p < d; p++) this.render(l[p], h[p]);
      else {
        u.multiDrawArraysWEBGL(n, l, 0, h, 0, d);
        let p = 0;
        for (let w = 0; w < d; w++) p += h[w];
        e.update(p, n, 1);
      }
    }
    function c(l, h, d, u) {
      if (d === 0) return;
      const p = t.get("WEBGL_multi_draw");
      if (p === null) for (let w = 0; w < l.length; w++) a(l[w], h[w], u[w]);
      else {
        p.multiDrawArraysInstancedWEBGL(n, l, 0, h, 0, u, 0, d);
        let w = 0;
        for (let b = 0; b < d; b++) w += h[b];
        for (let b = 0; b < u.length; b++) e.update(w, n, u[b]);
      }
    }
    this.setMode = i, this.render = s, this.renderInstances = a, this.renderMultiDraw = o, this.renderMultiDrawInstances = c;
  }
  function Xg(r, t, e, n) {
    let i;
    function s() {
      if (i !== void 0) return i;
      if (t.has("EXT_texture_filter_anisotropic") === true) {
        const R = t.get("EXT_texture_filter_anisotropic");
        i = r.getParameter(R.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
      } else i = 0;
      return i;
    }
    function a(R) {
      return !(R !== Tn && n.convert(R) !== r.getParameter(r.IMPLEMENTATION_COLOR_READ_FORMAT));
    }
    function o(R) {
      const P = R === Ba && (t.has("EXT_color_buffer_half_float") || t.has("EXT_color_buffer_float"));
      return !(R !== Si && n.convert(R) !== r.getParameter(r.IMPLEMENTATION_COLOR_READ_TYPE) && R !== Dn && !P);
    }
    function c(R) {
      if (R === "highp") {
        if (r.getShaderPrecisionFormat(r.VERTEX_SHADER, r.HIGH_FLOAT).precision > 0 && r.getShaderPrecisionFormat(r.FRAGMENT_SHADER, r.HIGH_FLOAT).precision > 0) return "highp";
        R = "mediump";
      }
      return R === "mediump" && r.getShaderPrecisionFormat(r.VERTEX_SHADER, r.MEDIUM_FLOAT).precision > 0 && r.getShaderPrecisionFormat(r.FRAGMENT_SHADER, r.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp";
    }
    let l = e.precision !== void 0 ? e.precision : "highp";
    const h = c(l);
    h !== l && (console.warn("THREE.WebGLRenderer:", l, "not supported, using", h, "instead."), l = h);
    const d = e.logarithmicDepthBuffer === true, u = r.getParameter(r.MAX_TEXTURE_IMAGE_UNITS), p = r.getParameter(r.MAX_VERTEX_TEXTURE_IMAGE_UNITS), w = r.getParameter(r.MAX_TEXTURE_SIZE), b = r.getParameter(r.MAX_CUBE_MAP_TEXTURE_SIZE), m = r.getParameter(r.MAX_VERTEX_ATTRIBS), _ = r.getParameter(r.MAX_VERTEX_UNIFORM_VECTORS), E = r.getParameter(r.MAX_VARYING_VECTORS), v = r.getParameter(r.MAX_FRAGMENT_UNIFORM_VECTORS), T = p > 0, O = r.getParameter(r.MAX_SAMPLES);
    return {
      isWebGL2: true,
      getMaxAnisotropy: s,
      getMaxPrecision: c,
      textureFormatReadable: a,
      textureTypeReadable: o,
      precision: l,
      logarithmicDepthBuffer: d,
      maxTextures: u,
      maxVertexTextures: p,
      maxTextureSize: w,
      maxCubemapSize: b,
      maxAttributes: m,
      maxVertexUniforms: _,
      maxVaryings: E,
      maxFragmentUniforms: v,
      vertexTextures: T,
      maxSamples: O
    };
  }
  function qg(r) {
    const t = this;
    let e = null, n = 0, i = false, s = false;
    const a = new mi(), o = new Vt(), c = {
      value: null,
      needsUpdate: false
    };
    this.uniform = c, this.numPlanes = 0, this.numIntersection = 0, this.init = function(d, u) {
      const p = d.length !== 0 || u || n !== 0 || i;
      return i = u, n = d.length, p;
    }, this.beginShadows = function() {
      s = true, h(null);
    }, this.endShadows = function() {
      s = false;
    }, this.setGlobalState = function(d, u) {
      e = h(d, u, 0);
    }, this.setState = function(d, u, p) {
      const w = d.clippingPlanes, b = d.clipIntersection, m = d.clipShadows, _ = r.get(d);
      if (!i || w === null || w.length === 0 || s && !m) s ? h(null) : l();
      else {
        const E = s ? 0 : n, v = E * 4;
        let T = _.clippingState || null;
        c.value = T, T = h(w, u, v, p);
        for (let O = 0; O !== v; ++O) T[O] = e[O];
        _.clippingState = T, this.numIntersection = b ? this.numPlanes : 0, this.numPlanes += E;
      }
    };
    function l() {
      c.value !== e && (c.value = e, c.needsUpdate = n > 0), t.numPlanes = n, t.numIntersection = 0;
    }
    function h(d, u, p, w) {
      const b = d !== null ? d.length : 0;
      let m = null;
      if (b !== 0) {
        if (m = c.value, w !== true || m === null) {
          const _ = p + b * 4, E = u.matrixWorldInverse;
          o.getNormalMatrix(E), (m === null || m.length < _) && (m = new Float32Array(_));
          for (let v = 0, T = p; v !== b; ++v, T += 4) a.copy(d[v]).applyMatrix4(E, o), a.normal.toArray(m, T), m[T + 3] = a.constant;
        }
        c.value = m, c.needsUpdate = true;
      }
      return t.numPlanes = b, t.numIntersection = 0, m;
    }
  }
  function Kg(r) {
    let t = /* @__PURE__ */ new WeakMap();
    function e(a, o) {
      return o === yc ? a.mapping = vr : o === vc && (a.mapping = xr), a;
    }
    function n(a) {
      if (a && a.isTexture) {
        const o = a.mapping;
        if (o === yc || o === vc) if (t.has(a)) {
          const c = t.get(a).texture;
          return e(c, a.mapping);
        } else {
          const c = a.image;
          if (c && c.height > 0) {
            const l = new s_(c.height);
            return l.fromEquirectangularTexture(r, a), t.set(a, l), a.addEventListener("dispose", i), e(l.texture, a.mapping);
          } else return null;
        }
      }
      return a;
    }
    function i(a) {
      const o = a.target;
      o.removeEventListener("dispose", i);
      const c = t.get(o);
      c !== void 0 && (t.delete(o), c.dispose());
    }
    function s() {
      t = /* @__PURE__ */ new WeakMap();
    }
    return {
      get: n,
      dispose: s
    };
  }
  class Fc extends Lu {
    constructor(t = -1, e = 1, n = 1, i = -1, s = 0.1, a = 2e3) {
      super(), this.isOrthographicCamera = true, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = t, this.right = e, this.top = n, this.bottom = i, this.near = s, this.far = a, this.updateProjectionMatrix();
    }
    copy(t, e) {
      return super.copy(t, e), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this.view = t.view === null ? null : Object.assign({}, t.view), this;
    }
    setViewOffset(t, e, n, i, s, a) {
      this.view === null && (this.view = {
        enabled: true,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      }), this.view.enabled = true, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = i, this.view.width = s, this.view.height = a, this.updateProjectionMatrix();
    }
    clearViewOffset() {
      this.view !== null && (this.view.enabled = false), this.updateProjectionMatrix();
    }
    updateProjectionMatrix() {
      const t = (this.right - this.left) / (2 * this.zoom), e = (this.top - this.bottom) / (2 * this.zoom), n = (this.right + this.left) / 2, i = (this.top + this.bottom) / 2;
      let s = n - t, a = n + t, o = i + e, c = i - e;
      if (this.view !== null && this.view.enabled) {
        const l = (this.right - this.left) / this.view.fullWidth / this.zoom, h = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
        s += l * this.view.offsetX, a = s + l * this.view.width, o -= h * this.view.offsetY, c = o - h * this.view.height;
      }
      this.projectionMatrix.makeOrthographic(s, a, o, c, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
    }
    toJSON(t) {
      const e = super.toJSON(t);
      return e.object.zoom = this.zoom, e.object.left = this.left, e.object.right = this.right, e.object.top = this.top, e.object.bottom = this.bottom, e.object.near = this.near, e.object.far = this.far, this.view !== null && (e.object.view = Object.assign({}, this.view)), e;
    }
  }
  const mr = 4, Nh = [
    0.125,
    0.215,
    0.35,
    0.446,
    0.526,
    0.582
  ], Fi = 20, Wo = new Fc(), Uh = new Ct();
  let jo = null, Xo = 0, qo = 0, Ko = false;
  const Ni = (1 + Math.sqrt(5)) / 2, cr = 1 / Ni, Fh = [
    new L(-Ni, cr, 0),
    new L(Ni, cr, 0),
    new L(-cr, 0, Ni),
    new L(cr, 0, Ni),
    new L(0, Ni, -cr),
    new L(0, Ni, cr),
    new L(-1, 1, -1),
    new L(1, 1, -1),
    new L(-1, 1, 1),
    new L(1, 1, 1)
  ];
  class Oh {
    constructor(t) {
      this._renderer = t, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial);
    }
    fromScene(t, e = 0, n = 0.1, i = 100) {
      jo = this._renderer.getRenderTarget(), Xo = this._renderer.getActiveCubeFace(), qo = this._renderer.getActiveMipmapLevel(), Ko = this._renderer.xr.enabled, this._renderer.xr.enabled = false, this._setSize(256);
      const s = this._allocateTargets();
      return s.depthBuffer = true, this._sceneToCubeUV(t, n, i, s), e > 0 && this._blur(s, 0, 0, e), this._applyPMREM(s), this._cleanup(s), s;
    }
    fromEquirectangular(t, e = null) {
      return this._fromTexture(t, e);
    }
    fromCubemap(t, e = null) {
      return this._fromTexture(t, e);
    }
    compileCubemapShader() {
      this._cubemapMaterial === null && (this._cubemapMaterial = kh(), this._compileMaterial(this._cubemapMaterial));
    }
    compileEquirectangularShader() {
      this._equirectMaterial === null && (this._equirectMaterial = zh(), this._compileMaterial(this._equirectMaterial));
    }
    dispose() {
      this._dispose(), this._cubemapMaterial !== null && this._cubemapMaterial.dispose(), this._equirectMaterial !== null && this._equirectMaterial.dispose();
    }
    _setSize(t) {
      this._lodMax = Math.floor(Math.log2(t)), this._cubeSize = Math.pow(2, this._lodMax);
    }
    _dispose() {
      this._blurMaterial !== null && this._blurMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
      for (let t = 0; t < this._lodPlanes.length; t++) this._lodPlanes[t].dispose();
    }
    _cleanup(t) {
      this._renderer.setRenderTarget(jo, Xo, qo), this._renderer.xr.enabled = Ko, t.scissorTest = false, Xs(t, 0, 0, t.width, t.height);
    }
    _fromTexture(t, e) {
      t.mapping === vr || t.mapping === xr ? this._setSize(t.image.length === 0 ? 16 : t.image[0].width || t.image[0].image.width) : this._setSize(t.image.width / 4), jo = this._renderer.getRenderTarget(), Xo = this._renderer.getActiveCubeFace(), qo = this._renderer.getActiveMipmapLevel(), Ko = this._renderer.xr.enabled, this._renderer.xr.enabled = false;
      const n = e || this._allocateTargets();
      return this._textureToCubeUV(t, n), this._applyPMREM(n), this._cleanup(n), n;
    }
    _allocateTargets() {
      const t = 3 * Math.max(this._cubeSize, 112), e = 4 * this._cubeSize, n = {
        magFilter: dn,
        minFilter: dn,
        generateMipmaps: false,
        type: Ba,
        format: Tn,
        colorSpace: je,
        depthBuffer: false
      }, i = Bh(t, e, n);
      if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== t || this._pingPongRenderTarget.height !== e) {
        this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget = Bh(t, e, n);
        const { _lodMax: s } = this;
        ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = Yg(s)), this._blurMaterial = Zg(s, t, e);
      }
      return i;
    }
    _compileMaterial(t) {
      const e = new fe(this._lodPlanes[0], t);
      this._renderer.compile(e, Wo);
    }
    _sceneToCubeUV(t, e, n, i) {
      const o = new tn(90, 1, e, n), c = [
        1,
        -1,
        1,
        1,
        1,
        1
      ], l = [
        1,
        1,
        1,
        -1,
        -1,
        -1
      ], h = this._renderer, d = h.autoClear, u = h.toneMapping;
      h.getClearColor(Uh), h.toneMapping = xi, h.autoClear = false;
      const p = new Nn({
        name: "PMREM.Background",
        side: nn,
        depthWrite: false,
        depthTest: false
      }), w = new fe(new Cn(), p);
      let b = false;
      const m = t.background;
      m ? m.isColor && (p.color.copy(m), t.background = null, b = true) : (p.color.copy(Uh), b = true);
      for (let _ = 0; _ < 6; _++) {
        const E = _ % 3;
        E === 0 ? (o.up.set(0, c[_], 0), o.lookAt(l[_], 0, 0)) : E === 1 ? (o.up.set(0, 0, c[_]), o.lookAt(0, l[_], 0)) : (o.up.set(0, c[_], 0), o.lookAt(0, 0, l[_]));
        const v = this._cubeSize;
        Xs(i, E * v, _ > 2 ? v : 0, v, v), h.setRenderTarget(i), b && h.render(w, o), h.render(t, o);
      }
      w.geometry.dispose(), w.material.dispose(), h.toneMapping = u, h.autoClear = d, t.background = m;
    }
    _textureToCubeUV(t, e) {
      const n = this._renderer, i = t.mapping === vr || t.mapping === xr;
      i ? (this._cubemapMaterial === null && (this._cubemapMaterial = kh()), this._cubemapMaterial.uniforms.flipEnvMap.value = t.isRenderTargetTexture === false ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = zh());
      const s = i ? this._cubemapMaterial : this._equirectMaterial, a = new fe(this._lodPlanes[0], s), o = s.uniforms;
      o.envMap.value = t;
      const c = this._cubeSize;
      Xs(e, 0, 0, 3 * c, 2 * c), n.setRenderTarget(e), n.render(a, Wo);
    }
    _applyPMREM(t) {
      const e = this._renderer, n = e.autoClear;
      e.autoClear = false;
      const i = this._lodPlanes.length;
      for (let s = 1; s < i; s++) {
        const a = Math.sqrt(this._sigmas[s] * this._sigmas[s] - this._sigmas[s - 1] * this._sigmas[s - 1]), o = Fh[(i - s - 1) % Fh.length];
        this._blur(t, s - 1, s, a, o);
      }
      e.autoClear = n;
    }
    _blur(t, e, n, i, s) {
      const a = this._pingPongRenderTarget;
      this._halfBlur(t, a, e, n, i, "latitudinal", s), this._halfBlur(a, t, n, n, i, "longitudinal", s);
    }
    _halfBlur(t, e, n, i, s, a, o) {
      const c = this._renderer, l = this._blurMaterial;
      a !== "latitudinal" && a !== "longitudinal" && console.error("blur direction must be either latitudinal or longitudinal!");
      const h = 3, d = new fe(this._lodPlanes[i], l), u = l.uniforms, p = this._sizeLods[n] - 1, w = isFinite(s) ? Math.PI / (2 * p) : 2 * Math.PI / (2 * Fi - 1), b = s / w, m = isFinite(s) ? 1 + Math.floor(h * b) : Fi;
      m > Fi && console.warn(`sigmaRadians, ${s}, is too large and will clip, as it requested ${m} samples when the maximum is set to ${Fi}`);
      const _ = [];
      let E = 0;
      for (let P = 0; P < Fi; ++P) {
        const z = P / b, A = Math.exp(-z * z / 2);
        _.push(A), P === 0 ? E += A : P < m && (E += 2 * A);
      }
      for (let P = 0; P < _.length; P++) _[P] = _[P] / E;
      u.envMap.value = t.texture, u.samples.value = m, u.weights.value = _, u.latitudinal.value = a === "latitudinal", o && (u.poleAxis.value = o);
      const { _lodMax: v } = this;
      u.dTheta.value = w, u.mipInt.value = v - n;
      const T = this._sizeLods[i], O = 3 * T * (i > v - mr ? i - v + mr : 0), R = 4 * (this._cubeSize - T);
      Xs(e, O, R, 3 * T, 2 * T), c.setRenderTarget(e), c.render(d, Wo);
    }
  }
  function Yg(r) {
    const t = [], e = [], n = [];
    let i = r;
    const s = r - mr + 1 + Nh.length;
    for (let a = 0; a < s; a++) {
      const o = Math.pow(2, i);
      e.push(o);
      let c = 1 / o;
      a > r - mr ? c = Nh[a - r + mr - 1] : a === 0 && (c = 0), n.push(c);
      const l = 1 / (o - 2), h = -l, d = 1 + l, u = [
        h,
        h,
        d,
        h,
        d,
        d,
        h,
        h,
        d,
        d,
        h,
        d
      ], p = 6, w = 6, b = 3, m = 2, _ = 1, E = new Float32Array(b * w * p), v = new Float32Array(m * w * p), T = new Float32Array(_ * w * p);
      for (let R = 0; R < p; R++) {
        const P = R % 3 * 2 / 3 - 1, z = R > 2 ? 0 : -1, A = [
          P,
          z,
          0,
          P + 2 / 3,
          z,
          0,
          P + 2 / 3,
          z + 1,
          0,
          P,
          z,
          0,
          P + 2 / 3,
          z + 1,
          0,
          P,
          z + 1,
          0
        ];
        E.set(A, b * w * R), v.set(u, m * w * R);
        const S = [
          R,
          R,
          R,
          R,
          R,
          R
        ];
        T.set(S, _ * w * R);
      }
      const O = new sn();
      O.setAttribute("position", new rn(E, b)), O.setAttribute("uv", new rn(v, m)), O.setAttribute("faceIndex", new rn(T, _)), t.push(O), i > mr && i--;
    }
    return {
      lodPlanes: t,
      sizeLods: e,
      sigmas: n
    };
  }
  function Bh(r, t, e) {
    const n = new Bi(r, t, e);
    return n.texture.mapping = Oa, n.texture.name = "PMREM.cubeUv", n.scissorTest = true, n;
  }
  function Xs(r, t, e, n, i) {
    r.viewport.set(t, e, n, i), r.scissor.set(t, e, n, i);
  }
  function Zg(r, t, e) {
    const n = new Float32Array(Fi), i = new L(0, 1, 0);
    return new Qn({
      name: "SphericalGaussianBlur",
      defines: {
        n: Fi,
        CUBEUV_TEXEL_WIDTH: 1 / t,
        CUBEUV_TEXEL_HEIGHT: 1 / e,
        CUBEUV_MAX_MIP: `${r}.0`
      },
      uniforms: {
        envMap: {
          value: null
        },
        samples: {
          value: 1
        },
        weights: {
          value: n
        },
        latitudinal: {
          value: false
        },
        dTheta: {
          value: 0
        },
        mipInt: {
          value: 0
        },
        poleAxis: {
          value: i
        }
      },
      vertexShader: Oc(),
      fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
      blending: vi,
      depthTest: false,
      depthWrite: false
    });
  }
  function zh() {
    return new Qn({
      name: "EquirectangularToCubeUV",
      uniforms: {
        envMap: {
          value: null
        }
      },
      vertexShader: Oc(),
      fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
      blending: vi,
      depthTest: false,
      depthWrite: false
    });
  }
  function kh() {
    return new Qn({
      name: "CubemapToCubeUV",
      uniforms: {
        envMap: {
          value: null
        },
        flipEnvMap: {
          value: -1
        }
      },
      vertexShader: Oc(),
      fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
      blending: vi,
      depthTest: false,
      depthWrite: false
    });
  }
  function Oc() {
    return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
  }
  function $g(r) {
    let t = /* @__PURE__ */ new WeakMap(), e = null;
    function n(o) {
      if (o && o.isTexture) {
        const c = o.mapping, l = c === yc || c === vc, h = c === vr || c === xr;
        if (l || h) {
          let d = t.get(o);
          const u = d !== void 0 ? d.texture.pmremVersion : 0;
          if (o.isRenderTargetTexture && o.pmremVersion !== u) return e === null && (e = new Oh(r)), d = l ? e.fromEquirectangular(o, d) : e.fromCubemap(o, d), d.texture.pmremVersion = o.pmremVersion, t.set(o, d), d.texture;
          if (d !== void 0) return d.texture;
          {
            const p = o.image;
            return l && p && p.height > 0 || h && p && i(p) ? (e === null && (e = new Oh(r)), d = l ? e.fromEquirectangular(o) : e.fromCubemap(o), d.texture.pmremVersion = o.pmremVersion, t.set(o, d), o.addEventListener("dispose", s), d.texture) : null;
          }
        }
      }
      return o;
    }
    function i(o) {
      let c = 0;
      const l = 6;
      for (let h = 0; h < l; h++) o[h] !== void 0 && c++;
      return c === l;
    }
    function s(o) {
      const c = o.target;
      c.removeEventListener("dispose", s);
      const l = t.get(c);
      l !== void 0 && (t.delete(c), l.dispose());
    }
    function a() {
      t = /* @__PURE__ */ new WeakMap(), e !== null && (e.dispose(), e = null);
    }
    return {
      get: n,
      dispose: a
    };
  }
  function Jg(r) {
    const t = {};
    function e(n) {
      if (t[n] !== void 0) return t[n];
      let i;
      switch (n) {
        case "WEBGL_depth_texture":
          i = r.getExtension("WEBGL_depth_texture") || r.getExtension("MOZ_WEBGL_depth_texture") || r.getExtension("WEBKIT_WEBGL_depth_texture");
          break;
        case "EXT_texture_filter_anisotropic":
          i = r.getExtension("EXT_texture_filter_anisotropic") || r.getExtension("MOZ_EXT_texture_filter_anisotropic") || r.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
          break;
        case "WEBGL_compressed_texture_s3tc":
          i = r.getExtension("WEBGL_compressed_texture_s3tc") || r.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || r.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
          break;
        case "WEBGL_compressed_texture_pvrtc":
          i = r.getExtension("WEBGL_compressed_texture_pvrtc") || r.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
          break;
        default:
          i = r.getExtension(n);
      }
      return t[n] = i, i;
    }
    return {
      has: function(n) {
        return e(n) !== null;
      },
      init: function() {
        e("EXT_color_buffer_float"), e("WEBGL_clip_cull_distance"), e("OES_texture_float_linear"), e("EXT_color_buffer_half_float"), e("WEBGL_multisampled_render_to_texture"), e("WEBGL_render_shared_exponent");
      },
      get: function(n) {
        const i = e(n);
        return i === null && Nc("THREE.WebGLRenderer: " + n + " extension not supported."), i;
      }
    };
  }
  function Qg(r, t, e, n) {
    const i = {}, s = /* @__PURE__ */ new WeakMap();
    function a(d) {
      const u = d.target;
      u.index !== null && t.remove(u.index);
      for (const w in u.attributes) t.remove(u.attributes[w]);
      for (const w in u.morphAttributes) {
        const b = u.morphAttributes[w];
        for (let m = 0, _ = b.length; m < _; m++) t.remove(b[m]);
      }
      u.removeEventListener("dispose", a), delete i[u.id];
      const p = s.get(u);
      p && (t.remove(p), s.delete(u)), n.releaseStatesOfGeometry(u), u.isInstancedBufferGeometry === true && delete u._maxInstanceCount, e.memory.geometries--;
    }
    function o(d, u) {
      return i[u.id] === true || (u.addEventListener("dispose", a), i[u.id] = true, e.memory.geometries++), u;
    }
    function c(d) {
      const u = d.attributes;
      for (const w in u) t.update(u[w], r.ARRAY_BUFFER);
      const p = d.morphAttributes;
      for (const w in p) {
        const b = p[w];
        for (let m = 0, _ = b.length; m < _; m++) t.update(b[m], r.ARRAY_BUFFER);
      }
    }
    function l(d) {
      const u = [], p = d.index, w = d.attributes.position;
      let b = 0;
      if (p !== null) {
        const E = p.array;
        b = p.version;
        for (let v = 0, T = E.length; v < T; v += 3) {
          const O = E[v + 0], R = E[v + 1], P = E[v + 2];
          u.push(O, R, R, P, P, O);
        }
      } else if (w !== void 0) {
        const E = w.array;
        b = w.version;
        for (let v = 0, T = E.length / 3 - 1; v < T; v += 3) {
          const O = v + 0, R = v + 1, P = v + 2;
          u.push(O, R, R, P, P, O);
        }
      } else return;
      const m = new (xu(u) ? Cu : Ru)(u, 1);
      m.version = b;
      const _ = s.get(d);
      _ && t.remove(_), s.set(d, m);
    }
    function h(d) {
      const u = s.get(d);
      if (u) {
        const p = d.index;
        p !== null && u.version < p.version && l(d);
      } else l(d);
      return s.get(d);
    }
    return {
      get: o,
      update: c,
      getWireframeAttribute: h
    };
  }
  function tw(r, t, e) {
    let n;
    function i(u) {
      n = u;
    }
    let s, a;
    function o(u) {
      s = u.type, a = u.bytesPerElement;
    }
    function c(u, p) {
      r.drawElements(n, p, s, u * a), e.update(p, n, 1);
    }
    function l(u, p, w) {
      w !== 0 && (r.drawElementsInstanced(n, p, s, u * a, w), e.update(p, n, w));
    }
    function h(u, p, w) {
      if (w === 0) return;
      const b = t.get("WEBGL_multi_draw");
      if (b === null) for (let m = 0; m < w; m++) this.render(u[m] / a, p[m]);
      else {
        b.multiDrawElementsWEBGL(n, p, 0, s, u, 0, w);
        let m = 0;
        for (let _ = 0; _ < w; _++) m += p[_];
        e.update(m, n, 1);
      }
    }
    function d(u, p, w, b) {
      if (w === 0) return;
      const m = t.get("WEBGL_multi_draw");
      if (m === null) for (let _ = 0; _ < u.length; _++) l(u[_] / a, p[_], b[_]);
      else {
        m.multiDrawElementsInstancedWEBGL(n, p, 0, s, u, 0, b, 0, w);
        let _ = 0;
        for (let E = 0; E < w; E++) _ += p[E];
        for (let E = 0; E < b.length; E++) e.update(_, n, b[E]);
      }
    }
    this.setMode = i, this.setIndex = o, this.render = c, this.renderInstances = l, this.renderMultiDraw = h, this.renderMultiDrawInstances = d;
  }
  function ew(r) {
    const t = {
      geometries: 0,
      textures: 0
    }, e = {
      frame: 0,
      calls: 0,
      triangles: 0,
      points: 0,
      lines: 0
    };
    function n(s, a, o) {
      switch (e.calls++, a) {
        case r.TRIANGLES:
          e.triangles += o * (s / 3);
          break;
        case r.LINES:
          e.lines += o * (s / 2);
          break;
        case r.LINE_STRIP:
          e.lines += o * (s - 1);
          break;
        case r.LINE_LOOP:
          e.lines += o * s;
          break;
        case r.POINTS:
          e.points += o * s;
          break;
        default:
          console.error("THREE.WebGLInfo: Unknown draw mode:", a);
          break;
      }
    }
    function i() {
      e.calls = 0, e.triangles = 0, e.points = 0, e.lines = 0;
    }
    return {
      memory: t,
      render: e,
      programs: null,
      autoReset: true,
      reset: i,
      update: n
    };
  }
  function nw(r, t, e) {
    const n = /* @__PURE__ */ new WeakMap(), i = new de();
    function s(a, o, c) {
      const l = a.morphTargetInfluences, h = o.morphAttributes.position || o.morphAttributes.normal || o.morphAttributes.color, d = h !== void 0 ? h.length : 0;
      let u = n.get(o);
      if (u === void 0 || u.count !== d) {
        let A = function() {
          P.dispose(), n.delete(o), o.removeEventListener("dispose", A);
        };
        u !== void 0 && u.texture.dispose();
        const p = o.morphAttributes.position !== void 0, w = o.morphAttributes.normal !== void 0, b = o.morphAttributes.color !== void 0, m = o.morphAttributes.position || [], _ = o.morphAttributes.normal || [], E = o.morphAttributes.color || [];
        let v = 0;
        p === true && (v = 1), w === true && (v = 2), b === true && (v = 3);
        let T = o.attributes.position.count * v, O = 1;
        T > t.maxTextureSize && (O = Math.ceil(T / t.maxTextureSize), T = t.maxTextureSize);
        const R = new Float32Array(T * O * 4 * d), P = new Mu(R, T, O, d);
        P.type = Dn, P.needsUpdate = true;
        const z = v * 4;
        for (let S = 0; S < d; S++) {
          const F = m[S], W = _[S], V = E[S], Z = T * O * 4 * S;
          for (let tt = 0; tt < F.count; tt++) {
            const Y = tt * z;
            p === true && (i.fromBufferAttribute(F, tt), R[Z + Y + 0] = i.x, R[Z + Y + 1] = i.y, R[Z + Y + 2] = i.z, R[Z + Y + 3] = 0), w === true && (i.fromBufferAttribute(W, tt), R[Z + Y + 4] = i.x, R[Z + Y + 5] = i.y, R[Z + Y + 6] = i.z, R[Z + Y + 7] = 0), b === true && (i.fromBufferAttribute(V, tt), R[Z + Y + 8] = i.x, R[Z + Y + 9] = i.y, R[Z + Y + 10] = i.z, R[Z + Y + 11] = V.itemSize === 4 ? i.w : 1);
          }
        }
        u = {
          count: d,
          texture: P,
          size: new vt(T, O)
        }, n.set(o, u), o.addEventListener("dispose", A);
      }
      if (a.isInstancedMesh === true && a.morphTexture !== null) c.getUniforms().setValue(r, "morphTexture", a.morphTexture, e);
      else {
        let p = 0;
        for (let b = 0; b < l.length; b++) p += l[b];
        const w = o.morphTargetsRelative ? 1 : 1 - p;
        c.getUniforms().setValue(r, "morphTargetBaseInfluence", w), c.getUniforms().setValue(r, "morphTargetInfluences", l);
      }
      c.getUniforms().setValue(r, "morphTargetsTexture", u.texture, e), c.getUniforms().setValue(r, "morphTargetsTextureSize", u.size);
    }
    return {
      update: s
    };
  }
  function iw(r, t, e, n) {
    let i = /* @__PURE__ */ new WeakMap();
    function s(c) {
      const l = n.render.frame, h = c.geometry, d = t.get(c, h);
      if (i.get(d) !== l && (t.update(d), i.set(d, l)), c.isInstancedMesh && (c.hasEventListener("dispose", o) === false && c.addEventListener("dispose", o), i.get(c) !== l && (e.update(c.instanceMatrix, r.ARRAY_BUFFER), c.instanceColor !== null && e.update(c.instanceColor, r.ARRAY_BUFFER), i.set(c, l))), c.isSkinnedMesh) {
        const u = c.skeleton;
        i.get(u) !== l && (u.update(), i.set(u, l));
      }
      return d;
    }
    function a() {
      i = /* @__PURE__ */ new WeakMap();
    }
    function o(c) {
      const l = c.target;
      l.removeEventListener("dispose", o), e.remove(l.instanceMatrix), l.instanceColor !== null && e.remove(l.instanceColor);
    }
    return {
      update: s,
      dispose: a
    };
  }
  class Uu extends Ne {
    constructor(t, e, n, i, s, a, o, c, l, h = wr) {
      if (h !== wr && h !== Er) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
      n === void 0 && h === wr && (n = Sr), n === void 0 && h === Er && (n = Mr), super(null, i, s, a, o, c, h, n, l), this.isDepthTexture = true, this.image = {
        width: t,
        height: e
      }, this.magFilter = o !== void 0 ? o : en, this.minFilter = c !== void 0 ? c : en, this.flipY = false, this.generateMipmaps = false, this.compareFunction = null;
    }
    copy(t) {
      return super.copy(t), this.compareFunction = t.compareFunction, this;
    }
    toJSON(t) {
      const e = super.toJSON(t);
      return this.compareFunction !== null && (e.compareFunction = this.compareFunction), e;
    }
  }
  const Fu = new Ne(), Ou = new Uu(1, 1);
  Ou.compareFunction = vu;
  const Bu = new Mu(), zu = new Wf(), ku = new Du(), Hh = [], Gh = [], Vh = new Float32Array(16), Wh = new Float32Array(9), jh = new Float32Array(4);
  function Nr(r, t, e) {
    const n = r[0];
    if (n <= 0 || n > 0) return r;
    const i = t * e;
    let s = Hh[i];
    if (s === void 0 && (s = new Float32Array(i), Hh[i] = s), t !== 0) {
      n.toArray(s, 0);
      for (let a = 1, o = 0; a !== t; ++a) o += e, r[a].toArray(s, o);
    }
    return s;
  }
  function Ue(r, t) {
    if (r.length !== t.length) return false;
    for (let e = 0, n = r.length; e < n; e++) if (r[e] !== t[e]) return false;
    return true;
  }
  function Fe(r, t) {
    for (let e = 0, n = t.length; e < n; e++) r[e] = t[e];
  }
  function ka(r, t) {
    let e = Gh[t];
    e === void 0 && (e = new Int32Array(t), Gh[t] = e);
    for (let n = 0; n !== t; ++n) e[n] = r.allocateTextureUnit();
    return e;
  }
  function rw(r, t) {
    const e = this.cache;
    e[0] !== t && (r.uniform1f(this.addr, t), e[0] = t);
  }
  function sw(r, t) {
    const e = this.cache;
    if (t.x !== void 0) (e[0] !== t.x || e[1] !== t.y) && (r.uniform2f(this.addr, t.x, t.y), e[0] = t.x, e[1] = t.y);
    else {
      if (Ue(e, t)) return;
      r.uniform2fv(this.addr, t), Fe(e, t);
    }
  }
  function aw(r, t) {
    const e = this.cache;
    if (t.x !== void 0) (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z) && (r.uniform3f(this.addr, t.x, t.y, t.z), e[0] = t.x, e[1] = t.y, e[2] = t.z);
    else if (t.r !== void 0) (e[0] !== t.r || e[1] !== t.g || e[2] !== t.b) && (r.uniform3f(this.addr, t.r, t.g, t.b), e[0] = t.r, e[1] = t.g, e[2] = t.b);
    else {
      if (Ue(e, t)) return;
      r.uniform3fv(this.addr, t), Fe(e, t);
    }
  }
  function ow(r, t) {
    const e = this.cache;
    if (t.x !== void 0) (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z || e[3] !== t.w) && (r.uniform4f(this.addr, t.x, t.y, t.z, t.w), e[0] = t.x, e[1] = t.y, e[2] = t.z, e[3] = t.w);
    else {
      if (Ue(e, t)) return;
      r.uniform4fv(this.addr, t), Fe(e, t);
    }
  }
  function cw(r, t) {
    const e = this.cache, n = t.elements;
    if (n === void 0) {
      if (Ue(e, t)) return;
      r.uniformMatrix2fv(this.addr, false, t), Fe(e, t);
    } else {
      if (Ue(e, n)) return;
      jh.set(n), r.uniformMatrix2fv(this.addr, false, jh), Fe(e, n);
    }
  }
  function lw(r, t) {
    const e = this.cache, n = t.elements;
    if (n === void 0) {
      if (Ue(e, t)) return;
      r.uniformMatrix3fv(this.addr, false, t), Fe(e, t);
    } else {
      if (Ue(e, n)) return;
      Wh.set(n), r.uniformMatrix3fv(this.addr, false, Wh), Fe(e, n);
    }
  }
  function hw(r, t) {
    const e = this.cache, n = t.elements;
    if (n === void 0) {
      if (Ue(e, t)) return;
      r.uniformMatrix4fv(this.addr, false, t), Fe(e, t);
    } else {
      if (Ue(e, n)) return;
      Vh.set(n), r.uniformMatrix4fv(this.addr, false, Vh), Fe(e, n);
    }
  }
  function dw(r, t) {
    const e = this.cache;
    e[0] !== t && (r.uniform1i(this.addr, t), e[0] = t);
  }
  function uw(r, t) {
    const e = this.cache;
    if (t.x !== void 0) (e[0] !== t.x || e[1] !== t.y) && (r.uniform2i(this.addr, t.x, t.y), e[0] = t.x, e[1] = t.y);
    else {
      if (Ue(e, t)) return;
      r.uniform2iv(this.addr, t), Fe(e, t);
    }
  }
  function pw(r, t) {
    const e = this.cache;
    if (t.x !== void 0) (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z) && (r.uniform3i(this.addr, t.x, t.y, t.z), e[0] = t.x, e[1] = t.y, e[2] = t.z);
    else {
      if (Ue(e, t)) return;
      r.uniform3iv(this.addr, t), Fe(e, t);
    }
  }
  function fw(r, t) {
    const e = this.cache;
    if (t.x !== void 0) (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z || e[3] !== t.w) && (r.uniform4i(this.addr, t.x, t.y, t.z, t.w), e[0] = t.x, e[1] = t.y, e[2] = t.z, e[3] = t.w);
    else {
      if (Ue(e, t)) return;
      r.uniform4iv(this.addr, t), Fe(e, t);
    }
  }
  function _w(r, t) {
    const e = this.cache;
    e[0] !== t && (r.uniform1ui(this.addr, t), e[0] = t);
  }
  function mw(r, t) {
    const e = this.cache;
    if (t.x !== void 0) (e[0] !== t.x || e[1] !== t.y) && (r.uniform2ui(this.addr, t.x, t.y), e[0] = t.x, e[1] = t.y);
    else {
      if (Ue(e, t)) return;
      r.uniform2uiv(this.addr, t), Fe(e, t);
    }
  }
  function gw(r, t) {
    const e = this.cache;
    if (t.x !== void 0) (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z) && (r.uniform3ui(this.addr, t.x, t.y, t.z), e[0] = t.x, e[1] = t.y, e[2] = t.z);
    else {
      if (Ue(e, t)) return;
      r.uniform3uiv(this.addr, t), Fe(e, t);
    }
  }
  function ww(r, t) {
    const e = this.cache;
    if (t.x !== void 0) (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z || e[3] !== t.w) && (r.uniform4ui(this.addr, t.x, t.y, t.z, t.w), e[0] = t.x, e[1] = t.y, e[2] = t.z, e[3] = t.w);
    else {
      if (Ue(e, t)) return;
      r.uniform4uiv(this.addr, t), Fe(e, t);
    }
  }
  function bw(r, t, e) {
    const n = this.cache, i = e.allocateTextureUnit();
    n[0] !== i && (r.uniform1i(this.addr, i), n[0] = i);
    const s = this.type === r.SAMPLER_2D_SHADOW ? Ou : Fu;
    e.setTexture2D(t || s, i);
  }
  function yw(r, t, e) {
    const n = this.cache, i = e.allocateTextureUnit();
    n[0] !== i && (r.uniform1i(this.addr, i), n[0] = i), e.setTexture3D(t || zu, i);
  }
  function vw(r, t, e) {
    const n = this.cache, i = e.allocateTextureUnit();
    n[0] !== i && (r.uniform1i(this.addr, i), n[0] = i), e.setTextureCube(t || ku, i);
  }
  function xw(r, t, e) {
    const n = this.cache, i = e.allocateTextureUnit();
    n[0] !== i && (r.uniform1i(this.addr, i), n[0] = i), e.setTexture2DArray(t || Bu, i);
  }
  function Sw(r) {
    switch (r) {
      case 5126:
        return rw;
      case 35664:
        return sw;
      case 35665:
        return aw;
      case 35666:
        return ow;
      case 35674:
        return cw;
      case 35675:
        return lw;
      case 35676:
        return hw;
      case 5124:
      case 35670:
        return dw;
      case 35667:
      case 35671:
        return uw;
      case 35668:
      case 35672:
        return pw;
      case 35669:
      case 35673:
        return fw;
      case 5125:
        return _w;
      case 36294:
        return mw;
      case 36295:
        return gw;
      case 36296:
        return ww;
      case 35678:
      case 36198:
      case 36298:
      case 36306:
      case 35682:
        return bw;
      case 35679:
      case 36299:
      case 36307:
        return yw;
      case 35680:
      case 36300:
      case 36308:
      case 36293:
        return vw;
      case 36289:
      case 36303:
      case 36311:
      case 36292:
        return xw;
    }
  }
  function Mw(r, t) {
    r.uniform1fv(this.addr, t);
  }
  function Ew(r, t) {
    const e = Nr(t, this.size, 2);
    r.uniform2fv(this.addr, e);
  }
  function Tw(r, t) {
    const e = Nr(t, this.size, 3);
    r.uniform3fv(this.addr, e);
  }
  function Aw(r, t) {
    const e = Nr(t, this.size, 4);
    r.uniform4fv(this.addr, e);
  }
  function Rw(r, t) {
    const e = Nr(t, this.size, 4);
    r.uniformMatrix2fv(this.addr, false, e);
  }
  function Cw(r, t) {
    const e = Nr(t, this.size, 9);
    r.uniformMatrix3fv(this.addr, false, e);
  }
  function Pw(r, t) {
    const e = Nr(t, this.size, 16);
    r.uniformMatrix4fv(this.addr, false, e);
  }
  function Iw(r, t) {
    r.uniform1iv(this.addr, t);
  }
  function Lw(r, t) {
    r.uniform2iv(this.addr, t);
  }
  function Dw(r, t) {
    r.uniform3iv(this.addr, t);
  }
  function Nw(r, t) {
    r.uniform4iv(this.addr, t);
  }
  function Uw(r, t) {
    r.uniform1uiv(this.addr, t);
  }
  function Fw(r, t) {
    r.uniform2uiv(this.addr, t);
  }
  function Ow(r, t) {
    r.uniform3uiv(this.addr, t);
  }
  function Bw(r, t) {
    r.uniform4uiv(this.addr, t);
  }
  function zw(r, t, e) {
    const n = this.cache, i = t.length, s = ka(e, i);
    Ue(n, s) || (r.uniform1iv(this.addr, s), Fe(n, s));
    for (let a = 0; a !== i; ++a) e.setTexture2D(t[a] || Fu, s[a]);
  }
  function kw(r, t, e) {
    const n = this.cache, i = t.length, s = ka(e, i);
    Ue(n, s) || (r.uniform1iv(this.addr, s), Fe(n, s));
    for (let a = 0; a !== i; ++a) e.setTexture3D(t[a] || zu, s[a]);
  }
  function Hw(r, t, e) {
    const n = this.cache, i = t.length, s = ka(e, i);
    Ue(n, s) || (r.uniform1iv(this.addr, s), Fe(n, s));
    for (let a = 0; a !== i; ++a) e.setTextureCube(t[a] || ku, s[a]);
  }
  function Gw(r, t, e) {
    const n = this.cache, i = t.length, s = ka(e, i);
    Ue(n, s) || (r.uniform1iv(this.addr, s), Fe(n, s));
    for (let a = 0; a !== i; ++a) e.setTexture2DArray(t[a] || Bu, s[a]);
  }
  function Vw(r) {
    switch (r) {
      case 5126:
        return Mw;
      case 35664:
        return Ew;
      case 35665:
        return Tw;
      case 35666:
        return Aw;
      case 35674:
        return Rw;
      case 35675:
        return Cw;
      case 35676:
        return Pw;
      case 5124:
      case 35670:
        return Iw;
      case 35667:
      case 35671:
        return Lw;
      case 35668:
      case 35672:
        return Dw;
      case 35669:
      case 35673:
        return Nw;
      case 5125:
        return Uw;
      case 36294:
        return Fw;
      case 36295:
        return Ow;
      case 36296:
        return Bw;
      case 35678:
      case 36198:
      case 36298:
      case 36306:
      case 35682:
        return zw;
      case 35679:
      case 36299:
      case 36307:
        return kw;
      case 35680:
      case 36300:
      case 36308:
      case 36293:
        return Hw;
      case 36289:
      case 36303:
      case 36311:
      case 36292:
        return Gw;
    }
  }
  class Ww {
    constructor(t, e, n) {
      this.id = t, this.addr = n, this.cache = [], this.type = e.type, this.setValue = Sw(e.type);
    }
  }
  class jw {
    constructor(t, e, n) {
      this.id = t, this.addr = n, this.cache = [], this.type = e.type, this.size = e.size, this.setValue = Vw(e.type);
    }
  }
  class Xw {
    constructor(t) {
      this.id = t, this.seq = [], this.map = {};
    }
    setValue(t, e, n) {
      const i = this.seq;
      for (let s = 0, a = i.length; s !== a; ++s) {
        const o = i[s];
        o.setValue(t, e[o.id], n);
      }
    }
  }
  const Yo = /(\w+)(\])?(\[|\.)?/g;
  function Xh(r, t) {
    r.seq.push(t), r.map[t.id] = t;
  }
  function qw(r, t, e) {
    const n = r.name, i = n.length;
    for (Yo.lastIndex = 0; ; ) {
      const s = Yo.exec(n), a = Yo.lastIndex;
      let o = s[1];
      const c = s[2] === "]", l = s[3];
      if (c && (o = o | 0), l === void 0 || l === "[" && a + 2 === i) {
        Xh(e, l === void 0 ? new Ww(o, r, t) : new jw(o, r, t));
        break;
      } else {
        let d = e.map[o];
        d === void 0 && (d = new Xw(o), Xh(e, d)), e = d;
      }
    }
  }
  class ua {
    constructor(t, e) {
      this.seq = [], this.map = {};
      const n = t.getProgramParameter(e, t.ACTIVE_UNIFORMS);
      for (let i = 0; i < n; ++i) {
        const s = t.getActiveUniform(e, i), a = t.getUniformLocation(e, s.name);
        qw(s, a, this);
      }
    }
    setValue(t, e, n, i) {
      const s = this.map[e];
      s !== void 0 && s.setValue(t, n, i);
    }
    setOptional(t, e, n) {
      const i = e[n];
      i !== void 0 && this.setValue(t, n, i);
    }
    static upload(t, e, n, i) {
      for (let s = 0, a = e.length; s !== a; ++s) {
        const o = e[s], c = n[o.id];
        c.needsUpdate !== false && o.setValue(t, c.value, i);
      }
    }
    static seqWithValue(t, e) {
      const n = [];
      for (let i = 0, s = t.length; i !== s; ++i) {
        const a = t[i];
        a.id in e && n.push(a);
      }
      return n;
    }
  }
  function qh(r, t, e) {
    const n = r.createShader(t);
    return r.shaderSource(n, e), r.compileShader(n), n;
  }
  const Kw = 37297;
  let Yw = 0;
  function Zw(r, t) {
    const e = r.split(`
`), n = [], i = Math.max(t - 6, 0), s = Math.min(t + 6, e.length);
    for (let a = i; a < s; a++) {
      const o = a + 1;
      n.push(`${o === t ? ">" : " "} ${o}: ${e[a]}`);
    }
    return n.join(`
`);
  }
  function $w(r) {
    const t = ie.getPrimaries(ie.workingColorSpace), e = ie.getPrimaries(r);
    let n;
    switch (t === e ? n = "" : t === wa && e === ga ? n = "LinearDisplayP3ToLinearSRGB" : t === ga && e === wa && (n = "LinearSRGBToLinearDisplayP3"), r) {
      case je:
      case za:
        return [
          n,
          "LinearTransferOETF"
        ];
      case Ke:
      case Lc:
        return [
          n,
          "sRGBTransferOETF"
        ];
      default:
        return console.warn("THREE.WebGLProgram: Unsupported color space:", r), [
          n,
          "LinearTransferOETF"
        ];
    }
  }
  function Kh(r, t, e) {
    const n = r.getShaderParameter(t, r.COMPILE_STATUS), i = r.getShaderInfoLog(t).trim();
    if (n && i === "") return "";
    const s = /ERROR: 0:(\d+)/.exec(i);
    if (s) {
      const a = parseInt(s[1]);
      return e.toUpperCase() + `

` + i + `

` + Zw(r.getShaderSource(t), a);
    } else return i;
  }
  function Jw(r, t) {
    const e = $w(t);
    return `vec4 ${r}( vec4 value ) { return ${e[0]}( ${e[1]}( value ) ); }`;
  }
  function Qw(r, t) {
    let e;
    switch (t) {
      case Xp:
        e = "Linear";
        break;
      case qp:
        e = "Reinhard";
        break;
      case Kp:
        e = "OptimizedCineon";
        break;
      case lu:
        e = "ACESFilmic";
        break;
      case Zp:
        e = "AgX";
        break;
      case $p:
        e = "Neutral";
        break;
      case Yp:
        e = "Custom";
        break;
      default:
        console.warn("THREE.WebGLProgram: Unsupported toneMapping:", t), e = "Linear";
    }
    return "vec3 " + r + "( vec3 color ) { return " + e + "ToneMapping( color ); }";
  }
  function t0(r) {
    return [
      r.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "",
      r.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""
    ].filter(ns).join(`
`);
  }
  function e0(r) {
    const t = [];
    for (const e in r) {
      const n = r[e];
      n !== false && t.push("#define " + e + " " + n);
    }
    return t.join(`
`);
  }
  function n0(r, t) {
    const e = {}, n = r.getProgramParameter(t, r.ACTIVE_ATTRIBUTES);
    for (let i = 0; i < n; i++) {
      const s = r.getActiveAttrib(t, i), a = s.name;
      let o = 1;
      s.type === r.FLOAT_MAT2 && (o = 2), s.type === r.FLOAT_MAT3 && (o = 3), s.type === r.FLOAT_MAT4 && (o = 4), e[a] = {
        type: s.type,
        location: r.getAttribLocation(t, a),
        locationSize: o
      };
    }
    return e;
  }
  function ns(r) {
    return r !== "";
  }
  function Yh(r, t) {
    const e = t.numSpotLightShadows + t.numSpotLightMaps - t.numSpotLightShadowsWithMaps;
    return r.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, t.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, e).replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, t.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows);
  }
  function Zh(r, t) {
    return r.replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection);
  }
  const i0 = /^[ \t]*#include +<([\w\d./]+)>/gm;
  function Mc(r) {
    return r.replace(i0, s0);
  }
  const r0 = /* @__PURE__ */ new Map();
  function s0(r, t) {
    let e = Gt[t];
    if (e === void 0) {
      const n = r0.get(t);
      if (n !== void 0) e = Gt[n], console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', t, n);
      else throw new Error("Can not resolve #include <" + t + ">");
    }
    return Mc(e);
  }
  const a0 = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
  function $h(r) {
    return r.replace(a0, o0);
  }
  function o0(r, t, e, n) {
    let i = "";
    for (let s = parseInt(t); s < parseInt(e); s++) i += n.replace(/\[\s*i\s*\]/g, "[ " + s + " ]").replace(/UNROLLED_LOOP_INDEX/g, s);
    return i;
  }
  function Jh(r) {
    let t = `precision ${r.precision} float;
	precision ${r.precision} int;
	precision ${r.precision} sampler2D;
	precision ${r.precision} samplerCube;
	precision ${r.precision} sampler3D;
	precision ${r.precision} sampler2DArray;
	precision ${r.precision} sampler2DShadow;
	precision ${r.precision} samplerCubeShadow;
	precision ${r.precision} sampler2DArrayShadow;
	precision ${r.precision} isampler2D;
	precision ${r.precision} isampler3D;
	precision ${r.precision} isamplerCube;
	precision ${r.precision} isampler2DArray;
	precision ${r.precision} usampler2D;
	precision ${r.precision} usampler3D;
	precision ${r.precision} usamplerCube;
	precision ${r.precision} usampler2DArray;
	`;
    return r.precision === "highp" ? t += `
#define HIGH_PRECISION` : r.precision === "mediump" ? t += `
#define MEDIUM_PRECISION` : r.precision === "lowp" && (t += `
#define LOW_PRECISION`), t;
  }
  function c0(r) {
    let t = "SHADOWMAP_TYPE_BASIC";
    return r.shadowMapType === au ? t = "SHADOWMAP_TYPE_PCF" : r.shadowMapType === ou ? t = "SHADOWMAP_TYPE_PCF_SOFT" : r.shadowMapType === Kn && (t = "SHADOWMAP_TYPE_VSM"), t;
  }
  function l0(r) {
    let t = "ENVMAP_TYPE_CUBE";
    if (r.envMap) switch (r.envMapMode) {
      case vr:
      case xr:
        t = "ENVMAP_TYPE_CUBE";
        break;
      case Oa:
        t = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
    return t;
  }
  function h0(r) {
    let t = "ENVMAP_MODE_REFLECTION";
    if (r.envMap) switch (r.envMapMode) {
      case xr:
        t = "ENVMAP_MODE_REFRACTION";
        break;
    }
    return t;
  }
  function d0(r) {
    let t = "ENVMAP_BLENDING_NONE";
    if (r.envMap) switch (r.combine) {
      case cu:
        t = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case Wp:
        t = "ENVMAP_BLENDING_MIX";
        break;
      case jp:
        t = "ENVMAP_BLENDING_ADD";
        break;
    }
    return t;
  }
  function u0(r) {
    const t = r.envMapCubeUVHeight;
    if (t === null) return null;
    const e = Math.log2(t) - 2, n = 1 / t;
    return {
      texelWidth: 1 / (3 * Math.max(Math.pow(2, e), 112)),
      texelHeight: n,
      maxMip: e
    };
  }
  function p0(r, t, e, n) {
    const i = r.getContext(), s = e.defines;
    let a = e.vertexShader, o = e.fragmentShader;
    const c = c0(e), l = l0(e), h = h0(e), d = d0(e), u = u0(e), p = t0(e), w = e0(s), b = i.createProgram();
    let m, _, E = e.glslVersion ? "#version " + e.glslVersion + `
` : "";
    e.isRawShaderMaterial ? (m = [
      "#define SHADER_TYPE " + e.shaderType,
      "#define SHADER_NAME " + e.shaderName,
      w
    ].filter(ns).join(`
`), m.length > 0 && (m += `
`), _ = [
      "#define SHADER_TYPE " + e.shaderType,
      "#define SHADER_NAME " + e.shaderName,
      w
    ].filter(ns).join(`
`), _.length > 0 && (_ += `
`)) : (m = [
      Jh(e),
      "#define SHADER_TYPE " + e.shaderType,
      "#define SHADER_NAME " + e.shaderName,
      w,
      e.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "",
      e.batching ? "#define USE_BATCHING" : "",
      e.batchingColor ? "#define USE_BATCHING_COLOR" : "",
      e.instancing ? "#define USE_INSTANCING" : "",
      e.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
      e.instancingMorph ? "#define USE_INSTANCING_MORPH" : "",
      e.useFog && e.fog ? "#define USE_FOG" : "",
      e.useFog && e.fogExp2 ? "#define FOG_EXP2" : "",
      e.map ? "#define USE_MAP" : "",
      e.envMap ? "#define USE_ENVMAP" : "",
      e.envMap ? "#define " + h : "",
      e.lightMap ? "#define USE_LIGHTMAP" : "",
      e.aoMap ? "#define USE_AOMAP" : "",
      e.bumpMap ? "#define USE_BUMPMAP" : "",
      e.normalMap ? "#define USE_NORMALMAP" : "",
      e.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
      e.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
      e.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
      e.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
      e.anisotropy ? "#define USE_ANISOTROPY" : "",
      e.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
      e.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
      e.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
      e.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
      e.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
      e.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
      e.specularMap ? "#define USE_SPECULARMAP" : "",
      e.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
      e.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
      e.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
      e.metalnessMap ? "#define USE_METALNESSMAP" : "",
      e.alphaMap ? "#define USE_ALPHAMAP" : "",
      e.alphaHash ? "#define USE_ALPHAHASH" : "",
      e.transmission ? "#define USE_TRANSMISSION" : "",
      e.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
      e.thicknessMap ? "#define USE_THICKNESSMAP" : "",
      e.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
      e.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
      e.mapUv ? "#define MAP_UV " + e.mapUv : "",
      e.alphaMapUv ? "#define ALPHAMAP_UV " + e.alphaMapUv : "",
      e.lightMapUv ? "#define LIGHTMAP_UV " + e.lightMapUv : "",
      e.aoMapUv ? "#define AOMAP_UV " + e.aoMapUv : "",
      e.emissiveMapUv ? "#define EMISSIVEMAP_UV " + e.emissiveMapUv : "",
      e.bumpMapUv ? "#define BUMPMAP_UV " + e.bumpMapUv : "",
      e.normalMapUv ? "#define NORMALMAP_UV " + e.normalMapUv : "",
      e.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + e.displacementMapUv : "",
      e.metalnessMapUv ? "#define METALNESSMAP_UV " + e.metalnessMapUv : "",
      e.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + e.roughnessMapUv : "",
      e.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + e.anisotropyMapUv : "",
      e.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + e.clearcoatMapUv : "",
      e.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + e.clearcoatNormalMapUv : "",
      e.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + e.clearcoatRoughnessMapUv : "",
      e.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + e.iridescenceMapUv : "",
      e.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + e.iridescenceThicknessMapUv : "",
      e.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + e.sheenColorMapUv : "",
      e.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + e.sheenRoughnessMapUv : "",
      e.specularMapUv ? "#define SPECULARMAP_UV " + e.specularMapUv : "",
      e.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + e.specularColorMapUv : "",
      e.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + e.specularIntensityMapUv : "",
      e.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + e.transmissionMapUv : "",
      e.thicknessMapUv ? "#define THICKNESSMAP_UV " + e.thicknessMapUv : "",
      e.vertexTangents && e.flatShading === false ? "#define USE_TANGENT" : "",
      e.vertexColors ? "#define USE_COLOR" : "",
      e.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
      e.vertexUv1s ? "#define USE_UV1" : "",
      e.vertexUv2s ? "#define USE_UV2" : "",
      e.vertexUv3s ? "#define USE_UV3" : "",
      e.pointsUvs ? "#define USE_POINTS_UV" : "",
      e.flatShading ? "#define FLAT_SHADED" : "",
      e.skinning ? "#define USE_SKINNING" : "",
      e.morphTargets ? "#define USE_MORPHTARGETS" : "",
      e.morphNormals && e.flatShading === false ? "#define USE_MORPHNORMALS" : "",
      e.morphColors ? "#define USE_MORPHCOLORS" : "",
      e.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + e.morphTextureStride : "",
      e.morphTargetsCount > 0 ? "#define MORPHTARGETS_COUNT " + e.morphTargetsCount : "",
      e.doubleSided ? "#define DOUBLE_SIDED" : "",
      e.flipSided ? "#define FLIP_SIDED" : "",
      e.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
      e.shadowMapEnabled ? "#define " + c : "",
      e.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
      e.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
      e.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
      "uniform mat4 modelMatrix;",
      "uniform mat4 modelViewMatrix;",
      "uniform mat4 projectionMatrix;",
      "uniform mat4 viewMatrix;",
      "uniform mat3 normalMatrix;",
      "uniform vec3 cameraPosition;",
      "uniform bool isOrthographic;",
      "#ifdef USE_INSTANCING",
      "	attribute mat4 instanceMatrix;",
      "#endif",
      "#ifdef USE_INSTANCING_COLOR",
      "	attribute vec3 instanceColor;",
      "#endif",
      "#ifdef USE_INSTANCING_MORPH",
      "	uniform sampler2D morphTexture;",
      "#endif",
      "attribute vec3 position;",
      "attribute vec3 normal;",
      "attribute vec2 uv;",
      "#ifdef USE_UV1",
      "	attribute vec2 uv1;",
      "#endif",
      "#ifdef USE_UV2",
      "	attribute vec2 uv2;",
      "#endif",
      "#ifdef USE_UV3",
      "	attribute vec2 uv3;",
      "#endif",
      "#ifdef USE_TANGENT",
      "	attribute vec4 tangent;",
      "#endif",
      "#if defined( USE_COLOR_ALPHA )",
      "	attribute vec4 color;",
      "#elif defined( USE_COLOR )",
      "	attribute vec3 color;",
      "#endif",
      "#ifdef USE_SKINNING",
      "	attribute vec4 skinIndex;",
      "	attribute vec4 skinWeight;",
      "#endif",
      `
`
    ].filter(ns).join(`
`), _ = [
      Jh(e),
      "#define SHADER_TYPE " + e.shaderType,
      "#define SHADER_NAME " + e.shaderName,
      w,
      e.useFog && e.fog ? "#define USE_FOG" : "",
      e.useFog && e.fogExp2 ? "#define FOG_EXP2" : "",
      e.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "",
      e.map ? "#define USE_MAP" : "",
      e.matcap ? "#define USE_MATCAP" : "",
      e.envMap ? "#define USE_ENVMAP" : "",
      e.envMap ? "#define " + l : "",
      e.envMap ? "#define " + h : "",
      e.envMap ? "#define " + d : "",
      u ? "#define CUBEUV_TEXEL_WIDTH " + u.texelWidth : "",
      u ? "#define CUBEUV_TEXEL_HEIGHT " + u.texelHeight : "",
      u ? "#define CUBEUV_MAX_MIP " + u.maxMip + ".0" : "",
      e.lightMap ? "#define USE_LIGHTMAP" : "",
      e.aoMap ? "#define USE_AOMAP" : "",
      e.bumpMap ? "#define USE_BUMPMAP" : "",
      e.normalMap ? "#define USE_NORMALMAP" : "",
      e.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
      e.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
      e.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
      e.anisotropy ? "#define USE_ANISOTROPY" : "",
      e.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
      e.clearcoat ? "#define USE_CLEARCOAT" : "",
      e.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
      e.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
      e.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
      e.dispersion ? "#define USE_DISPERSION" : "",
      e.iridescence ? "#define USE_IRIDESCENCE" : "",
      e.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
      e.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
      e.specularMap ? "#define USE_SPECULARMAP" : "",
      e.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
      e.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
      e.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
      e.metalnessMap ? "#define USE_METALNESSMAP" : "",
      e.alphaMap ? "#define USE_ALPHAMAP" : "",
      e.alphaTest ? "#define USE_ALPHATEST" : "",
      e.alphaHash ? "#define USE_ALPHAHASH" : "",
      e.sheen ? "#define USE_SHEEN" : "",
      e.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
      e.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
      e.transmission ? "#define USE_TRANSMISSION" : "",
      e.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
      e.thicknessMap ? "#define USE_THICKNESSMAP" : "",
      e.vertexTangents && e.flatShading === false ? "#define USE_TANGENT" : "",
      e.vertexColors || e.instancingColor || e.batchingColor ? "#define USE_COLOR" : "",
      e.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
      e.vertexUv1s ? "#define USE_UV1" : "",
      e.vertexUv2s ? "#define USE_UV2" : "",
      e.vertexUv3s ? "#define USE_UV3" : "",
      e.pointsUvs ? "#define USE_POINTS_UV" : "",
      e.gradientMap ? "#define USE_GRADIENTMAP" : "",
      e.flatShading ? "#define FLAT_SHADED" : "",
      e.doubleSided ? "#define DOUBLE_SIDED" : "",
      e.flipSided ? "#define FLIP_SIDED" : "",
      e.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
      e.shadowMapEnabled ? "#define " + c : "",
      e.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
      e.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
      e.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
      e.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
      "uniform mat4 viewMatrix;",
      "uniform vec3 cameraPosition;",
      "uniform bool isOrthographic;",
      e.toneMapping !== xi ? "#define TONE_MAPPING" : "",
      e.toneMapping !== xi ? Gt.tonemapping_pars_fragment : "",
      e.toneMapping !== xi ? Qw("toneMapping", e.toneMapping) : "",
      e.dithering ? "#define DITHERING" : "",
      e.opaque ? "#define OPAQUE" : "",
      Gt.colorspace_pars_fragment,
      Jw("linearToOutputTexel", e.outputColorSpace),
      e.useDepthPacking ? "#define DEPTH_PACKING " + e.depthPacking : "",
      `
`
    ].filter(ns).join(`
`)), a = Mc(a), a = Yh(a, e), a = Zh(a, e), o = Mc(o), o = Yh(o, e), o = Zh(o, e), a = $h(a), o = $h(o), e.isRawShaderMaterial !== true && (E = `#version 300 es
`, m = [
      p,
      "#define attribute in",
      "#define varying out",
      "#define texture2D texture"
    ].join(`
`) + `
` + m, _ = [
      "#define varying in",
      e.glslVersion === ph ? "" : "layout(location = 0) out highp vec4 pc_fragColor;",
      e.glslVersion === ph ? "" : "#define gl_FragColor pc_fragColor",
      "#define gl_FragDepthEXT gl_FragDepth",
      "#define texture2D texture",
      "#define textureCube texture",
      "#define texture2DProj textureProj",
      "#define texture2DLodEXT textureLod",
      "#define texture2DProjLodEXT textureProjLod",
      "#define textureCubeLodEXT textureLod",
      "#define texture2DGradEXT textureGrad",
      "#define texture2DProjGradEXT textureProjGrad",
      "#define textureCubeGradEXT textureGrad"
    ].join(`
`) + `
` + _);
    const v = E + m + a, T = E + _ + o, O = qh(i, i.VERTEX_SHADER, v), R = qh(i, i.FRAGMENT_SHADER, T);
    i.attachShader(b, O), i.attachShader(b, R), e.index0AttributeName !== void 0 ? i.bindAttribLocation(b, 0, e.index0AttributeName) : e.morphTargets === true && i.bindAttribLocation(b, 0, "position"), i.linkProgram(b);
    function P(F) {
      if (r.debug.checkShaderErrors) {
        const W = i.getProgramInfoLog(b).trim(), V = i.getShaderInfoLog(O).trim(), Z = i.getShaderInfoLog(R).trim();
        let tt = true, Y = true;
        if (i.getProgramParameter(b, i.LINK_STATUS) === false) if (tt = false, typeof r.debug.onShaderError == "function") r.debug.onShaderError(i, b, O, R);
        else {
          const J = Kh(i, O, "vertex"), $ = Kh(i, R, "fragment");
          console.error("THREE.WebGLProgram: Shader Error " + i.getError() + " - VALIDATE_STATUS " + i.getProgramParameter(b, i.VALIDATE_STATUS) + `

Material Name: ` + F.name + `
Material Type: ` + F.type + `

Program Info Log: ` + W + `
` + J + `
` + $);
        }
        else W !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", W) : (V === "" || Z === "") && (Y = false);
        Y && (F.diagnostics = {
          runnable: tt,
          programLog: W,
          vertexShader: {
            log: V,
            prefix: m
          },
          fragmentShader: {
            log: Z,
            prefix: _
          }
        });
      }
      i.deleteShader(O), i.deleteShader(R), z = new ua(i, b), A = n0(i, b);
    }
    let z;
    this.getUniforms = function() {
      return z === void 0 && P(this), z;
    };
    let A;
    this.getAttributes = function() {
      return A === void 0 && P(this), A;
    };
    let S = e.rendererExtensionParallelShaderCompile === false;
    return this.isReady = function() {
      return S === false && (S = i.getProgramParameter(b, Kw)), S;
    }, this.destroy = function() {
      n.releaseStatesOfProgram(this), i.deleteProgram(b), this.program = void 0;
    }, this.type = e.shaderType, this.name = e.shaderName, this.id = Yw++, this.cacheKey = t, this.usedTimes = 1, this.program = b, this.vertexShader = O, this.fragmentShader = R, this;
  }
  let f0 = 0;
  class _0 {
    constructor() {
      this.shaderCache = /* @__PURE__ */ new Map(), this.materialCache = /* @__PURE__ */ new Map();
    }
    update(t) {
      const e = t.vertexShader, n = t.fragmentShader, i = this._getShaderStage(e), s = this._getShaderStage(n), a = this._getShaderCacheForMaterial(t);
      return a.has(i) === false && (a.add(i), i.usedTimes++), a.has(s) === false && (a.add(s), s.usedTimes++), this;
    }
    remove(t) {
      const e = this.materialCache.get(t);
      for (const n of e) n.usedTimes--, n.usedTimes === 0 && this.shaderCache.delete(n.code);
      return this.materialCache.delete(t), this;
    }
    getVertexShaderID(t) {
      return this._getShaderStage(t.vertexShader).id;
    }
    getFragmentShaderID(t) {
      return this._getShaderStage(t.fragmentShader).id;
    }
    dispose() {
      this.shaderCache.clear(), this.materialCache.clear();
    }
    _getShaderCacheForMaterial(t) {
      const e = this.materialCache;
      let n = e.get(t);
      return n === void 0 && (n = /* @__PURE__ */ new Set(), e.set(t, n)), n;
    }
    _getShaderStage(t) {
      const e = this.shaderCache;
      let n = e.get(t);
      return n === void 0 && (n = new m0(t), e.set(t, n)), n;
    }
  }
  class m0 {
    constructor(t) {
      this.id = f0++, this.code = t, this.usedTimes = 0;
    }
  }
  function g0(r, t, e, n, i, s, a) {
    const o = new Tu(), c = new _0(), l = /* @__PURE__ */ new Set(), h = [], d = i.logarithmicDepthBuffer, u = i.vertexTextures;
    let p = i.precision;
    const w = {
      MeshDepthMaterial: "depth",
      MeshDistanceMaterial: "distanceRGBA",
      MeshNormalMaterial: "normal",
      MeshBasicMaterial: "basic",
      MeshLambertMaterial: "lambert",
      MeshPhongMaterial: "phong",
      MeshToonMaterial: "toon",
      MeshStandardMaterial: "physical",
      MeshPhysicalMaterial: "physical",
      MeshMatcapMaterial: "matcap",
      LineBasicMaterial: "basic",
      LineDashedMaterial: "dashed",
      PointsMaterial: "points",
      ShadowMaterial: "shadow",
      SpriteMaterial: "sprite"
    };
    function b(A) {
      return l.add(A), A === 0 ? "uv" : `uv${A}`;
    }
    function m(A, S, F, W, V) {
      const Z = W.fog, tt = V.geometry, Y = A.isMeshStandardMaterial ? W.environment : null, J = (A.isMeshStandardMaterial ? e : t).get(A.envMap || Y), $ = J && J.mapping === Oa ? J.image.height : null, ut = w[A.type];
      A.precision !== null && (p = i.getMaxPrecision(A.precision), p !== A.precision && console.warn("THREE.WebGLProgram.getParameters:", A.precision, "not supported, using", p, "instead."));
      const mt = tt.morphAttributes.position || tt.morphAttributes.normal || tt.morphAttributes.color, gt = mt !== void 0 ? mt.length : 0;
      let qt = 0;
      tt.morphAttributes.position !== void 0 && (qt = 1), tt.morphAttributes.normal !== void 0 && (qt = 2), tt.morphAttributes.color !== void 0 && (qt = 3);
      let ee, Q, st, _t;
      if (ut) {
        const ne = Ln[ut];
        ee = ne.vertexShader, Q = ne.fragmentShader;
      } else ee = A.vertexShader, Q = A.fragmentShader, c.update(A), st = c.getVertexShaderID(A), _t = c.getFragmentShaderID(A);
      const lt = r.getRenderTarget(), kt = V.isInstancedMesh === true, Dt = V.isBatchedMesh === true, Kt = !!A.map, D = !!A.matcap, Yt = !!J, jt = !!A.aoMap, ue = !!A.lightMap, At = !!A.bumpMap, Qt = !!A.normalMap, Xt = !!A.displacementMap, Ft = !!A.emissiveMap, ye = !!A.metalnessMap, I = !!A.roughnessMap, x = A.anisotropy > 0, X = A.clearcoat > 0, et = A.dispersion > 0, it = A.iridescence > 0, rt = A.sheen > 0, St = A.transmission > 0, ht = x && !!A.anisotropyMap, ct = X && !!A.clearcoatMap, Ot = X && !!A.clearcoatNormalMap, at = X && !!A.clearcoatRoughnessMap, bt = it && !!A.iridescenceMap, Zt = it && !!A.iridescenceThicknessMap, Pt = rt && !!A.sheenColorMap, pt = rt && !!A.sheenRoughnessMap, Bt = !!A.specularMap, zt = !!A.specularColorMap, xe = !!A.specularIntensityMap, y = St && !!A.transmissionMap, q = St && !!A.thicknessMap, H = !!A.gradientMap, K = !!A.alphaMap, nt = A.alphaTest > 0, Mt = !!A.alphaHash, Nt = !!A.extensions;
      let Se = xi;
      A.toneMapped && (lt === null || lt.isXRRenderTarget === true) && (Se = r.toneMapping);
      const Re = {
        shaderID: ut,
        shaderType: A.type,
        shaderName: A.name,
        vertexShader: ee,
        fragmentShader: Q,
        defines: A.defines,
        customVertexShaderID: st,
        customFragmentShaderID: _t,
        isRawShaderMaterial: A.isRawShaderMaterial === true,
        glslVersion: A.glslVersion,
        precision: p,
        batching: Dt,
        batchingColor: Dt && V._colorsTexture !== null,
        instancing: kt,
        instancingColor: kt && V.instanceColor !== null,
        instancingMorph: kt && V.morphTexture !== null,
        supportsVertexTextures: u,
        outputColorSpace: lt === null ? r.outputColorSpace : lt.isXRRenderTarget === true ? lt.texture.colorSpace : je,
        alphaToCoverage: !!A.alphaToCoverage,
        map: Kt,
        matcap: D,
        envMap: Yt,
        envMapMode: Yt && J.mapping,
        envMapCubeUVHeight: $,
        aoMap: jt,
        lightMap: ue,
        bumpMap: At,
        normalMap: Qt,
        displacementMap: u && Xt,
        emissiveMap: Ft,
        normalMapObjectSpace: Qt && A.normalMapType === pf,
        normalMapTangentSpace: Qt && A.normalMapType === yu,
        metalnessMap: ye,
        roughnessMap: I,
        anisotropy: x,
        anisotropyMap: ht,
        clearcoat: X,
        clearcoatMap: ct,
        clearcoatNormalMap: Ot,
        clearcoatRoughnessMap: at,
        dispersion: et,
        iridescence: it,
        iridescenceMap: bt,
        iridescenceThicknessMap: Zt,
        sheen: rt,
        sheenColorMap: Pt,
        sheenRoughnessMap: pt,
        specularMap: Bt,
        specularColorMap: zt,
        specularIntensityMap: xe,
        transmission: St,
        transmissionMap: y,
        thicknessMap: q,
        gradientMap: H,
        opaque: A.transparent === false && A.blending === gr && A.alphaToCoverage === false,
        alphaMap: K,
        alphaTest: nt,
        alphaHash: Mt,
        combine: A.combine,
        mapUv: Kt && b(A.map.channel),
        aoMapUv: jt && b(A.aoMap.channel),
        lightMapUv: ue && b(A.lightMap.channel),
        bumpMapUv: At && b(A.bumpMap.channel),
        normalMapUv: Qt && b(A.normalMap.channel),
        displacementMapUv: Xt && b(A.displacementMap.channel),
        emissiveMapUv: Ft && b(A.emissiveMap.channel),
        metalnessMapUv: ye && b(A.metalnessMap.channel),
        roughnessMapUv: I && b(A.roughnessMap.channel),
        anisotropyMapUv: ht && b(A.anisotropyMap.channel),
        clearcoatMapUv: ct && b(A.clearcoatMap.channel),
        clearcoatNormalMapUv: Ot && b(A.clearcoatNormalMap.channel),
        clearcoatRoughnessMapUv: at && b(A.clearcoatRoughnessMap.channel),
        iridescenceMapUv: bt && b(A.iridescenceMap.channel),
        iridescenceThicknessMapUv: Zt && b(A.iridescenceThicknessMap.channel),
        sheenColorMapUv: Pt && b(A.sheenColorMap.channel),
        sheenRoughnessMapUv: pt && b(A.sheenRoughnessMap.channel),
        specularMapUv: Bt && b(A.specularMap.channel),
        specularColorMapUv: zt && b(A.specularColorMap.channel),
        specularIntensityMapUv: xe && b(A.specularIntensityMap.channel),
        transmissionMapUv: y && b(A.transmissionMap.channel),
        thicknessMapUv: q && b(A.thicknessMap.channel),
        alphaMapUv: K && b(A.alphaMap.channel),
        vertexTangents: !!tt.attributes.tangent && (Qt || x),
        vertexColors: A.vertexColors,
        vertexAlphas: A.vertexColors === true && !!tt.attributes.color && tt.attributes.color.itemSize === 4,
        pointsUvs: V.isPoints === true && !!tt.attributes.uv && (Kt || K),
        fog: !!Z,
        useFog: A.fog === true,
        fogExp2: !!Z && Z.isFogExp2,
        flatShading: A.flatShading === true,
        sizeAttenuation: A.sizeAttenuation === true,
        logarithmicDepthBuffer: d,
        skinning: V.isSkinnedMesh === true,
        morphTargets: tt.morphAttributes.position !== void 0,
        morphNormals: tt.morphAttributes.normal !== void 0,
        morphColors: tt.morphAttributes.color !== void 0,
        morphTargetsCount: gt,
        morphTextureStride: qt,
        numDirLights: S.directional.length,
        numPointLights: S.point.length,
        numSpotLights: S.spot.length,
        numSpotLightMaps: S.spotLightMap.length,
        numRectAreaLights: S.rectArea.length,
        numHemiLights: S.hemi.length,
        numDirLightShadows: S.directionalShadowMap.length,
        numPointLightShadows: S.pointShadowMap.length,
        numSpotLightShadows: S.spotShadowMap.length,
        numSpotLightShadowsWithMaps: S.numSpotLightShadowsWithMaps,
        numLightProbes: S.numLightProbes,
        numClippingPlanes: a.numPlanes,
        numClipIntersection: a.numIntersection,
        dithering: A.dithering,
        shadowMapEnabled: r.shadowMap.enabled && F.length > 0,
        shadowMapType: r.shadowMap.type,
        toneMapping: Se,
        decodeVideoTexture: Kt && A.map.isVideoTexture === true && ie.getTransfer(A.map.colorSpace) === me,
        premultipliedAlpha: A.premultipliedAlpha,
        doubleSided: A.side === Mn,
        flipSided: A.side === nn,
        useDepthPacking: A.depthPacking >= 0,
        depthPacking: A.depthPacking || 0,
        index0AttributeName: A.index0AttributeName,
        extensionClipCullDistance: Nt && A.extensions.clipCullDistance === true && n.has("WEBGL_clip_cull_distance"),
        extensionMultiDraw: Nt && A.extensions.multiDraw === true && n.has("WEBGL_multi_draw"),
        rendererExtensionParallelShaderCompile: n.has("KHR_parallel_shader_compile"),
        customProgramCacheKey: A.customProgramCacheKey()
      };
      return Re.vertexUv1s = l.has(1), Re.vertexUv2s = l.has(2), Re.vertexUv3s = l.has(3), l.clear(), Re;
    }
    function _(A) {
      const S = [];
      if (A.shaderID ? S.push(A.shaderID) : (S.push(A.customVertexShaderID), S.push(A.customFragmentShaderID)), A.defines !== void 0) for (const F in A.defines) S.push(F), S.push(A.defines[F]);
      return A.isRawShaderMaterial === false && (E(S, A), v(S, A), S.push(r.outputColorSpace)), S.push(A.customProgramCacheKey), S.join();
    }
    function E(A, S) {
      A.push(S.precision), A.push(S.outputColorSpace), A.push(S.envMapMode), A.push(S.envMapCubeUVHeight), A.push(S.mapUv), A.push(S.alphaMapUv), A.push(S.lightMapUv), A.push(S.aoMapUv), A.push(S.bumpMapUv), A.push(S.normalMapUv), A.push(S.displacementMapUv), A.push(S.emissiveMapUv), A.push(S.metalnessMapUv), A.push(S.roughnessMapUv), A.push(S.anisotropyMapUv), A.push(S.clearcoatMapUv), A.push(S.clearcoatNormalMapUv), A.push(S.clearcoatRoughnessMapUv), A.push(S.iridescenceMapUv), A.push(S.iridescenceThicknessMapUv), A.push(S.sheenColorMapUv), A.push(S.sheenRoughnessMapUv), A.push(S.specularMapUv), A.push(S.specularColorMapUv), A.push(S.specularIntensityMapUv), A.push(S.transmissionMapUv), A.push(S.thicknessMapUv), A.push(S.combine), A.push(S.fogExp2), A.push(S.sizeAttenuation), A.push(S.morphTargetsCount), A.push(S.morphAttributeCount), A.push(S.numDirLights), A.push(S.numPointLights), A.push(S.numSpotLights), A.push(S.numSpotLightMaps), A.push(S.numHemiLights), A.push(S.numRectAreaLights), A.push(S.numDirLightShadows), A.push(S.numPointLightShadows), A.push(S.numSpotLightShadows), A.push(S.numSpotLightShadowsWithMaps), A.push(S.numLightProbes), A.push(S.shadowMapType), A.push(S.toneMapping), A.push(S.numClippingPlanes), A.push(S.numClipIntersection), A.push(S.depthPacking);
    }
    function v(A, S) {
      o.disableAll(), S.supportsVertexTextures && o.enable(0), S.instancing && o.enable(1), S.instancingColor && o.enable(2), S.instancingMorph && o.enable(3), S.matcap && o.enable(4), S.envMap && o.enable(5), S.normalMapObjectSpace && o.enable(6), S.normalMapTangentSpace && o.enable(7), S.clearcoat && o.enable(8), S.iridescence && o.enable(9), S.alphaTest && o.enable(10), S.vertexColors && o.enable(11), S.vertexAlphas && o.enable(12), S.vertexUv1s && o.enable(13), S.vertexUv2s && o.enable(14), S.vertexUv3s && o.enable(15), S.vertexTangents && o.enable(16), S.anisotropy && o.enable(17), S.alphaHash && o.enable(18), S.batching && o.enable(19), S.dispersion && o.enable(20), S.batchingColor && o.enable(21), A.push(o.mask), o.disableAll(), S.fog && o.enable(0), S.useFog && o.enable(1), S.flatShading && o.enable(2), S.logarithmicDepthBuffer && o.enable(3), S.skinning && o.enable(4), S.morphTargets && o.enable(5), S.morphNormals && o.enable(6), S.morphColors && o.enable(7), S.premultipliedAlpha && o.enable(8), S.shadowMapEnabled && o.enable(9), S.doubleSided && o.enable(10), S.flipSided && o.enable(11), S.useDepthPacking && o.enable(12), S.dithering && o.enable(13), S.transmission && o.enable(14), S.sheen && o.enable(15), S.opaque && o.enable(16), S.pointsUvs && o.enable(17), S.decodeVideoTexture && o.enable(18), S.alphaToCoverage && o.enable(19), A.push(o.mask);
    }
    function T(A) {
      const S = w[A.type];
      let F;
      if (S) {
        const W = Ln[S];
        F = Iu.clone(W.uniforms);
      } else F = A.uniforms;
      return F;
    }
    function O(A, S) {
      let F;
      for (let W = 0, V = h.length; W < V; W++) {
        const Z = h[W];
        if (Z.cacheKey === S) {
          F = Z, ++F.usedTimes;
          break;
        }
      }
      return F === void 0 && (F = new p0(r, S, A, s), h.push(F)), F;
    }
    function R(A) {
      if (--A.usedTimes === 0) {
        const S = h.indexOf(A);
        h[S] = h[h.length - 1], h.pop(), A.destroy();
      }
    }
    function P(A) {
      c.remove(A);
    }
    function z() {
      c.dispose();
    }
    return {
      getParameters: m,
      getProgramCacheKey: _,
      getUniforms: T,
      acquireProgram: O,
      releaseProgram: R,
      releaseShaderCache: P,
      programs: h,
      dispose: z
    };
  }
  function w0() {
    let r = /* @__PURE__ */ new WeakMap();
    function t(s) {
      let a = r.get(s);
      return a === void 0 && (a = {}, r.set(s, a)), a;
    }
    function e(s) {
      r.delete(s);
    }
    function n(s, a, o) {
      r.get(s)[a] = o;
    }
    function i() {
      r = /* @__PURE__ */ new WeakMap();
    }
    return {
      get: t,
      remove: e,
      update: n,
      dispose: i
    };
  }
  function b0(r, t) {
    return r.groupOrder !== t.groupOrder ? r.groupOrder - t.groupOrder : r.renderOrder !== t.renderOrder ? r.renderOrder - t.renderOrder : r.material.id !== t.material.id ? r.material.id - t.material.id : r.z !== t.z ? r.z - t.z : r.id - t.id;
  }
  function Qh(r, t) {
    return r.groupOrder !== t.groupOrder ? r.groupOrder - t.groupOrder : r.renderOrder !== t.renderOrder ? r.renderOrder - t.renderOrder : r.z !== t.z ? t.z - r.z : r.id - t.id;
  }
  function td() {
    const r = [];
    let t = 0;
    const e = [], n = [], i = [];
    function s() {
      t = 0, e.length = 0, n.length = 0, i.length = 0;
    }
    function a(d, u, p, w, b, m) {
      let _ = r[t];
      return _ === void 0 ? (_ = {
        id: d.id,
        object: d,
        geometry: u,
        material: p,
        groupOrder: w,
        renderOrder: d.renderOrder,
        z: b,
        group: m
      }, r[t] = _) : (_.id = d.id, _.object = d, _.geometry = u, _.material = p, _.groupOrder = w, _.renderOrder = d.renderOrder, _.z = b, _.group = m), t++, _;
    }
    function o(d, u, p, w, b, m) {
      const _ = a(d, u, p, w, b, m);
      p.transmission > 0 ? n.push(_) : p.transparent === true ? i.push(_) : e.push(_);
    }
    function c(d, u, p, w, b, m) {
      const _ = a(d, u, p, w, b, m);
      p.transmission > 0 ? n.unshift(_) : p.transparent === true ? i.unshift(_) : e.unshift(_);
    }
    function l(d, u) {
      e.length > 1 && e.sort(d || b0), n.length > 1 && n.sort(u || Qh), i.length > 1 && i.sort(u || Qh);
    }
    function h() {
      for (let d = t, u = r.length; d < u; d++) {
        const p = r[d];
        if (p.id === null) break;
        p.id = null, p.object = null, p.geometry = null, p.material = null, p.group = null;
      }
    }
    return {
      opaque: e,
      transmissive: n,
      transparent: i,
      init: s,
      push: o,
      unshift: c,
      finish: h,
      sort: l
    };
  }
  function y0() {
    let r = /* @__PURE__ */ new WeakMap();
    function t(n, i) {
      const s = r.get(n);
      let a;
      return s === void 0 ? (a = new td(), r.set(n, [
        a
      ])) : i >= s.length ? (a = new td(), s.push(a)) : a = s[i], a;
    }
    function e() {
      r = /* @__PURE__ */ new WeakMap();
    }
    return {
      get: t,
      dispose: e
    };
  }
  function v0() {
    const r = {};
    return {
      get: function(t) {
        if (r[t.id] !== void 0) return r[t.id];
        let e;
        switch (t.type) {
          case "DirectionalLight":
            e = {
              direction: new L(),
              color: new Ct()
            };
            break;
          case "SpotLight":
            e = {
              position: new L(),
              direction: new L(),
              color: new Ct(),
              distance: 0,
              coneCos: 0,
              penumbraCos: 0,
              decay: 0
            };
            break;
          case "PointLight":
            e = {
              position: new L(),
              color: new Ct(),
              distance: 0,
              decay: 0
            };
            break;
          case "HemisphereLight":
            e = {
              direction: new L(),
              skyColor: new Ct(),
              groundColor: new Ct()
            };
            break;
          case "RectAreaLight":
            e = {
              color: new Ct(),
              position: new L(),
              halfWidth: new L(),
              halfHeight: new L()
            };
            break;
        }
        return r[t.id] = e, e;
      }
    };
  }
  function x0() {
    const r = {};
    return {
      get: function(t) {
        if (r[t.id] !== void 0) return r[t.id];
        let e;
        switch (t.type) {
          case "DirectionalLight":
            e = {
              shadowBias: 0,
              shadowNormalBias: 0,
              shadowRadius: 1,
              shadowMapSize: new vt()
            };
            break;
          case "SpotLight":
            e = {
              shadowBias: 0,
              shadowNormalBias: 0,
              shadowRadius: 1,
              shadowMapSize: new vt()
            };
            break;
          case "PointLight":
            e = {
              shadowBias: 0,
              shadowNormalBias: 0,
              shadowRadius: 1,
              shadowMapSize: new vt(),
              shadowCameraNear: 1,
              shadowCameraFar: 1e3
            };
            break;
        }
        return r[t.id] = e, e;
      }
    };
  }
  let S0 = 0;
  function M0(r, t) {
    return (t.castShadow ? 2 : 0) - (r.castShadow ? 2 : 0) + (t.map ? 1 : 0) - (r.map ? 1 : 0);
  }
  function E0(r) {
    const t = new v0(), e = x0(), n = {
      version: 0,
      hash: {
        directionalLength: -1,
        pointLength: -1,
        spotLength: -1,
        rectAreaLength: -1,
        hemiLength: -1,
        numDirectionalShadows: -1,
        numPointShadows: -1,
        numSpotShadows: -1,
        numSpotMaps: -1,
        numLightProbes: -1
      },
      ambient: [
        0,
        0,
        0
      ],
      probe: [],
      directional: [],
      directionalShadow: [],
      directionalShadowMap: [],
      directionalShadowMatrix: [],
      spot: [],
      spotLightMap: [],
      spotShadow: [],
      spotShadowMap: [],
      spotLightMatrix: [],
      rectArea: [],
      rectAreaLTC1: null,
      rectAreaLTC2: null,
      point: [],
      pointShadow: [],
      pointShadowMap: [],
      pointShadowMatrix: [],
      hemi: [],
      numSpotLightShadowsWithMaps: 0,
      numLightProbes: 0
    };
    for (let l = 0; l < 9; l++) n.probe.push(new L());
    const i = new L(), s = new Ht(), a = new Ht();
    function o(l) {
      let h = 0, d = 0, u = 0;
      for (let A = 0; A < 9; A++) n.probe[A].set(0, 0, 0);
      let p = 0, w = 0, b = 0, m = 0, _ = 0, E = 0, v = 0, T = 0, O = 0, R = 0, P = 0;
      l.sort(M0);
      for (let A = 0, S = l.length; A < S; A++) {
        const F = l[A], W = F.color, V = F.intensity, Z = F.distance, tt = F.shadow && F.shadow.map ? F.shadow.map.texture : null;
        if (F.isAmbientLight) h += W.r * V, d += W.g * V, u += W.b * V;
        else if (F.isLightProbe) {
          for (let Y = 0; Y < 9; Y++) n.probe[Y].addScaledVector(F.sh.coefficients[Y], V);
          P++;
        } else if (F.isDirectionalLight) {
          const Y = t.get(F);
          if (Y.color.copy(F.color).multiplyScalar(F.intensity), F.castShadow) {
            const J = F.shadow, $ = e.get(F);
            $.shadowBias = J.bias, $.shadowNormalBias = J.normalBias, $.shadowRadius = J.radius, $.shadowMapSize = J.mapSize, n.directionalShadow[p] = $, n.directionalShadowMap[p] = tt, n.directionalShadowMatrix[p] = F.shadow.matrix, E++;
          }
          n.directional[p] = Y, p++;
        } else if (F.isSpotLight) {
          const Y = t.get(F);
          Y.position.setFromMatrixPosition(F.matrixWorld), Y.color.copy(W).multiplyScalar(V), Y.distance = Z, Y.coneCos = Math.cos(F.angle), Y.penumbraCos = Math.cos(F.angle * (1 - F.penumbra)), Y.decay = F.decay, n.spot[b] = Y;
          const J = F.shadow;
          if (F.map && (n.spotLightMap[O] = F.map, O++, J.updateMatrices(F), F.castShadow && R++), n.spotLightMatrix[b] = J.matrix, F.castShadow) {
            const $ = e.get(F);
            $.shadowBias = J.bias, $.shadowNormalBias = J.normalBias, $.shadowRadius = J.radius, $.shadowMapSize = J.mapSize, n.spotShadow[b] = $, n.spotShadowMap[b] = tt, T++;
          }
          b++;
        } else if (F.isRectAreaLight) {
          const Y = t.get(F);
          Y.color.copy(W).multiplyScalar(V), Y.halfWidth.set(F.width * 0.5, 0, 0), Y.halfHeight.set(0, F.height * 0.5, 0), n.rectArea[m] = Y, m++;
        } else if (F.isPointLight) {
          const Y = t.get(F);
          if (Y.color.copy(F.color).multiplyScalar(F.intensity), Y.distance = F.distance, Y.decay = F.decay, F.castShadow) {
            const J = F.shadow, $ = e.get(F);
            $.shadowBias = J.bias, $.shadowNormalBias = J.normalBias, $.shadowRadius = J.radius, $.shadowMapSize = J.mapSize, $.shadowCameraNear = J.camera.near, $.shadowCameraFar = J.camera.far, n.pointShadow[w] = $, n.pointShadowMap[w] = tt, n.pointShadowMatrix[w] = F.shadow.matrix, v++;
          }
          n.point[w] = Y, w++;
        } else if (F.isHemisphereLight) {
          const Y = t.get(F);
          Y.skyColor.copy(F.color).multiplyScalar(V), Y.groundColor.copy(F.groundColor).multiplyScalar(V), n.hemi[_] = Y, _++;
        }
      }
      m > 0 && (r.has("OES_texture_float_linear") === true ? (n.rectAreaLTC1 = dt.LTC_FLOAT_1, n.rectAreaLTC2 = dt.LTC_FLOAT_2) : (n.rectAreaLTC1 = dt.LTC_HALF_1, n.rectAreaLTC2 = dt.LTC_HALF_2)), n.ambient[0] = h, n.ambient[1] = d, n.ambient[2] = u;
      const z = n.hash;
      (z.directionalLength !== p || z.pointLength !== w || z.spotLength !== b || z.rectAreaLength !== m || z.hemiLength !== _ || z.numDirectionalShadows !== E || z.numPointShadows !== v || z.numSpotShadows !== T || z.numSpotMaps !== O || z.numLightProbes !== P) && (n.directional.length = p, n.spot.length = b, n.rectArea.length = m, n.point.length = w, n.hemi.length = _, n.directionalShadow.length = E, n.directionalShadowMap.length = E, n.pointShadow.length = v, n.pointShadowMap.length = v, n.spotShadow.length = T, n.spotShadowMap.length = T, n.directionalShadowMatrix.length = E, n.pointShadowMatrix.length = v, n.spotLightMatrix.length = T + O - R, n.spotLightMap.length = O, n.numSpotLightShadowsWithMaps = R, n.numLightProbes = P, z.directionalLength = p, z.pointLength = w, z.spotLength = b, z.rectAreaLength = m, z.hemiLength = _, z.numDirectionalShadows = E, z.numPointShadows = v, z.numSpotShadows = T, z.numSpotMaps = O, z.numLightProbes = P, n.version = S0++);
    }
    function c(l, h) {
      let d = 0, u = 0, p = 0, w = 0, b = 0;
      const m = h.matrixWorldInverse;
      for (let _ = 0, E = l.length; _ < E; _++) {
        const v = l[_];
        if (v.isDirectionalLight) {
          const T = n.directional[d];
          T.direction.setFromMatrixPosition(v.matrixWorld), i.setFromMatrixPosition(v.target.matrixWorld), T.direction.sub(i), T.direction.transformDirection(m), d++;
        } else if (v.isSpotLight) {
          const T = n.spot[p];
          T.position.setFromMatrixPosition(v.matrixWorld), T.position.applyMatrix4(m), T.direction.setFromMatrixPosition(v.matrixWorld), i.setFromMatrixPosition(v.target.matrixWorld), T.direction.sub(i), T.direction.transformDirection(m), p++;
        } else if (v.isRectAreaLight) {
          const T = n.rectArea[w];
          T.position.setFromMatrixPosition(v.matrixWorld), T.position.applyMatrix4(m), a.identity(), s.copy(v.matrixWorld), s.premultiply(m), a.extractRotation(s), T.halfWidth.set(v.width * 0.5, 0, 0), T.halfHeight.set(0, v.height * 0.5, 0), T.halfWidth.applyMatrix4(a), T.halfHeight.applyMatrix4(a), w++;
        } else if (v.isPointLight) {
          const T = n.point[u];
          T.position.setFromMatrixPosition(v.matrixWorld), T.position.applyMatrix4(m), u++;
        } else if (v.isHemisphereLight) {
          const T = n.hemi[b];
          T.direction.setFromMatrixPosition(v.matrixWorld), T.direction.transformDirection(m), b++;
        }
      }
    }
    return {
      setup: o,
      setupView: c,
      state: n
    };
  }
  function ed(r) {
    const t = new E0(r), e = [], n = [];
    function i(h) {
      l.camera = h, e.length = 0, n.length = 0;
    }
    function s(h) {
      e.push(h);
    }
    function a(h) {
      n.push(h);
    }
    function o() {
      t.setup(e);
    }
    function c(h) {
      t.setupView(e, h);
    }
    const l = {
      lightsArray: e,
      shadowsArray: n,
      camera: null,
      lights: t,
      transmissionRenderTarget: {}
    };
    return {
      init: i,
      state: l,
      setupLights: o,
      setupLightsView: c,
      pushLight: s,
      pushShadow: a
    };
  }
  function T0(r) {
    let t = /* @__PURE__ */ new WeakMap();
    function e(i, s = 0) {
      const a = t.get(i);
      let o;
      return a === void 0 ? (o = new ed(r), t.set(i, [
        o
      ])) : s >= a.length ? (o = new ed(r), a.push(o)) : o = a[s], o;
    }
    function n() {
      t = /* @__PURE__ */ new WeakMap();
    }
    return {
      get: e,
      dispose: n
    };
  }
  class A0 extends Rn {
    constructor(t) {
      super(), this.isMeshDepthMaterial = true, this.type = "MeshDepthMaterial", this.depthPacking = df, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = false, this.wireframeLinewidth = 1, this.setValues(t);
    }
    copy(t) {
      return super.copy(t), this.depthPacking = t.depthPacking, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this;
    }
  }
  class R0 extends Rn {
    constructor(t) {
      super(), this.isMeshDistanceMaterial = true, this.type = "MeshDistanceMaterial", this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(t);
    }
    copy(t) {
      return super.copy(t), this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this;
    }
  }
  const C0 = `void main() {
	gl_Position = vec4( position, 1.0 );
}`, P0 = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
  function I0(r, t, e) {
    let n = new Uc();
    const i = new vt(), s = new vt(), a = new de(), o = new A0({
      depthPacking: uf
    }), c = new R0(), l = {}, h = e.maxTextureSize, d = {
      [Jn]: nn,
      [nn]: Jn,
      [Mn]: Mn
    }, u = new Qn({
      defines: {
        VSM_SAMPLES: 8
      },
      uniforms: {
        shadow_pass: {
          value: null
        },
        resolution: {
          value: new vt()
        },
        radius: {
          value: 4
        }
      },
      vertexShader: C0,
      fragmentShader: P0
    }), p = u.clone();
    p.defines.HORIZONTAL_PASS = 1;
    const w = new sn();
    w.setAttribute("position", new rn(new Float32Array([
      -1,
      -1,
      0.5,
      3,
      -1,
      0.5,
      -1,
      3,
      0.5
    ]), 3));
    const b = new fe(w, u), m = this;
    this.enabled = false, this.autoUpdate = true, this.needsUpdate = false, this.type = au;
    let _ = this.type;
    this.render = function(R, P, z) {
      if (m.enabled === false || m.autoUpdate === false && m.needsUpdate === false || R.length === 0) return;
      const A = r.getRenderTarget(), S = r.getActiveCubeFace(), F = r.getActiveMipmapLevel(), W = r.state;
      W.setBlending(vi), W.buffers.color.setClear(1, 1, 1, 1), W.buffers.depth.setTest(true), W.setScissorTest(false);
      const V = _ !== Kn && this.type === Kn, Z = _ === Kn && this.type !== Kn;
      for (let tt = 0, Y = R.length; tt < Y; tt++) {
        const J = R[tt], $ = J.shadow;
        if ($ === void 0) {
          console.warn("THREE.WebGLShadowMap:", J, "has no shadow.");
          continue;
        }
        if ($.autoUpdate === false && $.needsUpdate === false) continue;
        i.copy($.mapSize);
        const ut = $.getFrameExtents();
        if (i.multiply(ut), s.copy($.mapSize), (i.x > h || i.y > h) && (i.x > h && (s.x = Math.floor(h / ut.x), i.x = s.x * ut.x, $.mapSize.x = s.x), i.y > h && (s.y = Math.floor(h / ut.y), i.y = s.y * ut.y, $.mapSize.y = s.y)), $.map === null || V === true || Z === true) {
          const gt = this.type !== Kn ? {
            minFilter: en,
            magFilter: en
          } : {};
          $.map !== null && $.map.dispose(), $.map = new Bi(i.x, i.y, gt), $.map.texture.name = J.name + ".shadowMap", $.camera.updateProjectionMatrix();
        }
        r.setRenderTarget($.map), r.clear();
        const mt = $.getViewportCount();
        for (let gt = 0; gt < mt; gt++) {
          const qt = $.getViewport(gt);
          a.set(s.x * qt.x, s.y * qt.y, s.x * qt.z, s.y * qt.w), W.viewport(a), $.updateMatrices(J, gt), n = $.getFrustum(), T(P, z, $.camera, J, this.type);
        }
        $.isPointLightShadow !== true && this.type === Kn && E($, z), $.needsUpdate = false;
      }
      _ = this.type, m.needsUpdate = false, r.setRenderTarget(A, S, F);
    };
    function E(R, P) {
      const z = t.update(b);
      u.defines.VSM_SAMPLES !== R.blurSamples && (u.defines.VSM_SAMPLES = R.blurSamples, p.defines.VSM_SAMPLES = R.blurSamples, u.needsUpdate = true, p.needsUpdate = true), R.mapPass === null && (R.mapPass = new Bi(i.x, i.y)), u.uniforms.shadow_pass.value = R.map.texture, u.uniforms.resolution.value = R.mapSize, u.uniforms.radius.value = R.radius, r.setRenderTarget(R.mapPass), r.clear(), r.renderBufferDirect(P, null, z, u, b, null), p.uniforms.shadow_pass.value = R.mapPass.texture, p.uniforms.resolution.value = R.mapSize, p.uniforms.radius.value = R.radius, r.setRenderTarget(R.map), r.clear(), r.renderBufferDirect(P, null, z, p, b, null);
    }
    function v(R, P, z, A) {
      let S = null;
      const F = z.isPointLight === true ? R.customDistanceMaterial : R.customDepthMaterial;
      if (F !== void 0) S = F;
      else if (S = z.isPointLight === true ? c : o, r.localClippingEnabled && P.clipShadows === true && Array.isArray(P.clippingPlanes) && P.clippingPlanes.length !== 0 || P.displacementMap && P.displacementScale !== 0 || P.alphaMap && P.alphaTest > 0 || P.map && P.alphaTest > 0) {
        const W = S.uuid, V = P.uuid;
        let Z = l[W];
        Z === void 0 && (Z = {}, l[W] = Z);
        let tt = Z[V];
        tt === void 0 && (tt = S.clone(), Z[V] = tt, P.addEventListener("dispose", O)), S = tt;
      }
      if (S.visible = P.visible, S.wireframe = P.wireframe, A === Kn ? S.side = P.shadowSide !== null ? P.shadowSide : P.side : S.side = P.shadowSide !== null ? P.shadowSide : d[P.side], S.alphaMap = P.alphaMap, S.alphaTest = P.alphaTest, S.map = P.map, S.clipShadows = P.clipShadows, S.clippingPlanes = P.clippingPlanes, S.clipIntersection = P.clipIntersection, S.displacementMap = P.displacementMap, S.displacementScale = P.displacementScale, S.displacementBias = P.displacementBias, S.wireframeLinewidth = P.wireframeLinewidth, S.linewidth = P.linewidth, z.isPointLight === true && S.isMeshDistanceMaterial === true) {
        const W = r.properties.get(S);
        W.light = z;
      }
      return S;
    }
    function T(R, P, z, A, S) {
      if (R.visible === false) return;
      if (R.layers.test(P.layers) && (R.isMesh || R.isLine || R.isPoints) && (R.castShadow || R.receiveShadow && S === Kn) && (!R.frustumCulled || n.intersectsObject(R))) {
        R.modelViewMatrix.multiplyMatrices(z.matrixWorldInverse, R.matrixWorld);
        const V = t.update(R), Z = R.material;
        if (Array.isArray(Z)) {
          const tt = V.groups;
          for (let Y = 0, J = tt.length; Y < J; Y++) {
            const $ = tt[Y], ut = Z[$.materialIndex];
            if (ut && ut.visible) {
              const mt = v(R, ut, A, S);
              R.onBeforeShadow(r, R, P, z, V, mt, $), r.renderBufferDirect(z, null, V, mt, R, $), R.onAfterShadow(r, R, P, z, V, mt, $);
            }
          }
        } else if (Z.visible) {
          const tt = v(R, Z, A, S);
          R.onBeforeShadow(r, R, P, z, V, tt, null), r.renderBufferDirect(z, null, V, tt, R, null), R.onAfterShadow(r, R, P, z, V, tt, null);
        }
      }
      const W = R.children;
      for (let V = 0, Z = W.length; V < Z; V++) T(W[V], P, z, A, S);
    }
    function O(R) {
      R.target.removeEventListener("dispose", O);
      for (const z in l) {
        const A = l[z], S = R.target.uuid;
        S in A && (A[S].dispose(), delete A[S]);
      }
    }
  }
  function L0(r) {
    function t() {
      let y = false;
      const q = new de();
      let H = null;
      const K = new de(0, 0, 0, 0);
      return {
        setMask: function(nt) {
          H !== nt && !y && (r.colorMask(nt, nt, nt, nt), H = nt);
        },
        setLocked: function(nt) {
          y = nt;
        },
        setClear: function(nt, Mt, Nt, Se, Re) {
          Re === true && (nt *= Se, Mt *= Se, Nt *= Se), q.set(nt, Mt, Nt, Se), K.equals(q) === false && (r.clearColor(nt, Mt, Nt, Se), K.copy(q));
        },
        reset: function() {
          y = false, H = null, K.set(-1, 0, 0, 0);
        }
      };
    }
    function e() {
      let y = false, q = null, H = null, K = null;
      return {
        setTest: function(nt) {
          nt ? _t(r.DEPTH_TEST) : lt(r.DEPTH_TEST);
        },
        setMask: function(nt) {
          q !== nt && !y && (r.depthMask(nt), q = nt);
        },
        setFunc: function(nt) {
          if (H !== nt) {
            switch (nt) {
              case Op:
                r.depthFunc(r.NEVER);
                break;
              case Bp:
                r.depthFunc(r.ALWAYS);
                break;
              case zp:
                r.depthFunc(r.LESS);
                break;
              case pa:
                r.depthFunc(r.LEQUAL);
                break;
              case kp:
                r.depthFunc(r.EQUAL);
                break;
              case Hp:
                r.depthFunc(r.GEQUAL);
                break;
              case Gp:
                r.depthFunc(r.GREATER);
                break;
              case Vp:
                r.depthFunc(r.NOTEQUAL);
                break;
              default:
                r.depthFunc(r.LEQUAL);
            }
            H = nt;
          }
        },
        setLocked: function(nt) {
          y = nt;
        },
        setClear: function(nt) {
          K !== nt && (r.clearDepth(nt), K = nt);
        },
        reset: function() {
          y = false, q = null, H = null, K = null;
        }
      };
    }
    function n() {
      let y = false, q = null, H = null, K = null, nt = null, Mt = null, Nt = null, Se = null, Re = null;
      return {
        setTest: function(ne) {
          y || (ne ? _t(r.STENCIL_TEST) : lt(r.STENCIL_TEST));
        },
        setMask: function(ne) {
          q !== ne && !y && (r.stencilMask(ne), q = ne);
        },
        setFunc: function(ne, Ce, Pe) {
          (H !== ne || K !== Ce || nt !== Pe) && (r.stencilFunc(ne, Ce, Pe), H = ne, K = Ce, nt = Pe);
        },
        setOp: function(ne, Ce, Pe) {
          (Mt !== ne || Nt !== Ce || Se !== Pe) && (r.stencilOp(ne, Ce, Pe), Mt = ne, Nt = Ce, Se = Pe);
        },
        setLocked: function(ne) {
          y = ne;
        },
        setClear: function(ne) {
          Re !== ne && (r.clearStencil(ne), Re = ne);
        },
        reset: function() {
          y = false, q = null, H = null, K = null, nt = null, Mt = null, Nt = null, Se = null, Re = null;
        }
      };
    }
    const i = new t(), s = new e(), a = new n(), o = /* @__PURE__ */ new WeakMap(), c = /* @__PURE__ */ new WeakMap();
    let l = {}, h = {}, d = /* @__PURE__ */ new WeakMap(), u = [], p = null, w = false, b = null, m = null, _ = null, E = null, v = null, T = null, O = null, R = new Ct(0, 0, 0), P = 0, z = false, A = null, S = null, F = null, W = null, V = null;
    const Z = r.getParameter(r.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
    let tt = false, Y = 0;
    const J = r.getParameter(r.VERSION);
    J.indexOf("WebGL") !== -1 ? (Y = parseFloat(/^WebGL (\d)/.exec(J)[1]), tt = Y >= 1) : J.indexOf("OpenGL ES") !== -1 && (Y = parseFloat(/^OpenGL ES (\d)/.exec(J)[1]), tt = Y >= 2);
    let $ = null, ut = {};
    const mt = r.getParameter(r.SCISSOR_BOX), gt = r.getParameter(r.VIEWPORT), qt = new de().fromArray(mt), ee = new de().fromArray(gt);
    function Q(y, q, H, K) {
      const nt = new Uint8Array(4), Mt = r.createTexture();
      r.bindTexture(y, Mt), r.texParameteri(y, r.TEXTURE_MIN_FILTER, r.NEAREST), r.texParameteri(y, r.TEXTURE_MAG_FILTER, r.NEAREST);
      for (let Nt = 0; Nt < H; Nt++) y === r.TEXTURE_3D || y === r.TEXTURE_2D_ARRAY ? r.texImage3D(q, 0, r.RGBA, 1, 1, K, 0, r.RGBA, r.UNSIGNED_BYTE, nt) : r.texImage2D(q + Nt, 0, r.RGBA, 1, 1, 0, r.RGBA, r.UNSIGNED_BYTE, nt);
      return Mt;
    }
    const st = {};
    st[r.TEXTURE_2D] = Q(r.TEXTURE_2D, r.TEXTURE_2D, 1), st[r.TEXTURE_CUBE_MAP] = Q(r.TEXTURE_CUBE_MAP, r.TEXTURE_CUBE_MAP_POSITIVE_X, 6), st[r.TEXTURE_2D_ARRAY] = Q(r.TEXTURE_2D_ARRAY, r.TEXTURE_2D_ARRAY, 1, 1), st[r.TEXTURE_3D] = Q(r.TEXTURE_3D, r.TEXTURE_3D, 1, 1), i.setClear(0, 0, 0, 1), s.setClear(1), a.setClear(0), _t(r.DEPTH_TEST), s.setFunc(pa), At(false), Qt(Ll), _t(r.CULL_FACE), jt(vi);
    function _t(y) {
      l[y] !== true && (r.enable(y), l[y] = true);
    }
    function lt(y) {
      l[y] !== false && (r.disable(y), l[y] = false);
    }
    function kt(y, q) {
      return h[y] !== q ? (r.bindFramebuffer(y, q), h[y] = q, y === r.DRAW_FRAMEBUFFER && (h[r.FRAMEBUFFER] = q), y === r.FRAMEBUFFER && (h[r.DRAW_FRAMEBUFFER] = q), true) : false;
    }
    function Dt(y, q) {
      let H = u, K = false;
      if (y) {
        H = d.get(q), H === void 0 && (H = [], d.set(q, H));
        const nt = y.textures;
        if (H.length !== nt.length || H[0] !== r.COLOR_ATTACHMENT0) {
          for (let Mt = 0, Nt = nt.length; Mt < Nt; Mt++) H[Mt] = r.COLOR_ATTACHMENT0 + Mt;
          H.length = nt.length, K = true;
        }
      } else H[0] !== r.BACK && (H[0] = r.BACK, K = true);
      K && r.drawBuffers(H);
    }
    function Kt(y) {
      return p !== y ? (r.useProgram(y), p = y, true) : false;
    }
    const D = {
      [Ui]: r.FUNC_ADD,
      [yp]: r.FUNC_SUBTRACT,
      [vp]: r.FUNC_REVERSE_SUBTRACT
    };
    D[xp] = r.MIN, D[Sp] = r.MAX;
    const Yt = {
      [Mp]: r.ZERO,
      [Ep]: r.ONE,
      [Tp]: r.SRC_COLOR,
      [wc]: r.SRC_ALPHA,
      [Lp]: r.SRC_ALPHA_SATURATE,
      [Pp]: r.DST_COLOR,
      [Rp]: r.DST_ALPHA,
      [Ap]: r.ONE_MINUS_SRC_COLOR,
      [bc]: r.ONE_MINUS_SRC_ALPHA,
      [Ip]: r.ONE_MINUS_DST_COLOR,
      [Cp]: r.ONE_MINUS_DST_ALPHA,
      [Dp]: r.CONSTANT_COLOR,
      [Np]: r.ONE_MINUS_CONSTANT_COLOR,
      [Up]: r.CONSTANT_ALPHA,
      [Fp]: r.ONE_MINUS_CONSTANT_ALPHA
    };
    function jt(y, q, H, K, nt, Mt, Nt, Se, Re, ne) {
      if (y === vi) {
        w === true && (lt(r.BLEND), w = false);
        return;
      }
      if (w === false && (_t(r.BLEND), w = true), y !== bp) {
        if (y !== b || ne !== z) {
          if ((m !== Ui || v !== Ui) && (r.blendEquation(r.FUNC_ADD), m = Ui, v = Ui), ne) switch (y) {
            case gr:
              r.blendFuncSeparate(r.ONE, r.ONE_MINUS_SRC_ALPHA, r.ONE, r.ONE_MINUS_SRC_ALPHA);
              break;
            case Dl:
              r.blendFunc(r.ONE, r.ONE);
              break;
            case Nl:
              r.blendFuncSeparate(r.ZERO, r.ONE_MINUS_SRC_COLOR, r.ZERO, r.ONE);
              break;
            case Ul:
              r.blendFuncSeparate(r.ZERO, r.SRC_COLOR, r.ZERO, r.SRC_ALPHA);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", y);
              break;
          }
          else switch (y) {
            case gr:
              r.blendFuncSeparate(r.SRC_ALPHA, r.ONE_MINUS_SRC_ALPHA, r.ONE, r.ONE_MINUS_SRC_ALPHA);
              break;
            case Dl:
              r.blendFunc(r.SRC_ALPHA, r.ONE);
              break;
            case Nl:
              r.blendFuncSeparate(r.ZERO, r.ONE_MINUS_SRC_COLOR, r.ZERO, r.ONE);
              break;
            case Ul:
              r.blendFunc(r.ZERO, r.SRC_COLOR);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", y);
              break;
          }
          _ = null, E = null, T = null, O = null, R.set(0, 0, 0), P = 0, b = y, z = ne;
        }
        return;
      }
      nt = nt || q, Mt = Mt || H, Nt = Nt || K, (q !== m || nt !== v) && (r.blendEquationSeparate(D[q], D[nt]), m = q, v = nt), (H !== _ || K !== E || Mt !== T || Nt !== O) && (r.blendFuncSeparate(Yt[H], Yt[K], Yt[Mt], Yt[Nt]), _ = H, E = K, T = Mt, O = Nt), (Se.equals(R) === false || Re !== P) && (r.blendColor(Se.r, Se.g, Se.b, Re), R.copy(Se), P = Re), b = y, z = false;
    }
    function ue(y, q) {
      y.side === Mn ? lt(r.CULL_FACE) : _t(r.CULL_FACE);
      let H = y.side === nn;
      q && (H = !H), At(H), y.blending === gr && y.transparent === false ? jt(vi) : jt(y.blending, y.blendEquation, y.blendSrc, y.blendDst, y.blendEquationAlpha, y.blendSrcAlpha, y.blendDstAlpha, y.blendColor, y.blendAlpha, y.premultipliedAlpha), s.setFunc(y.depthFunc), s.setTest(y.depthTest), s.setMask(y.depthWrite), i.setMask(y.colorWrite);
      const K = y.stencilWrite;
      a.setTest(K), K && (a.setMask(y.stencilWriteMask), a.setFunc(y.stencilFunc, y.stencilRef, y.stencilFuncMask), a.setOp(y.stencilFail, y.stencilZFail, y.stencilZPass)), Ft(y.polygonOffset, y.polygonOffsetFactor, y.polygonOffsetUnits), y.alphaToCoverage === true ? _t(r.SAMPLE_ALPHA_TO_COVERAGE) : lt(r.SAMPLE_ALPHA_TO_COVERAGE);
    }
    function At(y) {
      A !== y && (y ? r.frontFace(r.CW) : r.frontFace(r.CCW), A = y);
    }
    function Qt(y) {
      y !== gp ? (_t(r.CULL_FACE), y !== S && (y === Ll ? r.cullFace(r.BACK) : y === wp ? r.cullFace(r.FRONT) : r.cullFace(r.FRONT_AND_BACK))) : lt(r.CULL_FACE), S = y;
    }
    function Xt(y) {
      y !== F && (tt && r.lineWidth(y), F = y);
    }
    function Ft(y, q, H) {
      y ? (_t(r.POLYGON_OFFSET_FILL), (W !== q || V !== H) && (r.polygonOffset(q, H), W = q, V = H)) : lt(r.POLYGON_OFFSET_FILL);
    }
    function ye(y) {
      y ? _t(r.SCISSOR_TEST) : lt(r.SCISSOR_TEST);
    }
    function I(y) {
      y === void 0 && (y = r.TEXTURE0 + Z - 1), $ !== y && (r.activeTexture(y), $ = y);
    }
    function x(y, q, H) {
      H === void 0 && ($ === null ? H = r.TEXTURE0 + Z - 1 : H = $);
      let K = ut[H];
      K === void 0 && (K = {
        type: void 0,
        texture: void 0
      }, ut[H] = K), (K.type !== y || K.texture !== q) && ($ !== H && (r.activeTexture(H), $ = H), r.bindTexture(y, q || st[y]), K.type = y, K.texture = q);
    }
    function X() {
      const y = ut[$];
      y !== void 0 && y.type !== void 0 && (r.bindTexture(y.type, null), y.type = void 0, y.texture = void 0);
    }
    function et() {
      try {
        r.compressedTexImage2D.apply(r, arguments);
      } catch (y) {
        console.error("THREE.WebGLState:", y);
      }
    }
    function it() {
      try {
        r.compressedTexImage3D.apply(r, arguments);
      } catch (y) {
        console.error("THREE.WebGLState:", y);
      }
    }
    function rt() {
      try {
        r.texSubImage2D.apply(r, arguments);
      } catch (y) {
        console.error("THREE.WebGLState:", y);
      }
    }
    function St() {
      try {
        r.texSubImage3D.apply(r, arguments);
      } catch (y) {
        console.error("THREE.WebGLState:", y);
      }
    }
    function ht() {
      try {
        r.compressedTexSubImage2D.apply(r, arguments);
      } catch (y) {
        console.error("THREE.WebGLState:", y);
      }
    }
    function ct() {
      try {
        r.compressedTexSubImage3D.apply(r, arguments);
      } catch (y) {
        console.error("THREE.WebGLState:", y);
      }
    }
    function Ot() {
      try {
        r.texStorage2D.apply(r, arguments);
      } catch (y) {
        console.error("THREE.WebGLState:", y);
      }
    }
    function at() {
      try {
        r.texStorage3D.apply(r, arguments);
      } catch (y) {
        console.error("THREE.WebGLState:", y);
      }
    }
    function bt() {
      try {
        r.texImage2D.apply(r, arguments);
      } catch (y) {
        console.error("THREE.WebGLState:", y);
      }
    }
    function Zt() {
      try {
        r.texImage3D.apply(r, arguments);
      } catch (y) {
        console.error("THREE.WebGLState:", y);
      }
    }
    function Pt(y) {
      qt.equals(y) === false && (r.scissor(y.x, y.y, y.z, y.w), qt.copy(y));
    }
    function pt(y) {
      ee.equals(y) === false && (r.viewport(y.x, y.y, y.z, y.w), ee.copy(y));
    }
    function Bt(y, q) {
      let H = c.get(q);
      H === void 0 && (H = /* @__PURE__ */ new WeakMap(), c.set(q, H));
      let K = H.get(y);
      K === void 0 && (K = r.getUniformBlockIndex(q, y.name), H.set(y, K));
    }
    function zt(y, q) {
      const K = c.get(q).get(y);
      o.get(q) !== K && (r.uniformBlockBinding(q, K, y.__bindingPointIndex), o.set(q, K));
    }
    function xe() {
      r.disable(r.BLEND), r.disable(r.CULL_FACE), r.disable(r.DEPTH_TEST), r.disable(r.POLYGON_OFFSET_FILL), r.disable(r.SCISSOR_TEST), r.disable(r.STENCIL_TEST), r.disable(r.SAMPLE_ALPHA_TO_COVERAGE), r.blendEquation(r.FUNC_ADD), r.blendFunc(r.ONE, r.ZERO), r.blendFuncSeparate(r.ONE, r.ZERO, r.ONE, r.ZERO), r.blendColor(0, 0, 0, 0), r.colorMask(true, true, true, true), r.clearColor(0, 0, 0, 0), r.depthMask(true), r.depthFunc(r.LESS), r.clearDepth(1), r.stencilMask(4294967295), r.stencilFunc(r.ALWAYS, 0, 4294967295), r.stencilOp(r.KEEP, r.KEEP, r.KEEP), r.clearStencil(0), r.cullFace(r.BACK), r.frontFace(r.CCW), r.polygonOffset(0, 0), r.activeTexture(r.TEXTURE0), r.bindFramebuffer(r.FRAMEBUFFER, null), r.bindFramebuffer(r.DRAW_FRAMEBUFFER, null), r.bindFramebuffer(r.READ_FRAMEBUFFER, null), r.useProgram(null), r.lineWidth(1), r.scissor(0, 0, r.canvas.width, r.canvas.height), r.viewport(0, 0, r.canvas.width, r.canvas.height), l = {}, $ = null, ut = {}, h = {}, d = /* @__PURE__ */ new WeakMap(), u = [], p = null, w = false, b = null, m = null, _ = null, E = null, v = null, T = null, O = null, R = new Ct(0, 0, 0), P = 0, z = false, A = null, S = null, F = null, W = null, V = null, qt.set(0, 0, r.canvas.width, r.canvas.height), ee.set(0, 0, r.canvas.width, r.canvas.height), i.reset(), s.reset(), a.reset();
    }
    return {
      buffers: {
        color: i,
        depth: s,
        stencil: a
      },
      enable: _t,
      disable: lt,
      bindFramebuffer: kt,
      drawBuffers: Dt,
      useProgram: Kt,
      setBlending: jt,
      setMaterial: ue,
      setFlipSided: At,
      setCullFace: Qt,
      setLineWidth: Xt,
      setPolygonOffset: Ft,
      setScissorTest: ye,
      activeTexture: I,
      bindTexture: x,
      unbindTexture: X,
      compressedTexImage2D: et,
      compressedTexImage3D: it,
      texImage2D: bt,
      texImage3D: Zt,
      updateUBOMapping: Bt,
      uniformBlockBinding: zt,
      texStorage2D: Ot,
      texStorage3D: at,
      texSubImage2D: rt,
      texSubImage3D: St,
      compressedTexSubImage2D: ht,
      compressedTexSubImage3D: ct,
      scissor: Pt,
      viewport: pt,
      reset: xe
    };
  }
  function D0(r, t, e, n, i, s, a) {
    const o = t.has("WEBGL_multisampled_render_to_texture") ? t.get("WEBGL_multisampled_render_to_texture") : null, c = typeof navigator > "u" ? false : /OculusBrowser/g.test(navigator.userAgent), l = new vt(), h = /* @__PURE__ */ new WeakMap();
    let d;
    const u = /* @__PURE__ */ new WeakMap();
    let p = false;
    try {
      p = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
    } catch {
    }
    function w(I, x) {
      return p ? new OffscreenCanvas(I, x) : hs("canvas");
    }
    function b(I, x, X) {
      let et = 1;
      const it = ye(I);
      if ((it.width > X || it.height > X) && (et = X / Math.max(it.width, it.height)), et < 1) if (typeof HTMLImageElement < "u" && I instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && I instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && I instanceof ImageBitmap || typeof VideoFrame < "u" && I instanceof VideoFrame) {
        const rt = Math.floor(et * it.width), St = Math.floor(et * it.height);
        d === void 0 && (d = w(rt, St));
        const ht = x ? w(rt, St) : d;
        return ht.width = rt, ht.height = St, ht.getContext("2d").drawImage(I, 0, 0, rt, St), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + it.width + "x" + it.height + ") to (" + rt + "x" + St + ")."), ht;
      } else return "data" in I && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + it.width + "x" + it.height + ")."), I;
      return I;
    }
    function m(I) {
      return I.generateMipmaps && I.minFilter !== en && I.minFilter !== dn;
    }
    function _(I) {
      r.generateMipmap(I);
    }
    function E(I, x, X, et, it = false) {
      if (I !== null) {
        if (r[I] !== void 0) return r[I];
        console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + I + "'");
      }
      let rt = x;
      if (x === r.RED && (X === r.FLOAT && (rt = r.R32F), X === r.HALF_FLOAT && (rt = r.R16F), X === r.UNSIGNED_BYTE && (rt = r.R8)), x === r.RED_INTEGER && (X === r.UNSIGNED_BYTE && (rt = r.R8UI), X === r.UNSIGNED_SHORT && (rt = r.R16UI), X === r.UNSIGNED_INT && (rt = r.R32UI), X === r.BYTE && (rt = r.R8I), X === r.SHORT && (rt = r.R16I), X === r.INT && (rt = r.R32I)), x === r.RG && (X === r.FLOAT && (rt = r.RG32F), X === r.HALF_FLOAT && (rt = r.RG16F), X === r.UNSIGNED_BYTE && (rt = r.RG8)), x === r.RG_INTEGER && (X === r.UNSIGNED_BYTE && (rt = r.RG8UI), X === r.UNSIGNED_SHORT && (rt = r.RG16UI), X === r.UNSIGNED_INT && (rt = r.RG32UI), X === r.BYTE && (rt = r.RG8I), X === r.SHORT && (rt = r.RG16I), X === r.INT && (rt = r.RG32I)), x === r.RGB && X === r.UNSIGNED_INT_5_9_9_9_REV && (rt = r.RGB9_E5), x === r.RGBA) {
        const St = it ? ma : ie.getTransfer(et);
        X === r.FLOAT && (rt = r.RGBA32F), X === r.HALF_FLOAT && (rt = r.RGBA16F), X === r.UNSIGNED_BYTE && (rt = St === me ? r.SRGB8_ALPHA8 : r.RGBA8), X === r.UNSIGNED_SHORT_4_4_4_4 && (rt = r.RGBA4), X === r.UNSIGNED_SHORT_5_5_5_1 && (rt = r.RGB5_A1);
      }
      return (rt === r.R16F || rt === r.R32F || rt === r.RG16F || rt === r.RG32F || rt === r.RGBA16F || rt === r.RGBA32F) && t.get("EXT_color_buffer_float"), rt;
    }
    function v(I, x) {
      let X;
      return I ? x === null || x === Sr || x === Mr ? X = r.DEPTH24_STENCIL8 : x === Dn ? X = r.DEPTH32F_STENCIL8 : x === _a && (X = r.DEPTH24_STENCIL8, console.warn("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.")) : x === null || x === Sr || x === Mr ? X = r.DEPTH_COMPONENT24 : x === Dn ? X = r.DEPTH_COMPONENT32F : x === _a && (X = r.DEPTH_COMPONENT16), X;
    }
    function T(I, x) {
      return m(I) === true || I.isFramebufferTexture && I.minFilter !== en && I.minFilter !== dn ? Math.log2(Math.max(x.width, x.height)) + 1 : I.mipmaps !== void 0 && I.mipmaps.length > 0 ? I.mipmaps.length : I.isCompressedTexture && Array.isArray(I.image) ? x.mipmaps.length : 1;
    }
    function O(I) {
      const x = I.target;
      x.removeEventListener("dispose", O), P(x), x.isVideoTexture && h.delete(x);
    }
    function R(I) {
      const x = I.target;
      x.removeEventListener("dispose", R), A(x);
    }
    function P(I) {
      const x = n.get(I);
      if (x.__webglInit === void 0) return;
      const X = I.source, et = u.get(X);
      if (et) {
        const it = et[x.__cacheKey];
        it.usedTimes--, it.usedTimes === 0 && z(I), Object.keys(et).length === 0 && u.delete(X);
      }
      n.remove(I);
    }
    function z(I) {
      const x = n.get(I);
      r.deleteTexture(x.__webglTexture);
      const X = I.source, et = u.get(X);
      delete et[x.__cacheKey], a.memory.textures--;
    }
    function A(I) {
      const x = n.get(I);
      if (I.depthTexture && I.depthTexture.dispose(), I.isWebGLCubeRenderTarget) for (let et = 0; et < 6; et++) {
        if (Array.isArray(x.__webglFramebuffer[et])) for (let it = 0; it < x.__webglFramebuffer[et].length; it++) r.deleteFramebuffer(x.__webglFramebuffer[et][it]);
        else r.deleteFramebuffer(x.__webglFramebuffer[et]);
        x.__webglDepthbuffer && r.deleteRenderbuffer(x.__webglDepthbuffer[et]);
      }
      else {
        if (Array.isArray(x.__webglFramebuffer)) for (let et = 0; et < x.__webglFramebuffer.length; et++) r.deleteFramebuffer(x.__webglFramebuffer[et]);
        else r.deleteFramebuffer(x.__webglFramebuffer);
        if (x.__webglDepthbuffer && r.deleteRenderbuffer(x.__webglDepthbuffer), x.__webglMultisampledFramebuffer && r.deleteFramebuffer(x.__webglMultisampledFramebuffer), x.__webglColorRenderbuffer) for (let et = 0; et < x.__webglColorRenderbuffer.length; et++) x.__webglColorRenderbuffer[et] && r.deleteRenderbuffer(x.__webglColorRenderbuffer[et]);
        x.__webglDepthRenderbuffer && r.deleteRenderbuffer(x.__webglDepthRenderbuffer);
      }
      const X = I.textures;
      for (let et = 0, it = X.length; et < it; et++) {
        const rt = n.get(X[et]);
        rt.__webglTexture && (r.deleteTexture(rt.__webglTexture), a.memory.textures--), n.remove(X[et]);
      }
      n.remove(I);
    }
    let S = 0;
    function F() {
      S = 0;
    }
    function W() {
      const I = S;
      return I >= i.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + I + " texture units while this GPU supports only " + i.maxTextures), S += 1, I;
    }
    function V(I) {
      const x = [];
      return x.push(I.wrapS), x.push(I.wrapT), x.push(I.wrapR || 0), x.push(I.magFilter), x.push(I.minFilter), x.push(I.anisotropy), x.push(I.internalFormat), x.push(I.format), x.push(I.type), x.push(I.generateMipmaps), x.push(I.premultiplyAlpha), x.push(I.flipY), x.push(I.unpackAlignment), x.push(I.colorSpace), x.join();
    }
    function Z(I, x) {
      const X = n.get(I);
      if (I.isVideoTexture && Xt(I), I.isRenderTargetTexture === false && I.version > 0 && X.__version !== I.version) {
        const et = I.image;
        if (et === null) console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
        else if (et.complete === false) console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
        else {
          ee(X, I, x);
          return;
        }
      }
      e.bindTexture(r.TEXTURE_2D, X.__webglTexture, r.TEXTURE0 + x);
    }
    function tt(I, x) {
      const X = n.get(I);
      if (I.version > 0 && X.__version !== I.version) {
        ee(X, I, x);
        return;
      }
      e.bindTexture(r.TEXTURE_2D_ARRAY, X.__webglTexture, r.TEXTURE0 + x);
    }
    function Y(I, x) {
      const X = n.get(I);
      if (I.version > 0 && X.__version !== I.version) {
        ee(X, I, x);
        return;
      }
      e.bindTexture(r.TEXTURE_3D, X.__webglTexture, r.TEXTURE0 + x);
    }
    function J(I, x) {
      const X = n.get(I);
      if (I.version > 0 && X.__version !== I.version) {
        Q(X, I, x);
        return;
      }
      e.bindTexture(r.TEXTURE_CUBE_MAP, X.__webglTexture, r.TEXTURE0 + x);
    }
    const $ = {
      [Oi]: r.REPEAT,
      [wi]: r.CLAMP_TO_EDGE,
      [fa]: r.MIRRORED_REPEAT
    }, ut = {
      [en]: r.NEAREST,
      [du]: r.NEAREST_MIPMAP_NEAREST,
      [ts]: r.NEAREST_MIPMAP_LINEAR,
      [dn]: r.LINEAR,
      [da]: r.LINEAR_MIPMAP_NEAREST,
      [Zn]: r.LINEAR_MIPMAP_LINEAR
    }, mt = {
      [ff]: r.NEVER,
      [yf]: r.ALWAYS,
      [_f]: r.LESS,
      [vu]: r.LEQUAL,
      [mf]: r.EQUAL,
      [bf]: r.GEQUAL,
      [gf]: r.GREATER,
      [wf]: r.NOTEQUAL
    };
    function gt(I, x) {
      if (x.type === Dn && t.has("OES_texture_float_linear") === false && (x.magFilter === dn || x.magFilter === da || x.magFilter === ts || x.magFilter === Zn || x.minFilter === dn || x.minFilter === da || x.minFilter === ts || x.minFilter === Zn) && console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."), r.texParameteri(I, r.TEXTURE_WRAP_S, $[x.wrapS]), r.texParameteri(I, r.TEXTURE_WRAP_T, $[x.wrapT]), (I === r.TEXTURE_3D || I === r.TEXTURE_2D_ARRAY) && r.texParameteri(I, r.TEXTURE_WRAP_R, $[x.wrapR]), r.texParameteri(I, r.TEXTURE_MAG_FILTER, ut[x.magFilter]), r.texParameteri(I, r.TEXTURE_MIN_FILTER, ut[x.minFilter]), x.compareFunction && (r.texParameteri(I, r.TEXTURE_COMPARE_MODE, r.COMPARE_REF_TO_TEXTURE), r.texParameteri(I, r.TEXTURE_COMPARE_FUNC, mt[x.compareFunction])), t.has("EXT_texture_filter_anisotropic") === true) {
        if (x.magFilter === en || x.minFilter !== ts && x.minFilter !== Zn || x.type === Dn && t.has("OES_texture_float_linear") === false) return;
        if (x.anisotropy > 1 || n.get(x).__currentAnisotropy) {
          const X = t.get("EXT_texture_filter_anisotropic");
          r.texParameterf(I, X.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(x.anisotropy, i.getMaxAnisotropy())), n.get(x).__currentAnisotropy = x.anisotropy;
        }
      }
    }
    function qt(I, x) {
      let X = false;
      I.__webglInit === void 0 && (I.__webglInit = true, x.addEventListener("dispose", O));
      const et = x.source;
      let it = u.get(et);
      it === void 0 && (it = {}, u.set(et, it));
      const rt = V(x);
      if (rt !== I.__cacheKey) {
        it[rt] === void 0 && (it[rt] = {
          texture: r.createTexture(),
          usedTimes: 0
        }, a.memory.textures++, X = true), it[rt].usedTimes++;
        const St = it[I.__cacheKey];
        St !== void 0 && (it[I.__cacheKey].usedTimes--, St.usedTimes === 0 && z(x)), I.__cacheKey = rt, I.__webglTexture = it[rt].texture;
      }
      return X;
    }
    function ee(I, x, X) {
      let et = r.TEXTURE_2D;
      (x.isDataArrayTexture || x.isCompressedArrayTexture) && (et = r.TEXTURE_2D_ARRAY), x.isData3DTexture && (et = r.TEXTURE_3D);
      const it = qt(I, x), rt = x.source;
      e.bindTexture(et, I.__webglTexture, r.TEXTURE0 + X);
      const St = n.get(rt);
      if (rt.version !== St.__version || it === true) {
        e.activeTexture(r.TEXTURE0 + X);
        const ht = ie.getPrimaries(ie.workingColorSpace), ct = x.colorSpace === gi ? null : ie.getPrimaries(x.colorSpace), Ot = x.colorSpace === gi || ht === ct ? r.NONE : r.BROWSER_DEFAULT_WEBGL;
        r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL, x.flipY), r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, x.premultiplyAlpha), r.pixelStorei(r.UNPACK_ALIGNMENT, x.unpackAlignment), r.pixelStorei(r.UNPACK_COLORSPACE_CONVERSION_WEBGL, Ot);
        let at = b(x.image, false, i.maxTextureSize);
        at = Ft(x, at);
        const bt = s.convert(x.format, x.colorSpace), Zt = s.convert(x.type);
        let Pt = E(x.internalFormat, bt, Zt, x.colorSpace, x.isVideoTexture);
        gt(et, x);
        let pt;
        const Bt = x.mipmaps, zt = x.isVideoTexture !== true, xe = St.__version === void 0 || it === true, y = rt.dataReady, q = T(x, at);
        if (x.isDepthTexture) Pt = v(x.format === Er, x.type), xe && (zt ? e.texStorage2D(r.TEXTURE_2D, 1, Pt, at.width, at.height) : e.texImage2D(r.TEXTURE_2D, 0, Pt, at.width, at.height, 0, bt, Zt, null));
        else if (x.isDataTexture) if (Bt.length > 0) {
          zt && xe && e.texStorage2D(r.TEXTURE_2D, q, Pt, Bt[0].width, Bt[0].height);
          for (let H = 0, K = Bt.length; H < K; H++) pt = Bt[H], zt ? y && e.texSubImage2D(r.TEXTURE_2D, H, 0, 0, pt.width, pt.height, bt, Zt, pt.data) : e.texImage2D(r.TEXTURE_2D, H, Pt, pt.width, pt.height, 0, bt, Zt, pt.data);
          x.generateMipmaps = false;
        } else zt ? (xe && e.texStorage2D(r.TEXTURE_2D, q, Pt, at.width, at.height), y && e.texSubImage2D(r.TEXTURE_2D, 0, 0, 0, at.width, at.height, bt, Zt, at.data)) : e.texImage2D(r.TEXTURE_2D, 0, Pt, at.width, at.height, 0, bt, Zt, at.data);
        else if (x.isCompressedTexture) if (x.isCompressedArrayTexture) {
          zt && xe && e.texStorage3D(r.TEXTURE_2D_ARRAY, q, Pt, Bt[0].width, Bt[0].height, at.depth);
          for (let H = 0, K = Bt.length; H < K; H++) if (pt = Bt[H], x.format !== Tn) if (bt !== null) if (zt) {
            if (y) if (x.layerUpdates.size > 0) {
              for (const nt of x.layerUpdates) {
                const Mt = pt.width * pt.height;
                e.compressedTexSubImage3D(r.TEXTURE_2D_ARRAY, H, 0, 0, nt, pt.width, pt.height, 1, bt, pt.data.slice(Mt * nt, Mt * (nt + 1)), 0, 0);
              }
              x.clearLayerUpdates();
            } else e.compressedTexSubImage3D(r.TEXTURE_2D_ARRAY, H, 0, 0, 0, pt.width, pt.height, at.depth, bt, pt.data, 0, 0);
          } else e.compressedTexImage3D(r.TEXTURE_2D_ARRAY, H, Pt, pt.width, pt.height, at.depth, 0, pt.data, 0, 0);
          else console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
          else zt ? y && e.texSubImage3D(r.TEXTURE_2D_ARRAY, H, 0, 0, 0, pt.width, pt.height, at.depth, bt, Zt, pt.data) : e.texImage3D(r.TEXTURE_2D_ARRAY, H, Pt, pt.width, pt.height, at.depth, 0, bt, Zt, pt.data);
        } else {
          zt && xe && e.texStorage2D(r.TEXTURE_2D, q, Pt, Bt[0].width, Bt[0].height);
          for (let H = 0, K = Bt.length; H < K; H++) pt = Bt[H], x.format !== Tn ? bt !== null ? zt ? y && e.compressedTexSubImage2D(r.TEXTURE_2D, H, 0, 0, pt.width, pt.height, bt, pt.data) : e.compressedTexImage2D(r.TEXTURE_2D, H, Pt, pt.width, pt.height, 0, pt.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : zt ? y && e.texSubImage2D(r.TEXTURE_2D, H, 0, 0, pt.width, pt.height, bt, Zt, pt.data) : e.texImage2D(r.TEXTURE_2D, H, Pt, pt.width, pt.height, 0, bt, Zt, pt.data);
        }
        else if (x.isDataArrayTexture) if (zt) {
          if (xe && e.texStorage3D(r.TEXTURE_2D_ARRAY, q, Pt, at.width, at.height, at.depth), y) if (x.layerUpdates.size > 0) {
            let H;
            switch (Zt) {
              case r.UNSIGNED_BYTE:
                switch (bt) {
                  case r.ALPHA:
                    H = 1;
                    break;
                  case r.LUMINANCE:
                    H = 1;
                    break;
                  case r.LUMINANCE_ALPHA:
                    H = 2;
                    break;
                  case r.RGB:
                    H = 3;
                    break;
                  case r.RGBA:
                    H = 4;
                    break;
                  default:
                    throw new Error(`Unknown texel size for format ${bt}.`);
                }
                break;
              case r.UNSIGNED_SHORT_4_4_4_4:
              case r.UNSIGNED_SHORT_5_5_5_1:
              case r.UNSIGNED_SHORT_5_6_5:
                H = 1;
                break;
              default:
                throw new Error(`Unknown texel size for type ${Zt}.`);
            }
            const K = at.width * at.height * H;
            for (const nt of x.layerUpdates) e.texSubImage3D(r.TEXTURE_2D_ARRAY, 0, 0, 0, nt, at.width, at.height, 1, bt, Zt, at.data.slice(K * nt, K * (nt + 1)));
            x.clearLayerUpdates();
          } else e.texSubImage3D(r.TEXTURE_2D_ARRAY, 0, 0, 0, 0, at.width, at.height, at.depth, bt, Zt, at.data);
        } else e.texImage3D(r.TEXTURE_2D_ARRAY, 0, Pt, at.width, at.height, at.depth, 0, bt, Zt, at.data);
        else if (x.isData3DTexture) zt ? (xe && e.texStorage3D(r.TEXTURE_3D, q, Pt, at.width, at.height, at.depth), y && e.texSubImage3D(r.TEXTURE_3D, 0, 0, 0, 0, at.width, at.height, at.depth, bt, Zt, at.data)) : e.texImage3D(r.TEXTURE_3D, 0, Pt, at.width, at.height, at.depth, 0, bt, Zt, at.data);
        else if (x.isFramebufferTexture) {
          if (xe) if (zt) e.texStorage2D(r.TEXTURE_2D, q, Pt, at.width, at.height);
          else {
            let H = at.width, K = at.height;
            for (let nt = 0; nt < q; nt++) e.texImage2D(r.TEXTURE_2D, nt, Pt, H, K, 0, bt, Zt, null), H >>= 1, K >>= 1;
          }
        } else if (Bt.length > 0) {
          if (zt && xe) {
            const H = ye(Bt[0]);
            e.texStorage2D(r.TEXTURE_2D, q, Pt, H.width, H.height);
          }
          for (let H = 0, K = Bt.length; H < K; H++) pt = Bt[H], zt ? y && e.texSubImage2D(r.TEXTURE_2D, H, 0, 0, bt, Zt, pt) : e.texImage2D(r.TEXTURE_2D, H, Pt, bt, Zt, pt);
          x.generateMipmaps = false;
        } else if (zt) {
          if (xe) {
            const H = ye(at);
            e.texStorage2D(r.TEXTURE_2D, q, Pt, H.width, H.height);
          }
          y && e.texSubImage2D(r.TEXTURE_2D, 0, 0, 0, bt, Zt, at);
        } else e.texImage2D(r.TEXTURE_2D, 0, Pt, bt, Zt, at);
        m(x) && _(et), St.__version = rt.version, x.onUpdate && x.onUpdate(x);
      }
      I.__version = x.version;
    }
    function Q(I, x, X) {
      if (x.image.length !== 6) return;
      const et = qt(I, x), it = x.source;
      e.bindTexture(r.TEXTURE_CUBE_MAP, I.__webglTexture, r.TEXTURE0 + X);
      const rt = n.get(it);
      if (it.version !== rt.__version || et === true) {
        e.activeTexture(r.TEXTURE0 + X);
        const St = ie.getPrimaries(ie.workingColorSpace), ht = x.colorSpace === gi ? null : ie.getPrimaries(x.colorSpace), ct = x.colorSpace === gi || St === ht ? r.NONE : r.BROWSER_DEFAULT_WEBGL;
        r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL, x.flipY), r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, x.premultiplyAlpha), r.pixelStorei(r.UNPACK_ALIGNMENT, x.unpackAlignment), r.pixelStorei(r.UNPACK_COLORSPACE_CONVERSION_WEBGL, ct);
        const Ot = x.isCompressedTexture || x.image[0].isCompressedTexture, at = x.image[0] && x.image[0].isDataTexture, bt = [];
        for (let K = 0; K < 6; K++) !Ot && !at ? bt[K] = b(x.image[K], true, i.maxCubemapSize) : bt[K] = at ? x.image[K].image : x.image[K], bt[K] = Ft(x, bt[K]);
        const Zt = bt[0], Pt = s.convert(x.format, x.colorSpace), pt = s.convert(x.type), Bt = E(x.internalFormat, Pt, pt, x.colorSpace), zt = x.isVideoTexture !== true, xe = rt.__version === void 0 || et === true, y = it.dataReady;
        let q = T(x, Zt);
        gt(r.TEXTURE_CUBE_MAP, x);
        let H;
        if (Ot) {
          zt && xe && e.texStorage2D(r.TEXTURE_CUBE_MAP, q, Bt, Zt.width, Zt.height);
          for (let K = 0; K < 6; K++) {
            H = bt[K].mipmaps;
            for (let nt = 0; nt < H.length; nt++) {
              const Mt = H[nt];
              x.format !== Tn ? Pt !== null ? zt ? y && e.compressedTexSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + K, nt, 0, 0, Mt.width, Mt.height, Pt, Mt.data) : e.compressedTexImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + K, nt, Bt, Mt.width, Mt.height, 0, Mt.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : zt ? y && e.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + K, nt, 0, 0, Mt.width, Mt.height, Pt, pt, Mt.data) : e.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + K, nt, Bt, Mt.width, Mt.height, 0, Pt, pt, Mt.data);
            }
          }
        } else {
          if (H = x.mipmaps, zt && xe) {
            H.length > 0 && q++;
            const K = ye(bt[0]);
            e.texStorage2D(r.TEXTURE_CUBE_MAP, q, Bt, K.width, K.height);
          }
          for (let K = 0; K < 6; K++) if (at) {
            zt ? y && e.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + K, 0, 0, 0, bt[K].width, bt[K].height, Pt, pt, bt[K].data) : e.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + K, 0, Bt, bt[K].width, bt[K].height, 0, Pt, pt, bt[K].data);
            for (let nt = 0; nt < H.length; nt++) {
              const Nt = H[nt].image[K].image;
              zt ? y && e.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + K, nt + 1, 0, 0, Nt.width, Nt.height, Pt, pt, Nt.data) : e.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + K, nt + 1, Bt, Nt.width, Nt.height, 0, Pt, pt, Nt.data);
            }
          } else {
            zt ? y && e.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + K, 0, 0, 0, Pt, pt, bt[K]) : e.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + K, 0, Bt, Pt, pt, bt[K]);
            for (let nt = 0; nt < H.length; nt++) {
              const Mt = H[nt];
              zt ? y && e.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + K, nt + 1, 0, 0, Pt, pt, Mt.image[K]) : e.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + K, nt + 1, Bt, Pt, pt, Mt.image[K]);
            }
          }
        }
        m(x) && _(r.TEXTURE_CUBE_MAP), rt.__version = it.version, x.onUpdate && x.onUpdate(x);
      }
      I.__version = x.version;
    }
    function st(I, x, X, et, it, rt) {
      const St = s.convert(X.format, X.colorSpace), ht = s.convert(X.type), ct = E(X.internalFormat, St, ht, X.colorSpace);
      if (!n.get(x).__hasExternalTextures) {
        const at = Math.max(1, x.width >> rt), bt = Math.max(1, x.height >> rt);
        it === r.TEXTURE_3D || it === r.TEXTURE_2D_ARRAY ? e.texImage3D(it, rt, ct, at, bt, x.depth, 0, St, ht, null) : e.texImage2D(it, rt, ct, at, bt, 0, St, ht, null);
      }
      e.bindFramebuffer(r.FRAMEBUFFER, I), Qt(x) ? o.framebufferTexture2DMultisampleEXT(r.FRAMEBUFFER, et, it, n.get(X).__webglTexture, 0, At(x)) : (it === r.TEXTURE_2D || it >= r.TEXTURE_CUBE_MAP_POSITIVE_X && it <= r.TEXTURE_CUBE_MAP_NEGATIVE_Z) && r.framebufferTexture2D(r.FRAMEBUFFER, et, it, n.get(X).__webglTexture, rt), e.bindFramebuffer(r.FRAMEBUFFER, null);
    }
    function _t(I, x, X) {
      if (r.bindRenderbuffer(r.RENDERBUFFER, I), x.depthBuffer) {
        const et = x.depthTexture, it = et && et.isDepthTexture ? et.type : null, rt = v(x.stencilBuffer, it), St = x.stencilBuffer ? r.DEPTH_STENCIL_ATTACHMENT : r.DEPTH_ATTACHMENT, ht = At(x);
        Qt(x) ? o.renderbufferStorageMultisampleEXT(r.RENDERBUFFER, ht, rt, x.width, x.height) : X ? r.renderbufferStorageMultisample(r.RENDERBUFFER, ht, rt, x.width, x.height) : r.renderbufferStorage(r.RENDERBUFFER, rt, x.width, x.height), r.framebufferRenderbuffer(r.FRAMEBUFFER, St, r.RENDERBUFFER, I);
      } else {
        const et = x.textures;
        for (let it = 0; it < et.length; it++) {
          const rt = et[it], St = s.convert(rt.format, rt.colorSpace), ht = s.convert(rt.type), ct = E(rt.internalFormat, St, ht, rt.colorSpace), Ot = At(x);
          X && Qt(x) === false ? r.renderbufferStorageMultisample(r.RENDERBUFFER, Ot, ct, x.width, x.height) : Qt(x) ? o.renderbufferStorageMultisampleEXT(r.RENDERBUFFER, Ot, ct, x.width, x.height) : r.renderbufferStorage(r.RENDERBUFFER, ct, x.width, x.height);
        }
      }
      r.bindRenderbuffer(r.RENDERBUFFER, null);
    }
    function lt(I, x) {
      if (x && x.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
      if (e.bindFramebuffer(r.FRAMEBUFFER, I), !(x.depthTexture && x.depthTexture.isDepthTexture)) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
      (!n.get(x.depthTexture).__webglTexture || x.depthTexture.image.width !== x.width || x.depthTexture.image.height !== x.height) && (x.depthTexture.image.width = x.width, x.depthTexture.image.height = x.height, x.depthTexture.needsUpdate = true), Z(x.depthTexture, 0);
      const et = n.get(x.depthTexture).__webglTexture, it = At(x);
      if (x.depthTexture.format === wr) Qt(x) ? o.framebufferTexture2DMultisampleEXT(r.FRAMEBUFFER, r.DEPTH_ATTACHMENT, r.TEXTURE_2D, et, 0, it) : r.framebufferTexture2D(r.FRAMEBUFFER, r.DEPTH_ATTACHMENT, r.TEXTURE_2D, et, 0);
      else if (x.depthTexture.format === Er) Qt(x) ? o.framebufferTexture2DMultisampleEXT(r.FRAMEBUFFER, r.DEPTH_STENCIL_ATTACHMENT, r.TEXTURE_2D, et, 0, it) : r.framebufferTexture2D(r.FRAMEBUFFER, r.DEPTH_STENCIL_ATTACHMENT, r.TEXTURE_2D, et, 0);
      else throw new Error("Unknown depthTexture format");
    }
    function kt(I) {
      const x = n.get(I), X = I.isWebGLCubeRenderTarget === true;
      if (I.depthTexture && !x.__autoAllocateDepthBuffer) {
        if (X) throw new Error("target.depthTexture not supported in Cube render targets");
        lt(x.__webglFramebuffer, I);
      } else if (X) {
        x.__webglDepthbuffer = [];
        for (let et = 0; et < 6; et++) e.bindFramebuffer(r.FRAMEBUFFER, x.__webglFramebuffer[et]), x.__webglDepthbuffer[et] = r.createRenderbuffer(), _t(x.__webglDepthbuffer[et], I, false);
      } else e.bindFramebuffer(r.FRAMEBUFFER, x.__webglFramebuffer), x.__webglDepthbuffer = r.createRenderbuffer(), _t(x.__webglDepthbuffer, I, false);
      e.bindFramebuffer(r.FRAMEBUFFER, null);
    }
    function Dt(I, x, X) {
      const et = n.get(I);
      x !== void 0 && st(et.__webglFramebuffer, I, I.texture, r.COLOR_ATTACHMENT0, r.TEXTURE_2D, 0), X !== void 0 && kt(I);
    }
    function Kt(I) {
      const x = I.texture, X = n.get(I), et = n.get(x);
      I.addEventListener("dispose", R);
      const it = I.textures, rt = I.isWebGLCubeRenderTarget === true, St = it.length > 1;
      if (St || (et.__webglTexture === void 0 && (et.__webglTexture = r.createTexture()), et.__version = x.version, a.memory.textures++), rt) {
        X.__webglFramebuffer = [];
        for (let ht = 0; ht < 6; ht++) if (x.mipmaps && x.mipmaps.length > 0) {
          X.__webglFramebuffer[ht] = [];
          for (let ct = 0; ct < x.mipmaps.length; ct++) X.__webglFramebuffer[ht][ct] = r.createFramebuffer();
        } else X.__webglFramebuffer[ht] = r.createFramebuffer();
      } else {
        if (x.mipmaps && x.mipmaps.length > 0) {
          X.__webglFramebuffer = [];
          for (let ht = 0; ht < x.mipmaps.length; ht++) X.__webglFramebuffer[ht] = r.createFramebuffer();
        } else X.__webglFramebuffer = r.createFramebuffer();
        if (St) for (let ht = 0, ct = it.length; ht < ct; ht++) {
          const Ot = n.get(it[ht]);
          Ot.__webglTexture === void 0 && (Ot.__webglTexture = r.createTexture(), a.memory.textures++);
        }
        if (I.samples > 0 && Qt(I) === false) {
          X.__webglMultisampledFramebuffer = r.createFramebuffer(), X.__webglColorRenderbuffer = [], e.bindFramebuffer(r.FRAMEBUFFER, X.__webglMultisampledFramebuffer);
          for (let ht = 0; ht < it.length; ht++) {
            const ct = it[ht];
            X.__webglColorRenderbuffer[ht] = r.createRenderbuffer(), r.bindRenderbuffer(r.RENDERBUFFER, X.__webglColorRenderbuffer[ht]);
            const Ot = s.convert(ct.format, ct.colorSpace), at = s.convert(ct.type), bt = E(ct.internalFormat, Ot, at, ct.colorSpace, I.isXRRenderTarget === true), Zt = At(I);
            r.renderbufferStorageMultisample(r.RENDERBUFFER, Zt, bt, I.width, I.height), r.framebufferRenderbuffer(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0 + ht, r.RENDERBUFFER, X.__webglColorRenderbuffer[ht]);
          }
          r.bindRenderbuffer(r.RENDERBUFFER, null), I.depthBuffer && (X.__webglDepthRenderbuffer = r.createRenderbuffer(), _t(X.__webglDepthRenderbuffer, I, true)), e.bindFramebuffer(r.FRAMEBUFFER, null);
        }
      }
      if (rt) {
        e.bindTexture(r.TEXTURE_CUBE_MAP, et.__webglTexture), gt(r.TEXTURE_CUBE_MAP, x);
        for (let ht = 0; ht < 6; ht++) if (x.mipmaps && x.mipmaps.length > 0) for (let ct = 0; ct < x.mipmaps.length; ct++) st(X.__webglFramebuffer[ht][ct], I, x, r.COLOR_ATTACHMENT0, r.TEXTURE_CUBE_MAP_POSITIVE_X + ht, ct);
        else st(X.__webglFramebuffer[ht], I, x, r.COLOR_ATTACHMENT0, r.TEXTURE_CUBE_MAP_POSITIVE_X + ht, 0);
        m(x) && _(r.TEXTURE_CUBE_MAP), e.unbindTexture();
      } else if (St) {
        for (let ht = 0, ct = it.length; ht < ct; ht++) {
          const Ot = it[ht], at = n.get(Ot);
          e.bindTexture(r.TEXTURE_2D, at.__webglTexture), gt(r.TEXTURE_2D, Ot), st(X.__webglFramebuffer, I, Ot, r.COLOR_ATTACHMENT0 + ht, r.TEXTURE_2D, 0), m(Ot) && _(r.TEXTURE_2D);
        }
        e.unbindTexture();
      } else {
        let ht = r.TEXTURE_2D;
        if ((I.isWebGL3DRenderTarget || I.isWebGLArrayRenderTarget) && (ht = I.isWebGL3DRenderTarget ? r.TEXTURE_3D : r.TEXTURE_2D_ARRAY), e.bindTexture(ht, et.__webglTexture), gt(ht, x), x.mipmaps && x.mipmaps.length > 0) for (let ct = 0; ct < x.mipmaps.length; ct++) st(X.__webglFramebuffer[ct], I, x, r.COLOR_ATTACHMENT0, ht, ct);
        else st(X.__webglFramebuffer, I, x, r.COLOR_ATTACHMENT0, ht, 0);
        m(x) && _(ht), e.unbindTexture();
      }
      I.depthBuffer && kt(I);
    }
    function D(I) {
      const x = I.textures;
      for (let X = 0, et = x.length; X < et; X++) {
        const it = x[X];
        if (m(it)) {
          const rt = I.isWebGLCubeRenderTarget ? r.TEXTURE_CUBE_MAP : r.TEXTURE_2D, St = n.get(it).__webglTexture;
          e.bindTexture(rt, St), _(rt), e.unbindTexture();
        }
      }
    }
    const Yt = [], jt = [];
    function ue(I) {
      if (I.samples > 0) {
        if (Qt(I) === false) {
          const x = I.textures, X = I.width, et = I.height;
          let it = r.COLOR_BUFFER_BIT;
          const rt = I.stencilBuffer ? r.DEPTH_STENCIL_ATTACHMENT : r.DEPTH_ATTACHMENT, St = n.get(I), ht = x.length > 1;
          if (ht) for (let ct = 0; ct < x.length; ct++) e.bindFramebuffer(r.FRAMEBUFFER, St.__webglMultisampledFramebuffer), r.framebufferRenderbuffer(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0 + ct, r.RENDERBUFFER, null), e.bindFramebuffer(r.FRAMEBUFFER, St.__webglFramebuffer), r.framebufferTexture2D(r.DRAW_FRAMEBUFFER, r.COLOR_ATTACHMENT0 + ct, r.TEXTURE_2D, null, 0);
          e.bindFramebuffer(r.READ_FRAMEBUFFER, St.__webglMultisampledFramebuffer), e.bindFramebuffer(r.DRAW_FRAMEBUFFER, St.__webglFramebuffer);
          for (let ct = 0; ct < x.length; ct++) {
            if (I.resolveDepthBuffer && (I.depthBuffer && (it |= r.DEPTH_BUFFER_BIT), I.stencilBuffer && I.resolveStencilBuffer && (it |= r.STENCIL_BUFFER_BIT)), ht) {
              r.framebufferRenderbuffer(r.READ_FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.RENDERBUFFER, St.__webglColorRenderbuffer[ct]);
              const Ot = n.get(x[ct]).__webglTexture;
              r.framebufferTexture2D(r.DRAW_FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.TEXTURE_2D, Ot, 0);
            }
            r.blitFramebuffer(0, 0, X, et, 0, 0, X, et, it, r.NEAREST), c === true && (Yt.length = 0, jt.length = 0, Yt.push(r.COLOR_ATTACHMENT0 + ct), I.depthBuffer && I.resolveDepthBuffer === false && (Yt.push(rt), jt.push(rt), r.invalidateFramebuffer(r.DRAW_FRAMEBUFFER, jt)), r.invalidateFramebuffer(r.READ_FRAMEBUFFER, Yt));
          }
          if (e.bindFramebuffer(r.READ_FRAMEBUFFER, null), e.bindFramebuffer(r.DRAW_FRAMEBUFFER, null), ht) for (let ct = 0; ct < x.length; ct++) {
            e.bindFramebuffer(r.FRAMEBUFFER, St.__webglMultisampledFramebuffer), r.framebufferRenderbuffer(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0 + ct, r.RENDERBUFFER, St.__webglColorRenderbuffer[ct]);
            const Ot = n.get(x[ct]).__webglTexture;
            e.bindFramebuffer(r.FRAMEBUFFER, St.__webglFramebuffer), r.framebufferTexture2D(r.DRAW_FRAMEBUFFER, r.COLOR_ATTACHMENT0 + ct, r.TEXTURE_2D, Ot, 0);
          }
          e.bindFramebuffer(r.DRAW_FRAMEBUFFER, St.__webglMultisampledFramebuffer);
        } else if (I.depthBuffer && I.resolveDepthBuffer === false && c) {
          const x = I.stencilBuffer ? r.DEPTH_STENCIL_ATTACHMENT : r.DEPTH_ATTACHMENT;
          r.invalidateFramebuffer(r.DRAW_FRAMEBUFFER, [
            x
          ]);
        }
      }
    }
    function At(I) {
      return Math.min(i.maxSamples, I.samples);
    }
    function Qt(I) {
      const x = n.get(I);
      return I.samples > 0 && t.has("WEBGL_multisampled_render_to_texture") === true && x.__useRenderToTexture !== false;
    }
    function Xt(I) {
      const x = a.render.frame;
      h.get(I) !== x && (h.set(I, x), I.update());
    }
    function Ft(I, x) {
      const X = I.colorSpace, et = I.format, it = I.type;
      return I.isCompressedTexture === true || I.isVideoTexture === true || X !== je && X !== gi && (ie.getTransfer(X) === me ? (et !== Tn || it !== Si) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", X)), x;
    }
    function ye(I) {
      return typeof HTMLImageElement < "u" && I instanceof HTMLImageElement ? (l.width = I.naturalWidth || I.width, l.height = I.naturalHeight || I.height) : typeof VideoFrame < "u" && I instanceof VideoFrame ? (l.width = I.displayWidth, l.height = I.displayHeight) : (l.width = I.width, l.height = I.height), l;
    }
    this.allocateTextureUnit = W, this.resetTextureUnits = F, this.setTexture2D = Z, this.setTexture2DArray = tt, this.setTexture3D = Y, this.setTextureCube = J, this.rebindTextures = Dt, this.setupRenderTarget = Kt, this.updateRenderTargetMipmap = D, this.updateMultisampleRenderTarget = ue, this.setupDepthRenderbuffer = kt, this.setupFrameBufferTexture = st, this.useMultisampledRTT = Qt;
  }
  function N0(r, t) {
    function e(n, i = gi) {
      let s;
      const a = ie.getTransfer(i);
      if (n === Si) return r.UNSIGNED_BYTE;
      if (n === pu) return r.UNSIGNED_SHORT_4_4_4_4;
      if (n === fu) return r.UNSIGNED_SHORT_5_5_5_1;
      if (n === ef) return r.UNSIGNED_INT_5_9_9_9_REV;
      if (n === Qp) return r.BYTE;
      if (n === tf) return r.SHORT;
      if (n === _a) return r.UNSIGNED_SHORT;
      if (n === uu) return r.INT;
      if (n === Sr) return r.UNSIGNED_INT;
      if (n === Dn) return r.FLOAT;
      if (n === Ba) return r.HALF_FLOAT;
      if (n === nf) return r.ALPHA;
      if (n === rf) return r.RGB;
      if (n === Tn) return r.RGBA;
      if (n === sf) return r.LUMINANCE;
      if (n === af) return r.LUMINANCE_ALPHA;
      if (n === wr) return r.DEPTH_COMPONENT;
      if (n === Er) return r.DEPTH_STENCIL;
      if (n === _u) return r.RED;
      if (n === mu) return r.RED_INTEGER;
      if (n === of) return r.RG;
      if (n === gu) return r.RG_INTEGER;
      if (n === wu) return r.RGBA_INTEGER;
      if (n === yo || n === vo || n === xo || n === So) if (a === me) if (s = t.get("WEBGL_compressed_texture_s3tc_srgb"), s !== null) {
        if (n === yo) return s.COMPRESSED_SRGB_S3TC_DXT1_EXT;
        if (n === vo) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
        if (n === xo) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
        if (n === So) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
      } else return null;
      else if (s = t.get("WEBGL_compressed_texture_s3tc"), s !== null) {
        if (n === yo) return s.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (n === vo) return s.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (n === xo) return s.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (n === So) return s.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else return null;
      if (n === Ol || n === Bl || n === zl || n === kl) if (s = t.get("WEBGL_compressed_texture_pvrtc"), s !== null) {
        if (n === Ol) return s.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (n === Bl) return s.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (n === zl) return s.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (n === kl) return s.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else return null;
      if (n === Hl || n === Gl || n === Vl) if (s = t.get("WEBGL_compressed_texture_etc"), s !== null) {
        if (n === Hl || n === Gl) return a === me ? s.COMPRESSED_SRGB8_ETC2 : s.COMPRESSED_RGB8_ETC2;
        if (n === Vl) return a === me ? s.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : s.COMPRESSED_RGBA8_ETC2_EAC;
      } else return null;
      if (n === Wl || n === jl || n === Xl || n === ql || n === Kl || n === Yl || n === Zl || n === $l || n === Jl || n === Ql || n === th || n === eh || n === nh || n === ih) if (s = t.get("WEBGL_compressed_texture_astc"), s !== null) {
        if (n === Wl) return a === me ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : s.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (n === jl) return a === me ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : s.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (n === Xl) return a === me ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : s.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (n === ql) return a === me ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : s.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (n === Kl) return a === me ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : s.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (n === Yl) return a === me ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : s.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (n === Zl) return a === me ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : s.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (n === $l) return a === me ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : s.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (n === Jl) return a === me ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : s.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (n === Ql) return a === me ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : s.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (n === th) return a === me ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : s.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (n === eh) return a === me ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : s.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (n === nh) return a === me ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : s.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (n === ih) return a === me ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : s.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else return null;
      if (n === Mo || n === rh || n === sh) if (s = t.get("EXT_texture_compression_bptc"), s !== null) {
        if (n === Mo) return a === me ? s.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : s.COMPRESSED_RGBA_BPTC_UNORM_EXT;
        if (n === rh) return s.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
        if (n === sh) return s.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
      } else return null;
      if (n === cf || n === ah || n === oh || n === ch) if (s = t.get("EXT_texture_compression_rgtc"), s !== null) {
        if (n === Mo) return s.COMPRESSED_RED_RGTC1_EXT;
        if (n === ah) return s.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (n === oh) return s.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (n === ch) return s.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      } else return null;
      return n === Mr ? r.UNSIGNED_INT_24_8 : r[n] !== void 0 ? r[n] : null;
    }
    return {
      convert: e
    };
  }
  class U0 extends tn {
    constructor(t = []) {
      super(), this.isArrayCamera = true, this.cameras = t;
    }
  }
  class Ye extends _e {
    constructor() {
      super(), this.isGroup = true, this.type = "Group";
    }
  }
  const F0 = {
    type: "move"
  };
  class Zo {
    constructor() {
      this._targetRay = null, this._grip = null, this._hand = null;
    }
    getHandSpace() {
      return this._hand === null && (this._hand = new Ye(), this._hand.matrixAutoUpdate = false, this._hand.visible = false, this._hand.joints = {}, this._hand.inputState = {
        pinching: false
      }), this._hand;
    }
    getTargetRaySpace() {
      return this._targetRay === null && (this._targetRay = new Ye(), this._targetRay.matrixAutoUpdate = false, this._targetRay.visible = false, this._targetRay.hasLinearVelocity = false, this._targetRay.linearVelocity = new L(), this._targetRay.hasAngularVelocity = false, this._targetRay.angularVelocity = new L()), this._targetRay;
    }
    getGripSpace() {
      return this._grip === null && (this._grip = new Ye(), this._grip.matrixAutoUpdate = false, this._grip.visible = false, this._grip.hasLinearVelocity = false, this._grip.linearVelocity = new L(), this._grip.hasAngularVelocity = false, this._grip.angularVelocity = new L()), this._grip;
    }
    dispatchEvent(t) {
      return this._targetRay !== null && this._targetRay.dispatchEvent(t), this._grip !== null && this._grip.dispatchEvent(t), this._hand !== null && this._hand.dispatchEvent(t), this;
    }
    connect(t) {
      if (t && t.hand) {
        const e = this._hand;
        if (e) for (const n of t.hand.values()) this._getHandJoint(e, n);
      }
      return this.dispatchEvent({
        type: "connected",
        data: t
      }), this;
    }
    disconnect(t) {
      return this.dispatchEvent({
        type: "disconnected",
        data: t
      }), this._targetRay !== null && (this._targetRay.visible = false), this._grip !== null && (this._grip.visible = false), this._hand !== null && (this._hand.visible = false), this;
    }
    update(t, e, n) {
      let i = null, s = null, a = null;
      const o = this._targetRay, c = this._grip, l = this._hand;
      if (t && e.session.visibilityState !== "visible-blurred") {
        if (l && t.hand) {
          a = true;
          for (const b of t.hand.values()) {
            const m = e.getJointPose(b, n), _ = this._getHandJoint(l, b);
            m !== null && (_.matrix.fromArray(m.transform.matrix), _.matrix.decompose(_.position, _.rotation, _.scale), _.matrixWorldNeedsUpdate = true, _.jointRadius = m.radius), _.visible = m !== null;
          }
          const h = l.joints["index-finger-tip"], d = l.joints["thumb-tip"], u = h.position.distanceTo(d.position), p = 0.02, w = 5e-3;
          l.inputState.pinching && u > p + w ? (l.inputState.pinching = false, this.dispatchEvent({
            type: "pinchend",
            handedness: t.handedness,
            target: this
          })) : !l.inputState.pinching && u <= p - w && (l.inputState.pinching = true, this.dispatchEvent({
            type: "pinchstart",
            handedness: t.handedness,
            target: this
          }));
        } else c !== null && t.gripSpace && (s = e.getPose(t.gripSpace, n), s !== null && (c.matrix.fromArray(s.transform.matrix), c.matrix.decompose(c.position, c.rotation, c.scale), c.matrixWorldNeedsUpdate = true, s.linearVelocity ? (c.hasLinearVelocity = true, c.linearVelocity.copy(s.linearVelocity)) : c.hasLinearVelocity = false, s.angularVelocity ? (c.hasAngularVelocity = true, c.angularVelocity.copy(s.angularVelocity)) : c.hasAngularVelocity = false));
        o !== null && (i = e.getPose(t.targetRaySpace, n), i === null && s !== null && (i = s), i !== null && (o.matrix.fromArray(i.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale), o.matrixWorldNeedsUpdate = true, i.linearVelocity ? (o.hasLinearVelocity = true, o.linearVelocity.copy(i.linearVelocity)) : o.hasLinearVelocity = false, i.angularVelocity ? (o.hasAngularVelocity = true, o.angularVelocity.copy(i.angularVelocity)) : o.hasAngularVelocity = false, this.dispatchEvent(F0)));
      }
      return o !== null && (o.visible = i !== null), c !== null && (c.visible = s !== null), l !== null && (l.visible = a !== null), this;
    }
    _getHandJoint(t, e) {
      if (t.joints[e.jointName] === void 0) {
        const n = new Ye();
        n.matrixAutoUpdate = false, n.visible = false, t.joints[e.jointName] = n, t.add(n);
      }
      return t.joints[e.jointName];
    }
  }
  const O0 = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`, B0 = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
  class z0 {
    constructor() {
      this.texture = null, this.mesh = null, this.depthNear = 0, this.depthFar = 0;
    }
    init(t, e, n) {
      if (this.texture === null) {
        const i = new Ne(), s = t.properties.get(i);
        s.__webglTexture = e.texture, (e.depthNear != n.depthNear || e.depthFar != n.depthFar) && (this.depthNear = e.depthNear, this.depthFar = e.depthFar), this.texture = i;
      }
    }
    getMesh(t) {
      if (this.texture !== null && this.mesh === null) {
        const e = t.cameras[0].viewport, n = new Qn({
          vertexShader: O0,
          fragmentShader: B0,
          uniforms: {
            depthColor: {
              value: this.texture
            },
            depthWidth: {
              value: e.z
            },
            depthHeight: {
              value: e.w
            }
          }
        });
        this.mesh = new fe(new ys(20, 20), n);
      }
      return this.mesh;
    }
    reset() {
      this.texture = null, this.mesh = null;
    }
  }
  class k0 extends Gi {
    constructor(t, e) {
      super();
      const n = this;
      let i = null, s = 1, a = null, o = "local-floor", c = 1, l = null, h = null, d = null, u = null, p = null, w = null;
      const b = new z0(), m = e.getContextAttributes();
      let _ = null, E = null;
      const v = [], T = [], O = new vt();
      let R = null;
      const P = new tn();
      P.layers.enable(1), P.viewport = new de();
      const z = new tn();
      z.layers.enable(2), z.viewport = new de();
      const A = [
        P,
        z
      ], S = new U0();
      S.layers.enable(1), S.layers.enable(2);
      let F = null, W = null;
      this.cameraAutoUpdate = true, this.enabled = false, this.isPresenting = false, this.getController = function(Q) {
        let st = v[Q];
        return st === void 0 && (st = new Zo(), v[Q] = st), st.getTargetRaySpace();
      }, this.getControllerGrip = function(Q) {
        let st = v[Q];
        return st === void 0 && (st = new Zo(), v[Q] = st), st.getGripSpace();
      }, this.getHand = function(Q) {
        let st = v[Q];
        return st === void 0 && (st = new Zo(), v[Q] = st), st.getHandSpace();
      };
      function V(Q) {
        const st = T.indexOf(Q.inputSource);
        if (st === -1) return;
        const _t = v[st];
        _t !== void 0 && (_t.update(Q.inputSource, Q.frame, l || a), _t.dispatchEvent({
          type: Q.type,
          data: Q.inputSource
        }));
      }
      function Z() {
        i.removeEventListener("select", V), i.removeEventListener("selectstart", V), i.removeEventListener("selectend", V), i.removeEventListener("squeeze", V), i.removeEventListener("squeezestart", V), i.removeEventListener("squeezeend", V), i.removeEventListener("end", Z), i.removeEventListener("inputsourceschange", tt);
        for (let Q = 0; Q < v.length; Q++) {
          const st = T[Q];
          st !== null && (T[Q] = null, v[Q].disconnect(st));
        }
        F = null, W = null, b.reset(), t.setRenderTarget(_), p = null, u = null, d = null, i = null, E = null, ee.stop(), n.isPresenting = false, t.setPixelRatio(R), t.setSize(O.width, O.height, false), n.dispatchEvent({
          type: "sessionend"
        });
      }
      this.setFramebufferScaleFactor = function(Q) {
        s = Q, n.isPresenting === true && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
      }, this.setReferenceSpaceType = function(Q) {
        o = Q, n.isPresenting === true && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
      }, this.getReferenceSpace = function() {
        return l || a;
      }, this.setReferenceSpace = function(Q) {
        l = Q;
      }, this.getBaseLayer = function() {
        return u !== null ? u : p;
      }, this.getBinding = function() {
        return d;
      }, this.getFrame = function() {
        return w;
      }, this.getSession = function() {
        return i;
      }, this.setSession = async function(Q) {
        if (i = Q, i !== null) {
          if (_ = t.getRenderTarget(), i.addEventListener("select", V), i.addEventListener("selectstart", V), i.addEventListener("selectend", V), i.addEventListener("squeeze", V), i.addEventListener("squeezestart", V), i.addEventListener("squeezeend", V), i.addEventListener("end", Z), i.addEventListener("inputsourceschange", tt), m.xrCompatible !== true && await e.makeXRCompatible(), R = t.getPixelRatio(), t.getSize(O), i.renderState.layers === void 0) {
            const st = {
              antialias: m.antialias,
              alpha: true,
              depth: m.depth,
              stencil: m.stencil,
              framebufferScaleFactor: s
            };
            p = new XRWebGLLayer(i, e, st), i.updateRenderState({
              baseLayer: p
            }), t.setPixelRatio(1), t.setSize(p.framebufferWidth, p.framebufferHeight, false), E = new Bi(p.framebufferWidth, p.framebufferHeight, {
              format: Tn,
              type: Si,
              colorSpace: t.outputColorSpace,
              stencilBuffer: m.stencil
            });
          } else {
            let st = null, _t = null, lt = null;
            m.depth && (lt = m.stencil ? e.DEPTH24_STENCIL8 : e.DEPTH_COMPONENT24, st = m.stencil ? Er : wr, _t = m.stencil ? Mr : Sr);
            const kt = {
              colorFormat: e.RGBA8,
              depthFormat: lt,
              scaleFactor: s
            };
            d = new XRWebGLBinding(i, e), u = d.createProjectionLayer(kt), i.updateRenderState({
              layers: [
                u
              ]
            }), t.setPixelRatio(1), t.setSize(u.textureWidth, u.textureHeight, false), E = new Bi(u.textureWidth, u.textureHeight, {
              format: Tn,
              type: Si,
              depthTexture: new Uu(u.textureWidth, u.textureHeight, _t, void 0, void 0, void 0, void 0, void 0, void 0, st),
              stencilBuffer: m.stencil,
              colorSpace: t.outputColorSpace,
              samples: m.antialias ? 4 : 0,
              resolveDepthBuffer: u.ignoreDepthValues === false
            });
          }
          E.isXRRenderTarget = true, this.setFoveation(c), l = null, a = await i.requestReferenceSpace(o), ee.setContext(i), ee.start(), n.isPresenting = true, n.dispatchEvent({
            type: "sessionstart"
          });
        }
      }, this.getEnvironmentBlendMode = function() {
        if (i !== null) return i.environmentBlendMode;
      };
      function tt(Q) {
        for (let st = 0; st < Q.removed.length; st++) {
          const _t = Q.removed[st], lt = T.indexOf(_t);
          lt >= 0 && (T[lt] = null, v[lt].disconnect(_t));
        }
        for (let st = 0; st < Q.added.length; st++) {
          const _t = Q.added[st];
          let lt = T.indexOf(_t);
          if (lt === -1) {
            for (let Dt = 0; Dt < v.length; Dt++) if (Dt >= T.length) {
              T.push(_t), lt = Dt;
              break;
            } else if (T[Dt] === null) {
              T[Dt] = _t, lt = Dt;
              break;
            }
            if (lt === -1) break;
          }
          const kt = v[lt];
          kt && kt.connect(_t);
        }
      }
      const Y = new L(), J = new L();
      function $(Q, st, _t) {
        Y.setFromMatrixPosition(st.matrixWorld), J.setFromMatrixPosition(_t.matrixWorld);
        const lt = Y.distanceTo(J), kt = st.projectionMatrix.elements, Dt = _t.projectionMatrix.elements, Kt = kt[14] / (kt[10] - 1), D = kt[14] / (kt[10] + 1), Yt = (kt[9] + 1) / kt[5], jt = (kt[9] - 1) / kt[5], ue = (kt[8] - 1) / kt[0], At = (Dt[8] + 1) / Dt[0], Qt = Kt * ue, Xt = Kt * At, Ft = lt / (-ue + At), ye = Ft * -ue;
        st.matrixWorld.decompose(Q.position, Q.quaternion, Q.scale), Q.translateX(ye), Q.translateZ(Ft), Q.matrixWorld.compose(Q.position, Q.quaternion, Q.scale), Q.matrixWorldInverse.copy(Q.matrixWorld).invert();
        const I = Kt + Ft, x = D + Ft, X = Qt - ye, et = Xt + (lt - ye), it = Yt * D / x * I, rt = jt * D / x * I;
        Q.projectionMatrix.makePerspective(X, et, it, rt, I, x), Q.projectionMatrixInverse.copy(Q.projectionMatrix).invert();
      }
      function ut(Q, st) {
        st === null ? Q.matrixWorld.copy(Q.matrix) : Q.matrixWorld.multiplyMatrices(st.matrixWorld, Q.matrix), Q.matrixWorldInverse.copy(Q.matrixWorld).invert();
      }
      this.updateCamera = function(Q) {
        if (i === null) return;
        b.texture !== null && (Q.near = b.depthNear, Q.far = b.depthFar), S.near = z.near = P.near = Q.near, S.far = z.far = P.far = Q.far, (F !== S.near || W !== S.far) && (i.updateRenderState({
          depthNear: S.near,
          depthFar: S.far
        }), F = S.near, W = S.far, P.near = F, P.far = W, z.near = F, z.far = W, P.updateProjectionMatrix(), z.updateProjectionMatrix(), Q.updateProjectionMatrix());
        const st = Q.parent, _t = S.cameras;
        ut(S, st);
        for (let lt = 0; lt < _t.length; lt++) ut(_t[lt], st);
        _t.length === 2 ? $(S, P, z) : S.projectionMatrix.copy(P.projectionMatrix), mt(Q, S, st);
      };
      function mt(Q, st, _t) {
        _t === null ? Q.matrix.copy(st.matrixWorld) : (Q.matrix.copy(_t.matrixWorld), Q.matrix.invert(), Q.matrix.multiply(st.matrixWorld)), Q.matrix.decompose(Q.position, Q.quaternion, Q.scale), Q.updateMatrixWorld(true), Q.projectionMatrix.copy(st.projectionMatrix), Q.projectionMatrixInverse.copy(st.projectionMatrixInverse), Q.isPerspectiveCamera && (Q.fov = Tr * 2 * Math.atan(1 / Q.projectionMatrix.elements[5]), Q.zoom = 1);
      }
      this.getCamera = function() {
        return S;
      }, this.getFoveation = function() {
        if (!(u === null && p === null)) return c;
      }, this.setFoveation = function(Q) {
        c = Q, u !== null && (u.fixedFoveation = Q), p !== null && p.fixedFoveation !== void 0 && (p.fixedFoveation = Q);
      }, this.hasDepthSensing = function() {
        return b.texture !== null;
      }, this.getDepthSensingMesh = function() {
        return b.getMesh(S);
      };
      let gt = null;
      function qt(Q, st) {
        if (h = st.getViewerPose(l || a), w = st, h !== null) {
          const _t = h.views;
          p !== null && (t.setRenderTargetFramebuffer(E, p.framebuffer), t.setRenderTarget(E));
          let lt = false;
          _t.length !== S.cameras.length && (S.cameras.length = 0, lt = true);
          for (let Dt = 0; Dt < _t.length; Dt++) {
            const Kt = _t[Dt];
            let D = null;
            if (p !== null) D = p.getViewport(Kt);
            else {
              const jt = d.getViewSubImage(u, Kt);
              D = jt.viewport, Dt === 0 && (t.setRenderTargetTextures(E, jt.colorTexture, u.ignoreDepthValues ? void 0 : jt.depthStencilTexture), t.setRenderTarget(E));
            }
            let Yt = A[Dt];
            Yt === void 0 && (Yt = new tn(), Yt.layers.enable(Dt), Yt.viewport = new de(), A[Dt] = Yt), Yt.matrix.fromArray(Kt.transform.matrix), Yt.matrix.decompose(Yt.position, Yt.quaternion, Yt.scale), Yt.projectionMatrix.fromArray(Kt.projectionMatrix), Yt.projectionMatrixInverse.copy(Yt.projectionMatrix).invert(), Yt.viewport.set(D.x, D.y, D.width, D.height), Dt === 0 && (S.matrix.copy(Yt.matrix), S.matrix.decompose(S.position, S.quaternion, S.scale)), lt === true && S.cameras.push(Yt);
          }
          const kt = i.enabledFeatures;
          if (kt && kt.includes("depth-sensing")) {
            const Dt = d.getDepthInformation(_t[0]);
            Dt && Dt.isValid && Dt.texture && b.init(t, Dt, i.renderState);
          }
        }
        for (let _t = 0; _t < v.length; _t++) {
          const lt = T[_t], kt = v[_t];
          lt !== null && kt !== void 0 && kt.update(lt, st, l || a);
        }
        gt && gt(Q, st), st.detectedPlanes && n.dispatchEvent({
          type: "planesdetected",
          data: st
        }), w = null;
      }
      const ee = new Nu();
      ee.setAnimationLoop(qt), this.setAnimationLoop = function(Q) {
        gt = Q;
      }, this.dispose = function() {
      };
    }
  }
  const Li = new Pn(), H0 = new Ht();
  function G0(r, t) {
    function e(m, _) {
      m.matrixAutoUpdate === true && m.updateMatrix(), _.value.copy(m.matrix);
    }
    function n(m, _) {
      _.color.getRGB(m.fogColor.value, Pu(r)), _.isFog ? (m.fogNear.value = _.near, m.fogFar.value = _.far) : _.isFogExp2 && (m.fogDensity.value = _.density);
    }
    function i(m, _, E, v, T) {
      _.isMeshBasicMaterial || _.isMeshLambertMaterial ? s(m, _) : _.isMeshToonMaterial ? (s(m, _), d(m, _)) : _.isMeshPhongMaterial ? (s(m, _), h(m, _)) : _.isMeshStandardMaterial ? (s(m, _), u(m, _), _.isMeshPhysicalMaterial && p(m, _, T)) : _.isMeshMatcapMaterial ? (s(m, _), w(m, _)) : _.isMeshDepthMaterial ? s(m, _) : _.isMeshDistanceMaterial ? (s(m, _), b(m, _)) : _.isMeshNormalMaterial ? s(m, _) : _.isLineBasicMaterial ? (a(m, _), _.isLineDashedMaterial && o(m, _)) : _.isPointsMaterial ? c(m, _, E, v) : _.isSpriteMaterial ? l(m, _) : _.isShadowMaterial ? (m.color.value.copy(_.color), m.opacity.value = _.opacity) : _.isShaderMaterial && (_.uniformsNeedUpdate = false);
    }
    function s(m, _) {
      m.opacity.value = _.opacity, _.color && m.diffuse.value.copy(_.color), _.emissive && m.emissive.value.copy(_.emissive).multiplyScalar(_.emissiveIntensity), _.map && (m.map.value = _.map, e(_.map, m.mapTransform)), _.alphaMap && (m.alphaMap.value = _.alphaMap, e(_.alphaMap, m.alphaMapTransform)), _.bumpMap && (m.bumpMap.value = _.bumpMap, e(_.bumpMap, m.bumpMapTransform), m.bumpScale.value = _.bumpScale, _.side === nn && (m.bumpScale.value *= -1)), _.normalMap && (m.normalMap.value = _.normalMap, e(_.normalMap, m.normalMapTransform), m.normalScale.value.copy(_.normalScale), _.side === nn && m.normalScale.value.negate()), _.displacementMap && (m.displacementMap.value = _.displacementMap, e(_.displacementMap, m.displacementMapTransform), m.displacementScale.value = _.displacementScale, m.displacementBias.value = _.displacementBias), _.emissiveMap && (m.emissiveMap.value = _.emissiveMap, e(_.emissiveMap, m.emissiveMapTransform)), _.specularMap && (m.specularMap.value = _.specularMap, e(_.specularMap, m.specularMapTransform)), _.alphaTest > 0 && (m.alphaTest.value = _.alphaTest);
      const E = t.get(_), v = E.envMap, T = E.envMapRotation;
      v && (m.envMap.value = v, Li.copy(T), Li.x *= -1, Li.y *= -1, Li.z *= -1, v.isCubeTexture && v.isRenderTargetTexture === false && (Li.y *= -1, Li.z *= -1), m.envMapRotation.value.setFromMatrix4(H0.makeRotationFromEuler(Li)), m.flipEnvMap.value = v.isCubeTexture && v.isRenderTargetTexture === false ? -1 : 1, m.reflectivity.value = _.reflectivity, m.ior.value = _.ior, m.refractionRatio.value = _.refractionRatio), _.lightMap && (m.lightMap.value = _.lightMap, m.lightMapIntensity.value = _.lightMapIntensity, e(_.lightMap, m.lightMapTransform)), _.aoMap && (m.aoMap.value = _.aoMap, m.aoMapIntensity.value = _.aoMapIntensity, e(_.aoMap, m.aoMapTransform));
    }
    function a(m, _) {
      m.diffuse.value.copy(_.color), m.opacity.value = _.opacity, _.map && (m.map.value = _.map, e(_.map, m.mapTransform));
    }
    function o(m, _) {
      m.dashSize.value = _.dashSize, m.totalSize.value = _.dashSize + _.gapSize, m.scale.value = _.scale;
    }
    function c(m, _, E, v) {
      m.diffuse.value.copy(_.color), m.opacity.value = _.opacity, m.size.value = _.size * E, m.scale.value = v * 0.5, _.map && (m.map.value = _.map, e(_.map, m.uvTransform)), _.alphaMap && (m.alphaMap.value = _.alphaMap, e(_.alphaMap, m.alphaMapTransform)), _.alphaTest > 0 && (m.alphaTest.value = _.alphaTest);
    }
    function l(m, _) {
      m.diffuse.value.copy(_.color), m.opacity.value = _.opacity, m.rotation.value = _.rotation, _.map && (m.map.value = _.map, e(_.map, m.mapTransform)), _.alphaMap && (m.alphaMap.value = _.alphaMap, e(_.alphaMap, m.alphaMapTransform)), _.alphaTest > 0 && (m.alphaTest.value = _.alphaTest);
    }
    function h(m, _) {
      m.specular.value.copy(_.specular), m.shininess.value = Math.max(_.shininess, 1e-4);
    }
    function d(m, _) {
      _.gradientMap && (m.gradientMap.value = _.gradientMap);
    }
    function u(m, _) {
      m.metalness.value = _.metalness, _.metalnessMap && (m.metalnessMap.value = _.metalnessMap, e(_.metalnessMap, m.metalnessMapTransform)), m.roughness.value = _.roughness, _.roughnessMap && (m.roughnessMap.value = _.roughnessMap, e(_.roughnessMap, m.roughnessMapTransform)), _.envMap && (m.envMapIntensity.value = _.envMapIntensity);
    }
    function p(m, _, E) {
      m.ior.value = _.ior, _.sheen > 0 && (m.sheenColor.value.copy(_.sheenColor).multiplyScalar(_.sheen), m.sheenRoughness.value = _.sheenRoughness, _.sheenColorMap && (m.sheenColorMap.value = _.sheenColorMap, e(_.sheenColorMap, m.sheenColorMapTransform)), _.sheenRoughnessMap && (m.sheenRoughnessMap.value = _.sheenRoughnessMap, e(_.sheenRoughnessMap, m.sheenRoughnessMapTransform))), _.clearcoat > 0 && (m.clearcoat.value = _.clearcoat, m.clearcoatRoughness.value = _.clearcoatRoughness, _.clearcoatMap && (m.clearcoatMap.value = _.clearcoatMap, e(_.clearcoatMap, m.clearcoatMapTransform)), _.clearcoatRoughnessMap && (m.clearcoatRoughnessMap.value = _.clearcoatRoughnessMap, e(_.clearcoatRoughnessMap, m.clearcoatRoughnessMapTransform)), _.clearcoatNormalMap && (m.clearcoatNormalMap.value = _.clearcoatNormalMap, e(_.clearcoatNormalMap, m.clearcoatNormalMapTransform), m.clearcoatNormalScale.value.copy(_.clearcoatNormalScale), _.side === nn && m.clearcoatNormalScale.value.negate())), _.dispersion > 0 && (m.dispersion.value = _.dispersion), _.iridescence > 0 && (m.iridescence.value = _.iridescence, m.iridescenceIOR.value = _.iridescenceIOR, m.iridescenceThicknessMinimum.value = _.iridescenceThicknessRange[0], m.iridescenceThicknessMaximum.value = _.iridescenceThicknessRange[1], _.iridescenceMap && (m.iridescenceMap.value = _.iridescenceMap, e(_.iridescenceMap, m.iridescenceMapTransform)), _.iridescenceThicknessMap && (m.iridescenceThicknessMap.value = _.iridescenceThicknessMap, e(_.iridescenceThicknessMap, m.iridescenceThicknessMapTransform))), _.transmission > 0 && (m.transmission.value = _.transmission, m.transmissionSamplerMap.value = E.texture, m.transmissionSamplerSize.value.set(E.width, E.height), _.transmissionMap && (m.transmissionMap.value = _.transmissionMap, e(_.transmissionMap, m.transmissionMapTransform)), m.thickness.value = _.thickness, _.thicknessMap && (m.thicknessMap.value = _.thicknessMap, e(_.thicknessMap, m.thicknessMapTransform)), m.attenuationDistance.value = _.attenuationDistance, m.attenuationColor.value.copy(_.attenuationColor)), _.anisotropy > 0 && (m.anisotropyVector.value.set(_.anisotropy * Math.cos(_.anisotropyRotation), _.anisotropy * Math.sin(_.anisotropyRotation)), _.anisotropyMap && (m.anisotropyMap.value = _.anisotropyMap, e(_.anisotropyMap, m.anisotropyMapTransform))), m.specularIntensity.value = _.specularIntensity, m.specularColor.value.copy(_.specularColor), _.specularColorMap && (m.specularColorMap.value = _.specularColorMap, e(_.specularColorMap, m.specularColorMapTransform)), _.specularIntensityMap && (m.specularIntensityMap.value = _.specularIntensityMap, e(_.specularIntensityMap, m.specularIntensityMapTransform));
    }
    function w(m, _) {
      _.matcap && (m.matcap.value = _.matcap);
    }
    function b(m, _) {
      const E = t.get(_).light;
      m.referencePosition.value.setFromMatrixPosition(E.matrixWorld), m.nearDistance.value = E.shadow.camera.near, m.farDistance.value = E.shadow.camera.far;
    }
    return {
      refreshFogUniforms: n,
      refreshMaterialUniforms: i
    };
  }
  function V0(r, t, e, n) {
    let i = {}, s = {}, a = [];
    const o = r.getParameter(r.MAX_UNIFORM_BUFFER_BINDINGS);
    function c(E, v) {
      const T = v.program;
      n.uniformBlockBinding(E, T);
    }
    function l(E, v) {
      let T = i[E.id];
      T === void 0 && (w(E), T = h(E), i[E.id] = T, E.addEventListener("dispose", m));
      const O = v.program;
      n.updateUBOMapping(E, O);
      const R = t.render.frame;
      s[E.id] !== R && (u(E), s[E.id] = R);
    }
    function h(E) {
      const v = d();
      E.__bindingPointIndex = v;
      const T = r.createBuffer(), O = E.__size, R = E.usage;
      return r.bindBuffer(r.UNIFORM_BUFFER, T), r.bufferData(r.UNIFORM_BUFFER, O, R), r.bindBuffer(r.UNIFORM_BUFFER, null), r.bindBufferBase(r.UNIFORM_BUFFER, v, T), T;
    }
    function d() {
      for (let E = 0; E < o; E++) if (a.indexOf(E) === -1) return a.push(E), E;
      return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0;
    }
    function u(E) {
      const v = i[E.id], T = E.uniforms, O = E.__cache;
      r.bindBuffer(r.UNIFORM_BUFFER, v);
      for (let R = 0, P = T.length; R < P; R++) {
        const z = Array.isArray(T[R]) ? T[R] : [
          T[R]
        ];
        for (let A = 0, S = z.length; A < S; A++) {
          const F = z[A];
          if (p(F, R, A, O) === true) {
            const W = F.__offset, V = Array.isArray(F.value) ? F.value : [
              F.value
            ];
            let Z = 0;
            for (let tt = 0; tt < V.length; tt++) {
              const Y = V[tt], J = b(Y);
              typeof Y == "number" || typeof Y == "boolean" ? (F.__data[0] = Y, r.bufferSubData(r.UNIFORM_BUFFER, W + Z, F.__data)) : Y.isMatrix3 ? (F.__data[0] = Y.elements[0], F.__data[1] = Y.elements[1], F.__data[2] = Y.elements[2], F.__data[3] = 0, F.__data[4] = Y.elements[3], F.__data[5] = Y.elements[4], F.__data[6] = Y.elements[5], F.__data[7] = 0, F.__data[8] = Y.elements[6], F.__data[9] = Y.elements[7], F.__data[10] = Y.elements[8], F.__data[11] = 0) : (Y.toArray(F.__data, Z), Z += J.storage / Float32Array.BYTES_PER_ELEMENT);
            }
            r.bufferSubData(r.UNIFORM_BUFFER, W, F.__data);
          }
        }
      }
      r.bindBuffer(r.UNIFORM_BUFFER, null);
    }
    function p(E, v, T, O) {
      const R = E.value, P = v + "_" + T;
      if (O[P] === void 0) return typeof R == "number" || typeof R == "boolean" ? O[P] = R : O[P] = R.clone(), true;
      {
        const z = O[P];
        if (typeof R == "number" || typeof R == "boolean") {
          if (z !== R) return O[P] = R, true;
        } else if (z.equals(R) === false) return z.copy(R), true;
      }
      return false;
    }
    function w(E) {
      const v = E.uniforms;
      let T = 0;
      const O = 16;
      for (let P = 0, z = v.length; P < z; P++) {
        const A = Array.isArray(v[P]) ? v[P] : [
          v[P]
        ];
        for (let S = 0, F = A.length; S < F; S++) {
          const W = A[S], V = Array.isArray(W.value) ? W.value : [
            W.value
          ];
          for (let Z = 0, tt = V.length; Z < tt; Z++) {
            const Y = V[Z], J = b(Y), $ = T % O;
            $ !== 0 && O - $ < J.boundary && (T += O - $), W.__data = new Float32Array(J.storage / Float32Array.BYTES_PER_ELEMENT), W.__offset = T, T += J.storage;
          }
        }
      }
      const R = T % O;
      return R > 0 && (T += O - R), E.__size = T, E.__cache = {}, this;
    }
    function b(E) {
      const v = {
        boundary: 0,
        storage: 0
      };
      return typeof E == "number" || typeof E == "boolean" ? (v.boundary = 4, v.storage = 4) : E.isVector2 ? (v.boundary = 8, v.storage = 8) : E.isVector3 || E.isColor ? (v.boundary = 16, v.storage = 12) : E.isVector4 ? (v.boundary = 16, v.storage = 16) : E.isMatrix3 ? (v.boundary = 48, v.storage = 48) : E.isMatrix4 ? (v.boundary = 64, v.storage = 64) : E.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", E), v;
    }
    function m(E) {
      const v = E.target;
      v.removeEventListener("dispose", m);
      const T = a.indexOf(v.__bindingPointIndex);
      a.splice(T, 1), r.deleteBuffer(i[v.id]), delete i[v.id], delete s[v.id];
    }
    function _() {
      for (const E in i) r.deleteBuffer(i[E]);
      a = [], i = {}, s = {};
    }
    return {
      bind: c,
      update: l,
      dispose: _
    };
  }
  class W0 {
    constructor(t = {}) {
      const { canvas: e = Of(), context: n = null, depth: i = true, stencil: s = false, alpha: a = false, antialias: o = false, premultipliedAlpha: c = true, preserveDrawingBuffer: l = false, powerPreference: h = "default", failIfMajorPerformanceCaveat: d = false } = t;
      this.isWebGLRenderer = true;
      let u;
      if (n !== null) {
        if (typeof WebGLRenderingContext < "u" && n instanceof WebGLRenderingContext) throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");
        u = n.getContextAttributes().alpha;
      } else u = a;
      const p = new Uint32Array(4), w = new Int32Array(4);
      let b = null, m = null;
      const _ = [], E = [];
      this.domElement = e, this.debug = {
        checkShaderErrors: true,
        onShaderError: null
      }, this.autoClear = true, this.autoClearColor = true, this.autoClearDepth = true, this.autoClearStencil = true, this.sortObjects = true, this.clippingPlanes = [], this.localClippingEnabled = false, this._outputColorSpace = Ke, this.toneMapping = xi, this.toneMappingExposure = 1;
      const v = this;
      let T = false, O = 0, R = 0, P = null, z = -1, A = null;
      const S = new de(), F = new de();
      let W = null;
      const V = new Ct(0);
      let Z = 0, tt = e.width, Y = e.height, J = 1, $ = null, ut = null;
      const mt = new de(0, 0, tt, Y), gt = new de(0, 0, tt, Y);
      let qt = false;
      const ee = new Uc();
      let Q = false, st = false;
      const _t = new Ht(), lt = new L(), kt = {
        background: null,
        fog: null,
        environment: null,
        overrideMaterial: null,
        isScene: true
      };
      let Dt = false;
      function Kt() {
        return P === null ? J : 1;
      }
      let D = n;
      function Yt(M, B) {
        return e.getContext(M, B);
      }
      try {
        const M = {
          alpha: true,
          depth: i,
          stencil: s,
          antialias: o,
          premultipliedAlpha: c,
          preserveDrawingBuffer: l,
          powerPreference: h,
          failIfMajorPerformanceCaveat: d
        };
        if ("setAttribute" in e && e.setAttribute("data-engine", `three.js r${Ic}`), e.addEventListener("webglcontextlost", q, false), e.addEventListener("webglcontextrestored", H, false), e.addEventListener("webglcontextcreationerror", K, false), D === null) {
          const B = "webgl2";
          if (D = Yt(B, M), D === null) throw Yt(B) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
        }
      } catch (M) {
        throw console.error("THREE.WebGLRenderer: " + M.message), M;
      }
      let jt, ue, At, Qt, Xt, Ft, ye, I, x, X, et, it, rt, St, ht, ct, Ot, at, bt, Zt, Pt, pt, Bt, zt;
      function xe() {
        jt = new Jg(D), jt.init(), pt = new N0(D, jt), ue = new Xg(D, jt, t, pt), At = new L0(D), Qt = new ew(D), Xt = new w0(), Ft = new D0(D, jt, At, Xt, ue, pt, Qt), ye = new Kg(v), I = new $g(v), x = new c_(D), Bt = new Wg(D, x), X = new Qg(D, x, Qt, Bt), et = new iw(D, X, x, Qt), bt = new nw(D, ue, Ft), ct = new qg(Xt), it = new g0(v, ye, I, jt, ue, Bt, ct), rt = new G0(v, Xt), St = new y0(), ht = new T0(jt), at = new Vg(v, ye, I, At, et, u, c), Ot = new I0(v, et, ue), zt = new V0(D, Qt, ue, At), Zt = new jg(D, jt, Qt), Pt = new tw(D, jt, Qt), Qt.programs = it.programs, v.capabilities = ue, v.extensions = jt, v.properties = Xt, v.renderLists = St, v.shadowMap = Ot, v.state = At, v.info = Qt;
      }
      xe();
      const y = new k0(v, D);
      this.xr = y, this.getContext = function() {
        return D;
      }, this.getContextAttributes = function() {
        return D.getContextAttributes();
      }, this.forceContextLoss = function() {
        const M = jt.get("WEBGL_lose_context");
        M && M.loseContext();
      }, this.forceContextRestore = function() {
        const M = jt.get("WEBGL_lose_context");
        M && M.restoreContext();
      }, this.getPixelRatio = function() {
        return J;
      }, this.setPixelRatio = function(M) {
        M !== void 0 && (J = M, this.setSize(tt, Y, false));
      }, this.getSize = function(M) {
        return M.set(tt, Y);
      }, this.setSize = function(M, B, G = true) {
        if (y.isPresenting) {
          console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
          return;
        }
        tt = M, Y = B, e.width = Math.floor(M * J), e.height = Math.floor(B * J), G === true && (e.style.width = M + "px", e.style.height = B + "px"), this.setViewport(0, 0, M, B);
      }, this.getDrawingBufferSize = function(M) {
        return M.set(tt * J, Y * J).floor();
      }, this.setDrawingBufferSize = function(M, B, G) {
        tt = M, Y = B, J = G, e.width = Math.floor(M * G), e.height = Math.floor(B * G), this.setViewport(0, 0, M, B);
      }, this.getCurrentViewport = function(M) {
        return M.copy(S);
      }, this.getViewport = function(M) {
        return M.copy(mt);
      }, this.setViewport = function(M, B, G, j) {
        M.isVector4 ? mt.set(M.x, M.y, M.z, M.w) : mt.set(M, B, G, j), At.viewport(S.copy(mt).multiplyScalar(J).round());
      }, this.getScissor = function(M) {
        return M.copy(gt);
      }, this.setScissor = function(M, B, G, j) {
        M.isVector4 ? gt.set(M.x, M.y, M.z, M.w) : gt.set(M, B, G, j), At.scissor(F.copy(gt).multiplyScalar(J).round());
      }, this.getScissorTest = function() {
        return qt;
      }, this.setScissorTest = function(M) {
        At.setScissorTest(qt = M);
      }, this.setOpaqueSort = function(M) {
        $ = M;
      }, this.setTransparentSort = function(M) {
        ut = M;
      }, this.getClearColor = function(M) {
        return M.copy(at.getClearColor());
      }, this.setClearColor = function() {
        at.setClearColor.apply(at, arguments);
      }, this.getClearAlpha = function() {
        return at.getClearAlpha();
      }, this.setClearAlpha = function() {
        at.setClearAlpha.apply(at, arguments);
      }, this.clear = function(M = true, B = true, G = true) {
        let j = 0;
        if (M) {
          let k = false;
          if (P !== null) {
            const ot = P.texture.format;
            k = ot === wu || ot === gu || ot === mu;
          }
          if (k) {
            const ot = P.texture.type, ft = ot === Si || ot === Sr || ot === _a || ot === Mr || ot === pu || ot === fu, wt = at.getClearColor(), yt = at.getClearAlpha(), It = wt.r, Lt = wt.g, Rt = wt.b;
            ft ? (p[0] = It, p[1] = Lt, p[2] = Rt, p[3] = yt, D.clearBufferuiv(D.COLOR, 0, p)) : (w[0] = It, w[1] = Lt, w[2] = Rt, w[3] = yt, D.clearBufferiv(D.COLOR, 0, w));
          } else j |= D.COLOR_BUFFER_BIT;
        }
        B && (j |= D.DEPTH_BUFFER_BIT), G && (j |= D.STENCIL_BUFFER_BIT, this.state.buffers.stencil.setMask(4294967295)), D.clear(j);
      }, this.clearColor = function() {
        this.clear(true, false, false);
      }, this.clearDepth = function() {
        this.clear(false, true, false);
      }, this.clearStencil = function() {
        this.clear(false, false, true);
      }, this.dispose = function() {
        e.removeEventListener("webglcontextlost", q, false), e.removeEventListener("webglcontextrestored", H, false), e.removeEventListener("webglcontextcreationerror", K, false), St.dispose(), ht.dispose(), Xt.dispose(), ye.dispose(), I.dispose(), et.dispose(), Bt.dispose(), zt.dispose(), it.dispose(), y.dispose(), y.removeEventListener("sessionstart", Ce), y.removeEventListener("sessionend", Pe), an.stop();
      };
      function q(M) {
        M.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), T = true;
      }
      function H() {
        console.log("THREE.WebGLRenderer: Context Restored."), T = false;
        const M = Qt.autoReset, B = Ot.enabled, G = Ot.autoUpdate, j = Ot.needsUpdate, k = Ot.type;
        xe(), Qt.autoReset = M, Ot.enabled = B, Ot.autoUpdate = G, Ot.needsUpdate = j, Ot.type = k;
      }
      function K(M) {
        console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", M.statusMessage);
      }
      function nt(M) {
        const B = M.target;
        B.removeEventListener("dispose", nt), Mt(B);
      }
      function Mt(M) {
        Nt(M), Xt.remove(M);
      }
      function Nt(M) {
        const B = Xt.get(M).programs;
        B !== void 0 && (B.forEach(function(G) {
          it.releaseProgram(G);
        }), M.isShaderMaterial && it.releaseShaderCache(M));
      }
      this.renderBufferDirect = function(M, B, G, j, k, ot) {
        B === null && (B = kt);
        const ft = k.isMesh && k.matrixWorld.determinant() < 0, wt = pp(M, B, G, j, k);
        At.setMaterial(j, ft);
        let yt = G.index, It = 1;
        if (j.wireframe === true) {
          if (yt = X.getWireframeAttribute(G), yt === void 0) return;
          It = 2;
        }
        const Lt = G.drawRange, Rt = G.attributes.position;
        let re = Lt.start * It, Me = (Lt.start + Lt.count) * It;
        ot !== null && (re = Math.max(re, ot.start * It), Me = Math.min(Me, (ot.start + ot.count) * It)), yt !== null ? (re = Math.max(re, 0), Me = Math.min(Me, yt.count)) : Rt != null && (re = Math.max(re, 0), Me = Math.min(Me, Rt.count));
        const Ee = Me - re;
        if (Ee < 0 || Ee === 1 / 0) return;
        Bt.setup(k, j, wt, G, yt);
        let cn, se = Zt;
        if (yt !== null && (cn = x.get(yt), se = Pt, se.setIndex(cn)), k.isMesh) j.wireframe === true ? (At.setLineWidth(j.wireframeLinewidth * Kt()), se.setMode(D.LINES)) : se.setMode(D.TRIANGLES);
        else if (k.isLine) {
          let Tt = j.linewidth;
          Tt === void 0 && (Tt = 1), At.setLineWidth(Tt * Kt()), k.isLineSegments ? se.setMode(D.LINES) : k.isLineLoop ? se.setMode(D.LINE_LOOP) : se.setMode(D.LINE_STRIP);
        } else k.isPoints ? se.setMode(D.POINTS) : k.isSprite && se.setMode(D.TRIANGLES);
        if (k.isBatchedMesh) k._multiDrawInstances !== null ? se.renderMultiDrawInstances(k._multiDrawStarts, k._multiDrawCounts, k._multiDrawCount, k._multiDrawInstances) : se.renderMultiDraw(k._multiDrawStarts, k._multiDrawCounts, k._multiDrawCount);
        else if (k.isInstancedMesh) se.renderInstances(re, Ee, k.count);
        else if (G.isInstancedBufferGeometry) {
          const Tt = G._maxInstanceCount !== void 0 ? G._maxInstanceCount : 1 / 0, Ze = Math.min(G.instanceCount, Tt);
          se.renderInstances(re, Ee, Ze);
        } else se.render(re, Ee);
      };
      function Se(M, B, G) {
        M.transparent === true && M.side === Mn && M.forceSinglePass === false ? (M.side = nn, M.needsUpdate = true, Ms(M, B, G), M.side = Jn, M.needsUpdate = true, Ms(M, B, G), M.side = Mn) : Ms(M, B, G);
      }
      this.compile = function(M, B, G = null) {
        G === null && (G = M), m = ht.get(G), m.init(B), E.push(m), G.traverseVisible(function(k) {
          k.isLight && k.layers.test(B.layers) && (m.pushLight(k), k.castShadow && m.pushShadow(k));
        }), M !== G && M.traverseVisible(function(k) {
          k.isLight && k.layers.test(B.layers) && (m.pushLight(k), k.castShadow && m.pushShadow(k));
        }), m.setupLights();
        const j = /* @__PURE__ */ new Set();
        return M.traverse(function(k) {
          const ot = k.material;
          if (ot) if (Array.isArray(ot)) for (let ft = 0; ft < ot.length; ft++) {
            const wt = ot[ft];
            Se(wt, G, k), j.add(wt);
          }
          else Se(ot, G, k), j.add(ot);
        }), E.pop(), m = null, j;
      }, this.compileAsync = function(M, B, G = null) {
        const j = this.compile(M, B, G);
        return new Promise((k) => {
          function ot() {
            if (j.forEach(function(ft) {
              Xt.get(ft).currentProgram.isReady() && j.delete(ft);
            }), j.size === 0) {
              k(M);
              return;
            }
            setTimeout(ot, 10);
          }
          jt.get("KHR_parallel_shader_compile") !== null ? ot() : setTimeout(ot, 10);
        });
      };
      let Re = null;
      function ne(M) {
        Re && Re(M);
      }
      function Ce() {
        an.stop();
      }
      function Pe() {
        an.start();
      }
      const an = new Nu();
      an.setAnimationLoop(ne), typeof self < "u" && an.setContext(self), this.setAnimationLoop = function(M) {
        Re = M, y.setAnimationLoop(M), M === null ? an.stop() : an.start();
      }, y.addEventListener("sessionstart", Ce), y.addEventListener("sessionend", Pe), this.render = function(M, B) {
        if (B !== void 0 && B.isCamera !== true) {
          console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
          return;
        }
        if (T === true) return;
        if (M.matrixWorldAutoUpdate === true && M.updateMatrixWorld(), B.parent === null && B.matrixWorldAutoUpdate === true && B.updateMatrixWorld(), y.enabled === true && y.isPresenting === true && (y.cameraAutoUpdate === true && y.updateCamera(B), B = y.getCamera()), M.isScene === true && M.onBeforeRender(v, M, B, P), m = ht.get(M, E.length), m.init(B), E.push(m), _t.multiplyMatrices(B.projectionMatrix, B.matrixWorldInverse), ee.setFromProjectionMatrix(_t), st = this.localClippingEnabled, Q = ct.init(this.clippingPlanes, st), b = St.get(M, _.length), b.init(), _.push(b), y.enabled === true && y.isPresenting === true) {
          const ot = v.xr.getDepthSensingMesh();
          ot !== null && on(ot, B, -1 / 0, v.sortObjects);
        }
        on(M, B, 0, v.sortObjects), b.finish(), v.sortObjects === true && b.sort($, ut), Dt = y.enabled === false || y.isPresenting === false || y.hasDepthSensing() === false, Dt && at.addToRenderList(b, M), this.info.render.frame++, Q === true && ct.beginShadows();
        const G = m.state.shadowsArray;
        Ot.render(G, M, B), Q === true && ct.endShadows(), this.info.autoReset === true && this.info.reset();
        const j = b.opaque, k = b.transmissive;
        if (m.setupLights(), B.isArrayCamera) {
          const ot = B.cameras;
          if (k.length > 0) for (let ft = 0, wt = ot.length; ft < wt; ft++) {
            const yt = ot[ft];
            Mi(j, k, M, yt);
          }
          Dt && at.render(M);
          for (let ft = 0, wt = ot.length; ft < wt; ft++) {
            const yt = ot[ft];
            si(b, M, yt, yt.viewport);
          }
        } else k.length > 0 && Mi(j, k, M, B), Dt && at.render(M), si(b, M, B);
        P !== null && (Ft.updateMultisampleRenderTarget(P), Ft.updateRenderTargetMipmap(P)), M.isScene === true && M.onAfterRender(v, M, B), Bt.resetDefaultState(), z = -1, A = null, E.pop(), E.length > 0 ? (m = E[E.length - 1], Q === true && ct.setGlobalState(v.clippingPlanes, m.state.camera)) : m = null, _.pop(), _.length > 0 ? b = _[_.length - 1] : b = null;
      };
      function on(M, B, G, j) {
        if (M.visible === false) return;
        if (M.layers.test(B.layers)) {
          if (M.isGroup) G = M.renderOrder;
          else if (M.isLOD) M.autoUpdate === true && M.update(B);
          else if (M.isLight) m.pushLight(M), M.castShadow && m.pushShadow(M);
          else if (M.isSprite) {
            if (!M.frustumCulled || ee.intersectsSprite(M)) {
              j && lt.setFromMatrixPosition(M.matrixWorld).applyMatrix4(_t);
              const ft = et.update(M), wt = M.material;
              wt.visible && b.push(M, ft, wt, G, lt.z, null);
            }
          } else if ((M.isMesh || M.isLine || M.isPoints) && (!M.frustumCulled || ee.intersectsObject(M))) {
            const ft = et.update(M), wt = M.material;
            if (j && (M.boundingSphere !== void 0 ? (M.boundingSphere === null && M.computeBoundingSphere(), lt.copy(M.boundingSphere.center)) : (ft.boundingSphere === null && ft.computeBoundingSphere(), lt.copy(ft.boundingSphere.center)), lt.applyMatrix4(M.matrixWorld).applyMatrix4(_t)), Array.isArray(wt)) {
              const yt = ft.groups;
              for (let It = 0, Lt = yt.length; It < Lt; It++) {
                const Rt = yt[It], re = wt[Rt.materialIndex];
                re && re.visible && b.push(M, ft, re, G, lt.z, Rt);
              }
            } else wt.visible && b.push(M, ft, wt, G, lt.z, null);
          }
        }
        const ot = M.children;
        for (let ft = 0, wt = ot.length; ft < wt; ft++) on(ot[ft], B, G, j);
      }
      function si(M, B, G, j) {
        const k = M.opaque, ot = M.transmissive, ft = M.transparent;
        m.setupLightsView(G), Q === true && ct.setGlobalState(v.clippingPlanes, G), j && At.viewport(S.copy(j)), k.length > 0 && Ei(k, B, G), ot.length > 0 && Ei(ot, B, G), ft.length > 0 && Ei(ft, B, G), At.buffers.depth.setTest(true), At.buffers.depth.setMask(true), At.buffers.color.setMask(true), At.setPolygonOffset(false);
      }
      function Mi(M, B, G, j) {
        if ((G.isScene === true ? G.overrideMaterial : null) !== null) return;
        m.state.transmissionRenderTarget[j.id] === void 0 && (m.state.transmissionRenderTarget[j.id] = new Bi(1, 1, {
          generateMipmaps: true,
          type: jt.has("EXT_color_buffer_half_float") || jt.has("EXT_color_buffer_float") ? Ba : Si,
          minFilter: Zn,
          samples: 4,
          stencilBuffer: s,
          resolveDepthBuffer: false,
          resolveStencilBuffer: false,
          colorSpace: ie.workingColorSpace
        }));
        const ot = m.state.transmissionRenderTarget[j.id], ft = j.viewport || S;
        ot.setSize(ft.z, ft.w);
        const wt = v.getRenderTarget();
        v.setRenderTarget(ot), v.getClearColor(V), Z = v.getClearAlpha(), Z < 1 && v.setClearColor(16777215, 0.5), Dt ? at.render(G) : v.clear();
        const yt = v.toneMapping;
        v.toneMapping = xi;
        const It = j.viewport;
        if (j.viewport !== void 0 && (j.viewport = void 0), m.setupLightsView(j), Q === true && ct.setGlobalState(v.clippingPlanes, j), Ei(M, G, j), Ft.updateMultisampleRenderTarget(ot), Ft.updateRenderTargetMipmap(ot), jt.has("WEBGL_multisampled_render_to_texture") === false) {
          let Lt = false;
          for (let Rt = 0, re = B.length; Rt < re; Rt++) {
            const Me = B[Rt], Ee = Me.object, cn = Me.geometry, se = Me.material, Tt = Me.group;
            if (se.side === Mn && Ee.layers.test(j.layers)) {
              const Ze = se.side;
              se.side = nn, se.needsUpdate = true, Rl(Ee, G, j, cn, se, Tt), se.side = Ze, se.needsUpdate = true, Lt = true;
            }
          }
          Lt === true && (Ft.updateMultisampleRenderTarget(ot), Ft.updateRenderTargetMipmap(ot));
        }
        v.setRenderTarget(wt), v.setClearColor(V, Z), It !== void 0 && (j.viewport = It), v.toneMapping = yt;
      }
      function Ei(M, B, G) {
        const j = B.isScene === true ? B.overrideMaterial : null;
        for (let k = 0, ot = M.length; k < ot; k++) {
          const ft = M[k], wt = ft.object, yt = ft.geometry, It = j === null ? ft.material : j, Lt = ft.group;
          wt.layers.test(G.layers) && Rl(wt, B, G, yt, It, Lt);
        }
      }
      function Rl(M, B, G, j, k, ot) {
        M.onBeforeRender(v, B, G, j, k, ot), M.modelViewMatrix.multiplyMatrices(G.matrixWorldInverse, M.matrixWorld), M.normalMatrix.getNormalMatrix(M.modelViewMatrix), k.onBeforeRender(v, B, G, j, M, ot), k.transparent === true && k.side === Mn && k.forceSinglePass === false ? (k.side = nn, k.needsUpdate = true, v.renderBufferDirect(G, B, j, k, M, ot), k.side = Jn, k.needsUpdate = true, v.renderBufferDirect(G, B, j, k, M, ot), k.side = Mn) : v.renderBufferDirect(G, B, j, k, M, ot), M.onAfterRender(v, B, G, j, k, ot);
      }
      function Ms(M, B, G) {
        B.isScene !== true && (B = kt);
        const j = Xt.get(M), k = m.state.lights, ot = m.state.shadowsArray, ft = k.state.version, wt = it.getParameters(M, k.state, ot, B, G), yt = it.getProgramCacheKey(wt);
        let It = j.programs;
        j.environment = M.isMeshStandardMaterial ? B.environment : null, j.fog = B.fog, j.envMap = (M.isMeshStandardMaterial ? I : ye).get(M.envMap || j.environment), j.envMapRotation = j.environment !== null && M.envMap === null ? B.environmentRotation : M.envMapRotation, It === void 0 && (M.addEventListener("dispose", nt), It = /* @__PURE__ */ new Map(), j.programs = It);
        let Lt = It.get(yt);
        if (Lt !== void 0) {
          if (j.currentProgram === Lt && j.lightsStateVersion === ft) return Pl(M, wt), Lt;
        } else wt.uniforms = it.getUniforms(M), M.onBuild(G, wt, v), M.onBeforeCompile(wt, v), Lt = it.acquireProgram(wt, yt), It.set(yt, Lt), j.uniforms = wt.uniforms;
        const Rt = j.uniforms;
        return (!M.isShaderMaterial && !M.isRawShaderMaterial || M.clipping === true) && (Rt.clippingPlanes = ct.uniform), Pl(M, wt), j.needsLights = _p(M), j.lightsStateVersion = ft, j.needsLights && (Rt.ambientLightColor.value = k.state.ambient, Rt.lightProbe.value = k.state.probe, Rt.directionalLights.value = k.state.directional, Rt.directionalLightShadows.value = k.state.directionalShadow, Rt.spotLights.value = k.state.spot, Rt.spotLightShadows.value = k.state.spotShadow, Rt.rectAreaLights.value = k.state.rectArea, Rt.ltc_1.value = k.state.rectAreaLTC1, Rt.ltc_2.value = k.state.rectAreaLTC2, Rt.pointLights.value = k.state.point, Rt.pointLightShadows.value = k.state.pointShadow, Rt.hemisphereLights.value = k.state.hemi, Rt.directionalShadowMap.value = k.state.directionalShadowMap, Rt.directionalShadowMatrix.value = k.state.directionalShadowMatrix, Rt.spotShadowMap.value = k.state.spotShadowMap, Rt.spotLightMatrix.value = k.state.spotLightMatrix, Rt.spotLightMap.value = k.state.spotLightMap, Rt.pointShadowMap.value = k.state.pointShadowMap, Rt.pointShadowMatrix.value = k.state.pointShadowMatrix), j.currentProgram = Lt, j.uniformsList = null, Lt;
      }
      function Cl(M) {
        if (M.uniformsList === null) {
          const B = M.currentProgram.getUniforms();
          M.uniformsList = ua.seqWithValue(B.seq, M.uniforms);
        }
        return M.uniformsList;
      }
      function Pl(M, B) {
        const G = Xt.get(M);
        G.outputColorSpace = B.outputColorSpace, G.batching = B.batching, G.batchingColor = B.batchingColor, G.instancing = B.instancing, G.instancingColor = B.instancingColor, G.instancingMorph = B.instancingMorph, G.skinning = B.skinning, G.morphTargets = B.morphTargets, G.morphNormals = B.morphNormals, G.morphColors = B.morphColors, G.morphTargetsCount = B.morphTargetsCount, G.numClippingPlanes = B.numClippingPlanes, G.numIntersection = B.numClipIntersection, G.vertexAlphas = B.vertexAlphas, G.vertexTangents = B.vertexTangents, G.toneMapping = B.toneMapping;
      }
      function pp(M, B, G, j, k) {
        B.isScene !== true && (B = kt), Ft.resetTextureUnits();
        const ot = B.fog, ft = j.isMeshStandardMaterial ? B.environment : null, wt = P === null ? v.outputColorSpace : P.isXRRenderTarget === true ? P.texture.colorSpace : je, yt = (j.isMeshStandardMaterial ? I : ye).get(j.envMap || ft), It = j.vertexColors === true && !!G.attributes.color && G.attributes.color.itemSize === 4, Lt = !!G.attributes.tangent && (!!j.normalMap || j.anisotropy > 0), Rt = !!G.morphAttributes.position, re = !!G.morphAttributes.normal, Me = !!G.morphAttributes.color;
        let Ee = xi;
        j.toneMapped && (P === null || P.isXRRenderTarget === true) && (Ee = v.toneMapping);
        const cn = G.morphAttributes.position || G.morphAttributes.normal || G.morphAttributes.color, se = cn !== void 0 ? cn.length : 0, Tt = Xt.get(j), Ze = m.state.lights;
        if (Q === true && (st === true || M !== A)) {
          const un = M === A && j.id === z;
          ct.setState(j, M, un);
        }
        let ce = false;
        j.version === Tt.__version ? (Tt.needsLights && Tt.lightsStateVersion !== Ze.state.version || Tt.outputColorSpace !== wt || k.isBatchedMesh && Tt.batching === false || !k.isBatchedMesh && Tt.batching === true || k.isBatchedMesh && Tt.batchingColor === true && k.colorTexture === null || k.isBatchedMesh && Tt.batchingColor === false && k.colorTexture !== null || k.isInstancedMesh && Tt.instancing === false || !k.isInstancedMesh && Tt.instancing === true || k.isSkinnedMesh && Tt.skinning === false || !k.isSkinnedMesh && Tt.skinning === true || k.isInstancedMesh && Tt.instancingColor === true && k.instanceColor === null || k.isInstancedMesh && Tt.instancingColor === false && k.instanceColor !== null || k.isInstancedMesh && Tt.instancingMorph === true && k.morphTexture === null || k.isInstancedMesh && Tt.instancingMorph === false && k.morphTexture !== null || Tt.envMap !== yt || j.fog === true && Tt.fog !== ot || Tt.numClippingPlanes !== void 0 && (Tt.numClippingPlanes !== ct.numPlanes || Tt.numIntersection !== ct.numIntersection) || Tt.vertexAlphas !== It || Tt.vertexTangents !== Lt || Tt.morphTargets !== Rt || Tt.morphNormals !== re || Tt.morphColors !== Me || Tt.toneMapping !== Ee || Tt.morphTargetsCount !== se) && (ce = true) : (ce = true, Tt.__version = j.version);
        let kn = Tt.currentProgram;
        ce === true && (kn = Ms(j, B, k));
        let Es = false, Ti = false, go = false;
        const Oe = kn.getUniforms(), ai = Tt.uniforms;
        if (At.useProgram(kn.program) && (Es = true, Ti = true, go = true), j.id !== z && (z = j.id, Ti = true), Es || A !== M) {
          Oe.setValue(D, "projectionMatrix", M.projectionMatrix), Oe.setValue(D, "viewMatrix", M.matrixWorldInverse);
          const un = Oe.map.cameraPosition;
          un !== void 0 && un.setValue(D, lt.setFromMatrixPosition(M.matrixWorld)), ue.logarithmicDepthBuffer && Oe.setValue(D, "logDepthBufFC", 2 / (Math.log(M.far + 1) / Math.LN2)), (j.isMeshPhongMaterial || j.isMeshToonMaterial || j.isMeshLambertMaterial || j.isMeshBasicMaterial || j.isMeshStandardMaterial || j.isShaderMaterial) && Oe.setValue(D, "isOrthographic", M.isOrthographicCamera === true), A !== M && (A = M, Ti = true, go = true);
        }
        if (k.isSkinnedMesh) {
          Oe.setOptional(D, k, "bindMatrix"), Oe.setOptional(D, k, "bindMatrixInverse");
          const un = k.skeleton;
          un && (un.boneTexture === null && un.computeBoneTexture(), Oe.setValue(D, "boneTexture", un.boneTexture, Ft));
        }
        k.isBatchedMesh && (Oe.setOptional(D, k, "batchingTexture"), Oe.setValue(D, "batchingTexture", k._matricesTexture, Ft), Oe.setOptional(D, k, "batchingColorTexture"), k._colorsTexture !== null && Oe.setValue(D, "batchingColorTexture", k._colorsTexture, Ft));
        const wo = G.morphAttributes;
        if ((wo.position !== void 0 || wo.normal !== void 0 || wo.color !== void 0) && bt.update(k, G, kn), (Ti || Tt.receiveShadow !== k.receiveShadow) && (Tt.receiveShadow = k.receiveShadow, Oe.setValue(D, "receiveShadow", k.receiveShadow)), j.isMeshGouraudMaterial && j.envMap !== null && (ai.envMap.value = yt, ai.flipEnvMap.value = yt.isCubeTexture && yt.isRenderTargetTexture === false ? -1 : 1), j.isMeshStandardMaterial && j.envMap === null && B.environment !== null && (ai.envMapIntensity.value = B.environmentIntensity), Ti && (Oe.setValue(D, "toneMappingExposure", v.toneMappingExposure), Tt.needsLights && fp(ai, go), ot && j.fog === true && rt.refreshFogUniforms(ai, ot), rt.refreshMaterialUniforms(ai, j, J, Y, m.state.transmissionRenderTarget[M.id]), ua.upload(D, Cl(Tt), ai, Ft)), j.isShaderMaterial && j.uniformsNeedUpdate === true && (ua.upload(D, Cl(Tt), ai, Ft), j.uniformsNeedUpdate = false), j.isSpriteMaterial && Oe.setValue(D, "center", k.center), Oe.setValue(D, "modelViewMatrix", k.modelViewMatrix), Oe.setValue(D, "normalMatrix", k.normalMatrix), Oe.setValue(D, "modelMatrix", k.matrixWorld), j.isShaderMaterial || j.isRawShaderMaterial) {
          const un = j.uniformsGroups;
          for (let bo = 0, mp = un.length; bo < mp; bo++) {
            const Il = un[bo];
            zt.update(Il, kn), zt.bind(Il, kn);
          }
        }
        return kn;
      }
      function fp(M, B) {
        M.ambientLightColor.needsUpdate = B, M.lightProbe.needsUpdate = B, M.directionalLights.needsUpdate = B, M.directionalLightShadows.needsUpdate = B, M.pointLights.needsUpdate = B, M.pointLightShadows.needsUpdate = B, M.spotLights.needsUpdate = B, M.spotLightShadows.needsUpdate = B, M.rectAreaLights.needsUpdate = B, M.hemisphereLights.needsUpdate = B;
      }
      function _p(M) {
        return M.isMeshLambertMaterial || M.isMeshToonMaterial || M.isMeshPhongMaterial || M.isMeshStandardMaterial || M.isShadowMaterial || M.isShaderMaterial && M.lights === true;
      }
      this.getActiveCubeFace = function() {
        return O;
      }, this.getActiveMipmapLevel = function() {
        return R;
      }, this.getRenderTarget = function() {
        return P;
      }, this.setRenderTargetTextures = function(M, B, G) {
        Xt.get(M.texture).__webglTexture = B, Xt.get(M.depthTexture).__webglTexture = G;
        const j = Xt.get(M);
        j.__hasExternalTextures = true, j.__autoAllocateDepthBuffer = G === void 0, j.__autoAllocateDepthBuffer || jt.has("WEBGL_multisampled_render_to_texture") === true && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), j.__useRenderToTexture = false);
      }, this.setRenderTargetFramebuffer = function(M, B) {
        const G = Xt.get(M);
        G.__webglFramebuffer = B, G.__useDefaultFramebuffer = B === void 0;
      }, this.setRenderTarget = function(M, B = 0, G = 0) {
        P = M, O = B, R = G;
        let j = true, k = null, ot = false, ft = false;
        if (M) {
          const yt = Xt.get(M);
          yt.__useDefaultFramebuffer !== void 0 ? (At.bindFramebuffer(D.FRAMEBUFFER, null), j = false) : yt.__webglFramebuffer === void 0 ? Ft.setupRenderTarget(M) : yt.__hasExternalTextures && Ft.rebindTextures(M, Xt.get(M.texture).__webglTexture, Xt.get(M.depthTexture).__webglTexture);
          const It = M.texture;
          (It.isData3DTexture || It.isDataArrayTexture || It.isCompressedArrayTexture) && (ft = true);
          const Lt = Xt.get(M).__webglFramebuffer;
          M.isWebGLCubeRenderTarget ? (Array.isArray(Lt[B]) ? k = Lt[B][G] : k = Lt[B], ot = true) : M.samples > 0 && Ft.useMultisampledRTT(M) === false ? k = Xt.get(M).__webglMultisampledFramebuffer : Array.isArray(Lt) ? k = Lt[G] : k = Lt, S.copy(M.viewport), F.copy(M.scissor), W = M.scissorTest;
        } else S.copy(mt).multiplyScalar(J).floor(), F.copy(gt).multiplyScalar(J).floor(), W = qt;
        if (At.bindFramebuffer(D.FRAMEBUFFER, k) && j && At.drawBuffers(M, k), At.viewport(S), At.scissor(F), At.setScissorTest(W), ot) {
          const yt = Xt.get(M.texture);
          D.framebufferTexture2D(D.FRAMEBUFFER, D.COLOR_ATTACHMENT0, D.TEXTURE_CUBE_MAP_POSITIVE_X + B, yt.__webglTexture, G);
        } else if (ft) {
          const yt = Xt.get(M.texture), It = B || 0;
          D.framebufferTextureLayer(D.FRAMEBUFFER, D.COLOR_ATTACHMENT0, yt.__webglTexture, G || 0, It);
        }
        z = -1;
      }, this.readRenderTargetPixels = function(M, B, G, j, k, ot, ft) {
        if (!(M && M.isWebGLRenderTarget)) {
          console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
          return;
        }
        let wt = Xt.get(M).__webglFramebuffer;
        if (M.isWebGLCubeRenderTarget && ft !== void 0 && (wt = wt[ft]), wt) {
          At.bindFramebuffer(D.FRAMEBUFFER, wt);
          try {
            const yt = M.texture, It = yt.format, Lt = yt.type;
            if (!ue.textureFormatReadable(It)) {
              console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
              return;
            }
            if (!ue.textureTypeReadable(Lt)) {
              console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
              return;
            }
            B >= 0 && B <= M.width - j && G >= 0 && G <= M.height - k && D.readPixels(B, G, j, k, pt.convert(It), pt.convert(Lt), ot);
          } finally {
            const yt = P !== null ? Xt.get(P).__webglFramebuffer : null;
            At.bindFramebuffer(D.FRAMEBUFFER, yt);
          }
        }
      }, this.readRenderTargetPixelsAsync = async function(M, B, G, j, k, ot, ft) {
        if (!(M && M.isWebGLRenderTarget)) throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
        let wt = Xt.get(M).__webglFramebuffer;
        if (M.isWebGLCubeRenderTarget && ft !== void 0 && (wt = wt[ft]), wt) {
          At.bindFramebuffer(D.FRAMEBUFFER, wt);
          try {
            const yt = M.texture, It = yt.format, Lt = yt.type;
            if (!ue.textureFormatReadable(It)) throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");
            if (!ue.textureTypeReadable(Lt)) throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");
            if (B >= 0 && B <= M.width - j && G >= 0 && G <= M.height - k) {
              const Rt = D.createBuffer();
              D.bindBuffer(D.PIXEL_PACK_BUFFER, Rt), D.bufferData(D.PIXEL_PACK_BUFFER, ot.byteLength, D.STREAM_READ), D.readPixels(B, G, j, k, pt.convert(It), pt.convert(Lt), 0), D.flush();
              const re = D.fenceSync(D.SYNC_GPU_COMMANDS_COMPLETE, 0);
              await Bf(D, re, 4);
              try {
                D.bindBuffer(D.PIXEL_PACK_BUFFER, Rt), D.getBufferSubData(D.PIXEL_PACK_BUFFER, 0, ot);
              } finally {
                D.deleteBuffer(Rt), D.deleteSync(re);
              }
              return ot;
            }
          } finally {
            const yt = P !== null ? Xt.get(P).__webglFramebuffer : null;
            At.bindFramebuffer(D.FRAMEBUFFER, yt);
          }
        }
      }, this.copyFramebufferToTexture = function(M, B = null, G = 0) {
        M.isTexture !== true && (console.warn("WebGLRenderer: copyFramebufferToTexture function signature has changed."), B = arguments[0] || null, M = arguments[1]);
        const j = Math.pow(2, -G), k = Math.floor(M.image.width * j), ot = Math.floor(M.image.height * j), ft = B !== null ? B.x : 0, wt = B !== null ? B.y : 0;
        Ft.setTexture2D(M, 0), D.copyTexSubImage2D(D.TEXTURE_2D, G, 0, 0, ft, wt, k, ot), At.unbindTexture();
      }, this.copyTextureToTexture = function(M, B, G = null, j = null, k = 0) {
        M.isTexture !== true && (console.warn("WebGLRenderer: copyTextureToTexture function signature has changed."), j = arguments[0] || null, M = arguments[1], B = arguments[2], k = arguments[3] || 0, G = null);
        let ot, ft, wt, yt, It, Lt;
        G !== null ? (ot = G.max.x - G.min.x, ft = G.max.y - G.min.y, wt = G.min.x, yt = G.min.y) : (ot = M.image.width, ft = M.image.height, wt = 0, yt = 0), j !== null ? (It = j.x, Lt = j.y) : (It = 0, Lt = 0);
        const Rt = pt.convert(B.format), re = pt.convert(B.type);
        Ft.setTexture2D(B, 0), D.pixelStorei(D.UNPACK_FLIP_Y_WEBGL, B.flipY), D.pixelStorei(D.UNPACK_PREMULTIPLY_ALPHA_WEBGL, B.premultiplyAlpha), D.pixelStorei(D.UNPACK_ALIGNMENT, B.unpackAlignment);
        const Me = D.getParameter(D.UNPACK_ROW_LENGTH), Ee = D.getParameter(D.UNPACK_IMAGE_HEIGHT), cn = D.getParameter(D.UNPACK_SKIP_PIXELS), se = D.getParameter(D.UNPACK_SKIP_ROWS), Tt = D.getParameter(D.UNPACK_SKIP_IMAGES), Ze = M.isCompressedTexture ? M.mipmaps[k] : M.image;
        D.pixelStorei(D.UNPACK_ROW_LENGTH, Ze.width), D.pixelStorei(D.UNPACK_IMAGE_HEIGHT, Ze.height), D.pixelStorei(D.UNPACK_SKIP_PIXELS, wt), D.pixelStorei(D.UNPACK_SKIP_ROWS, yt), M.isDataTexture ? D.texSubImage2D(D.TEXTURE_2D, k, It, Lt, ot, ft, Rt, re, Ze.data) : M.isCompressedTexture ? D.compressedTexSubImage2D(D.TEXTURE_2D, k, It, Lt, Ze.width, Ze.height, Rt, Ze.data) : D.texSubImage2D(D.TEXTURE_2D, k, It, Lt, Rt, re, Ze), D.pixelStorei(D.UNPACK_ROW_LENGTH, Me), D.pixelStorei(D.UNPACK_IMAGE_HEIGHT, Ee), D.pixelStorei(D.UNPACK_SKIP_PIXELS, cn), D.pixelStorei(D.UNPACK_SKIP_ROWS, se), D.pixelStorei(D.UNPACK_SKIP_IMAGES, Tt), k === 0 && B.generateMipmaps && D.generateMipmap(D.TEXTURE_2D), At.unbindTexture();
      }, this.copyTextureToTexture3D = function(M, B, G = null, j = null, k = 0) {
        M.isTexture !== true && (console.warn("WebGLRenderer: copyTextureToTexture3D function signature has changed."), G = arguments[0] || null, j = arguments[1] || null, M = arguments[2], B = arguments[3], k = arguments[4] || 0);
        let ot, ft, wt, yt, It, Lt, Rt, re, Me;
        const Ee = M.isCompressedTexture ? M.mipmaps[k] : M.image;
        G !== null ? (ot = G.max.x - G.min.x, ft = G.max.y - G.min.y, wt = G.max.z - G.min.z, yt = G.min.x, It = G.min.y, Lt = G.min.z) : (ot = Ee.width, ft = Ee.height, wt = Ee.depth, yt = 0, It = 0, Lt = 0), j !== null ? (Rt = j.x, re = j.y, Me = j.z) : (Rt = 0, re = 0, Me = 0);
        const cn = pt.convert(B.format), se = pt.convert(B.type);
        let Tt;
        if (B.isData3DTexture) Ft.setTexture3D(B, 0), Tt = D.TEXTURE_3D;
        else if (B.isDataArrayTexture || B.isCompressedArrayTexture) Ft.setTexture2DArray(B, 0), Tt = D.TEXTURE_2D_ARRAY;
        else {
          console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
          return;
        }
        D.pixelStorei(D.UNPACK_FLIP_Y_WEBGL, B.flipY), D.pixelStorei(D.UNPACK_PREMULTIPLY_ALPHA_WEBGL, B.premultiplyAlpha), D.pixelStorei(D.UNPACK_ALIGNMENT, B.unpackAlignment);
        const Ze = D.getParameter(D.UNPACK_ROW_LENGTH), ce = D.getParameter(D.UNPACK_IMAGE_HEIGHT), kn = D.getParameter(D.UNPACK_SKIP_PIXELS), Es = D.getParameter(D.UNPACK_SKIP_ROWS), Ti = D.getParameter(D.UNPACK_SKIP_IMAGES);
        D.pixelStorei(D.UNPACK_ROW_LENGTH, Ee.width), D.pixelStorei(D.UNPACK_IMAGE_HEIGHT, Ee.height), D.pixelStorei(D.UNPACK_SKIP_PIXELS, yt), D.pixelStorei(D.UNPACK_SKIP_ROWS, It), D.pixelStorei(D.UNPACK_SKIP_IMAGES, Lt), M.isDataTexture || M.isData3DTexture ? D.texSubImage3D(Tt, k, Rt, re, Me, ot, ft, wt, cn, se, Ee.data) : B.isCompressedArrayTexture ? D.compressedTexSubImage3D(Tt, k, Rt, re, Me, ot, ft, wt, cn, Ee.data) : D.texSubImage3D(Tt, k, Rt, re, Me, ot, ft, wt, cn, se, Ee), D.pixelStorei(D.UNPACK_ROW_LENGTH, Ze), D.pixelStorei(D.UNPACK_IMAGE_HEIGHT, ce), D.pixelStorei(D.UNPACK_SKIP_PIXELS, kn), D.pixelStorei(D.UNPACK_SKIP_ROWS, Es), D.pixelStorei(D.UNPACK_SKIP_IMAGES, Ti), k === 0 && B.generateMipmaps && D.generateMipmap(Tt), At.unbindTexture();
      }, this.initRenderTarget = function(M) {
        Xt.get(M).__webglFramebuffer === void 0 && Ft.setupRenderTarget(M);
      }, this.initTexture = function(M) {
        M.isCubeTexture ? Ft.setTextureCube(M, 0) : M.isData3DTexture ? Ft.setTexture3D(M, 0) : M.isDataArrayTexture || M.isCompressedArrayTexture ? Ft.setTexture2DArray(M, 0) : Ft.setTexture2D(M, 0), At.unbindTexture();
      }, this.resetState = function() {
        O = 0, R = 0, P = null, At.reset(), Bt.reset();
      }, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
        detail: this
      }));
    }
    get coordinateSystem() {
      return $n;
    }
    get outputColorSpace() {
      return this._outputColorSpace;
    }
    set outputColorSpace(t) {
      this._outputColorSpace = t;
      const e = this.getContext();
      e.drawingBufferColorSpace = t === Lc ? "display-p3" : "srgb", e.unpackColorSpace = ie.workingColorSpace === za ? "display-p3" : "srgb";
    }
  }
  class j0 extends _e {
    constructor() {
      super(), this.isScene = true, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.backgroundRotation = new Pn(), this.environmentIntensity = 1, this.environmentRotation = new Pn(), this.overrideMaterial = null, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
        detail: this
      }));
    }
    copy(t, e) {
      return super.copy(t, e), t.background !== null && (this.background = t.background.clone()), t.environment !== null && (this.environment = t.environment.clone()), t.fog !== null && (this.fog = t.fog.clone()), this.backgroundBlurriness = t.backgroundBlurriness, this.backgroundIntensity = t.backgroundIntensity, this.backgroundRotation.copy(t.backgroundRotation), this.environmentIntensity = t.environmentIntensity, this.environmentRotation.copy(t.environmentRotation), t.overrideMaterial !== null && (this.overrideMaterial = t.overrideMaterial.clone()), this.matrixAutoUpdate = t.matrixAutoUpdate, this;
    }
    toJSON(t) {
      const e = super.toJSON(t);
      return this.fog !== null && (e.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (e.object.backgroundBlurriness = this.backgroundBlurriness), this.backgroundIntensity !== 1 && (e.object.backgroundIntensity = this.backgroundIntensity), e.object.backgroundRotation = this.backgroundRotation.toArray(), this.environmentIntensity !== 1 && (e.object.environmentIntensity = this.environmentIntensity), e.object.environmentRotation = this.environmentRotation.toArray(), e;
    }
  }
  class Hu {
    constructor(t, e) {
      this.isInterleavedBuffer = true, this.array = t, this.stride = e, this.count = t !== void 0 ? t.length / e : 0, this.usage = Sc, this._updateRange = {
        offset: 0,
        count: -1
      }, this.updateRanges = [], this.version = 0, this.uuid = An();
    }
    onUploadCallback() {
    }
    set needsUpdate(t) {
      t === true && this.version++;
    }
    get updateRange() {
      return Nc("THREE.InterleavedBuffer: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."), this._updateRange;
    }
    setUsage(t) {
      return this.usage = t, this;
    }
    addUpdateRange(t, e) {
      this.updateRanges.push({
        start: t,
        count: e
      });
    }
    clearUpdateRanges() {
      this.updateRanges.length = 0;
    }
    copy(t) {
      return this.array = new t.array.constructor(t.array), this.count = t.count, this.stride = t.stride, this.usage = t.usage, this;
    }
    copyAt(t, e, n) {
      t *= this.stride, n *= e.stride;
      for (let i = 0, s = this.stride; i < s; i++) this.array[t + i] = e.array[n + i];
      return this;
    }
    set(t, e = 0) {
      return this.array.set(t, e), this;
    }
    clone(t) {
      t.arrayBuffers === void 0 && (t.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = An()), t.arrayBuffers[this.array.buffer._uuid] === void 0 && (t.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
      const e = new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]), n = new this.constructor(e, this.stride);
      return n.setUsage(this.usage), n;
    }
    onUpload(t) {
      return this.onUploadCallback = t, this;
    }
    toJSON(t) {
      return t.arrayBuffers === void 0 && (t.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = An()), t.arrayBuffers[this.array.buffer._uuid] === void 0 && (t.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), {
        uuid: this.uuid,
        buffer: this.array.buffer._uuid,
        type: this.array.constructor.name,
        stride: this.stride
      };
    }
  }
  const $e = new L();
  class ds {
    constructor(t, e, n, i = false) {
      this.isInterleavedBufferAttribute = true, this.name = "", this.data = t, this.itemSize = e, this.offset = n, this.normalized = i;
    }
    get count() {
      return this.data.count;
    }
    get array() {
      return this.data.array;
    }
    set needsUpdate(t) {
      this.data.needsUpdate = t;
    }
    applyMatrix4(t) {
      for (let e = 0, n = this.data.count; e < n; e++) $e.fromBufferAttribute(this, e), $e.applyMatrix4(t), this.setXYZ(e, $e.x, $e.y, $e.z);
      return this;
    }
    applyNormalMatrix(t) {
      for (let e = 0, n = this.count; e < n; e++) $e.fromBufferAttribute(this, e), $e.applyNormalMatrix(t), this.setXYZ(e, $e.x, $e.y, $e.z);
      return this;
    }
    transformDirection(t) {
      for (let e = 0, n = this.count; e < n; e++) $e.fromBufferAttribute(this, e), $e.transformDirection(t), this.setXYZ(e, $e.x, $e.y, $e.z);
      return this;
    }
    getComponent(t, e) {
      let n = this.array[t * this.data.stride + this.offset + e];
      return this.normalized && (n = En(n, this.array)), n;
    }
    setComponent(t, e, n) {
      return this.normalized && (n = ae(n, this.array)), this.data.array[t * this.data.stride + this.offset + e] = n, this;
    }
    setX(t, e) {
      return this.normalized && (e = ae(e, this.array)), this.data.array[t * this.data.stride + this.offset] = e, this;
    }
    setY(t, e) {
      return this.normalized && (e = ae(e, this.array)), this.data.array[t * this.data.stride + this.offset + 1] = e, this;
    }
    setZ(t, e) {
      return this.normalized && (e = ae(e, this.array)), this.data.array[t * this.data.stride + this.offset + 2] = e, this;
    }
    setW(t, e) {
      return this.normalized && (e = ae(e, this.array)), this.data.array[t * this.data.stride + this.offset + 3] = e, this;
    }
    getX(t) {
      let e = this.data.array[t * this.data.stride + this.offset];
      return this.normalized && (e = En(e, this.array)), e;
    }
    getY(t) {
      let e = this.data.array[t * this.data.stride + this.offset + 1];
      return this.normalized && (e = En(e, this.array)), e;
    }
    getZ(t) {
      let e = this.data.array[t * this.data.stride + this.offset + 2];
      return this.normalized && (e = En(e, this.array)), e;
    }
    getW(t) {
      let e = this.data.array[t * this.data.stride + this.offset + 3];
      return this.normalized && (e = En(e, this.array)), e;
    }
    setXY(t, e, n) {
      return t = t * this.data.stride + this.offset, this.normalized && (e = ae(e, this.array), n = ae(n, this.array)), this.data.array[t + 0] = e, this.data.array[t + 1] = n, this;
    }
    setXYZ(t, e, n, i) {
      return t = t * this.data.stride + this.offset, this.normalized && (e = ae(e, this.array), n = ae(n, this.array), i = ae(i, this.array)), this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = i, this;
    }
    setXYZW(t, e, n, i, s) {
      return t = t * this.data.stride + this.offset, this.normalized && (e = ae(e, this.array), n = ae(n, this.array), i = ae(i, this.array), s = ae(s, this.array)), this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = i, this.data.array[t + 3] = s, this;
    }
    clone(t) {
      if (t === void 0) {
        console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
        const e = [];
        for (let n = 0; n < this.count; n++) {
          const i = n * this.data.stride + this.offset;
          for (let s = 0; s < this.itemSize; s++) e.push(this.data.array[i + s]);
        }
        return new rn(new this.array.constructor(e), this.itemSize, this.normalized);
      } else return t.interleavedBuffers === void 0 && (t.interleavedBuffers = {}), t.interleavedBuffers[this.data.uuid] === void 0 && (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)), new ds(t.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
    }
    toJSON(t) {
      if (t === void 0) {
        console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
        const e = [];
        for (let n = 0; n < this.count; n++) {
          const i = n * this.data.stride + this.offset;
          for (let s = 0; s < this.itemSize; s++) e.push(this.data.array[i + s]);
        }
        return {
          itemSize: this.itemSize,
          type: this.array.constructor.name,
          array: e,
          normalized: this.normalized
        };
      } else return t.interleavedBuffers === void 0 && (t.interleavedBuffers = {}), t.interleavedBuffers[this.data.uuid] === void 0 && (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)), {
        isInterleavedBufferAttribute: true,
        itemSize: this.itemSize,
        data: this.data.uuid,
        offset: this.offset,
        normalized: this.normalized
      };
    }
  }
  class Gu extends Rn {
    constructor(t) {
      super(), this.isSpriteMaterial = true, this.type = "SpriteMaterial", this.color = new Ct(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = true, this.transparent = true, this.fog = true, this.setValues(t);
    }
    copy(t) {
      return super.copy(t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.rotation = t.rotation, this.sizeAttenuation = t.sizeAttenuation, this.fog = t.fog, this;
    }
  }
  let lr;
  const jr = new L(), hr = new L(), dr = new L(), ur = new vt(), Xr = new vt(), Vu = new Ht(), qs = new L(), qr = new L(), Ks = new L(), nd = new vt(), $o = new vt(), id = new vt();
  class X0 extends _e {
    constructor(t = new Gu()) {
      if (super(), this.isSprite = true, this.type = "Sprite", lr === void 0) {
        lr = new sn();
        const e = new Float32Array([
          -0.5,
          -0.5,
          0,
          0,
          0,
          0.5,
          -0.5,
          0,
          1,
          0,
          0.5,
          0.5,
          0,
          1,
          1,
          -0.5,
          0.5,
          0,
          0,
          1
        ]), n = new Hu(e, 5);
        lr.setIndex([
          0,
          1,
          2,
          0,
          2,
          3
        ]), lr.setAttribute("position", new ds(n, 3, 0, false)), lr.setAttribute("uv", new ds(n, 2, 3, false));
      }
      this.geometry = lr, this.material = t, this.center = new vt(0.5, 0.5);
    }
    raycast(t, e) {
      t.camera === null && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), hr.setFromMatrixScale(this.matrixWorld), Vu.copy(t.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse, this.matrixWorld), dr.setFromMatrixPosition(this.modelViewMatrix), t.camera.isPerspectiveCamera && this.material.sizeAttenuation === false && hr.multiplyScalar(-dr.z);
      const n = this.material.rotation;
      let i, s;
      n !== 0 && (s = Math.cos(n), i = Math.sin(n));
      const a = this.center;
      Ys(qs.set(-0.5, -0.5, 0), dr, a, hr, i, s), Ys(qr.set(0.5, -0.5, 0), dr, a, hr, i, s), Ys(Ks.set(0.5, 0.5, 0), dr, a, hr, i, s), nd.set(0, 0), $o.set(1, 0), id.set(1, 1);
      let o = t.ray.intersectTriangle(qs, qr, Ks, false, jr);
      if (o === null && (Ys(qr.set(-0.5, 0.5, 0), dr, a, hr, i, s), $o.set(0, 1), o = t.ray.intersectTriangle(qs, Ks, qr, false, jr), o === null)) return;
      const c = t.ray.origin.distanceTo(jr);
      c < t.near || c > t.far || e.push({
        distance: c,
        point: jr.clone(),
        uv: es.getInterpolation(jr, qs, qr, Ks, nd, $o, id, new vt()),
        face: null,
        object: this
      });
    }
    copy(t, e) {
      return super.copy(t, e), t.center !== void 0 && this.center.copy(t.center), this.material = t.material, this;
    }
  }
  function Ys(r, t, e, n, i, s) {
    ur.subVectors(r, e).addScalar(0.5).multiply(n), i !== void 0 ? (Xr.x = s * ur.x - i * ur.y, Xr.y = i * ur.x + s * ur.y) : Xr.copy(ur), r.copy(t), r.x += Xr.x, r.y += Xr.y, r.applyMatrix4(Vu);
  }
  const rd = new L(), sd = new de(), ad = new de(), q0 = new L(), od = new Ht(), Zs = new L(), Jo = new On(), cd = new Ht(), Qo = new bs();
  class K0 extends fe {
    constructor(t, e) {
      super(t, e), this.isSkinnedMesh = true, this.type = "SkinnedMesh", this.bindMode = Fl, this.bindMatrix = new Ht(), this.bindMatrixInverse = new Ht(), this.boundingBox = null, this.boundingSphere = null;
    }
    computeBoundingBox() {
      const t = this.geometry;
      this.boundingBox === null && (this.boundingBox = new Fn()), this.boundingBox.makeEmpty();
      const e = t.getAttribute("position");
      for (let n = 0; n < e.count; n++) this.getVertexPosition(n, Zs), this.boundingBox.expandByPoint(Zs);
    }
    computeBoundingSphere() {
      const t = this.geometry;
      this.boundingSphere === null && (this.boundingSphere = new On()), this.boundingSphere.makeEmpty();
      const e = t.getAttribute("position");
      for (let n = 0; n < e.count; n++) this.getVertexPosition(n, Zs), this.boundingSphere.expandByPoint(Zs);
    }
    copy(t, e) {
      return super.copy(t, e), this.bindMode = t.bindMode, this.bindMatrix.copy(t.bindMatrix), this.bindMatrixInverse.copy(t.bindMatrixInverse), this.skeleton = t.skeleton, t.boundingBox !== null && (this.boundingBox = t.boundingBox.clone()), t.boundingSphere !== null && (this.boundingSphere = t.boundingSphere.clone()), this;
    }
    raycast(t, e) {
      const n = this.material, i = this.matrixWorld;
      n !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), Jo.copy(this.boundingSphere), Jo.applyMatrix4(i), t.ray.intersectsSphere(Jo) !== false && (cd.copy(i).invert(), Qo.copy(t.ray).applyMatrix4(cd), !(this.boundingBox !== null && Qo.intersectsBox(this.boundingBox) === false) && this._computeIntersections(t, e, Qo)));
    }
    getVertexPosition(t, e) {
      return super.getVertexPosition(t, e), this.applyBoneTransform(t, e), e;
    }
    bind(t, e) {
      this.skeleton = t, e === void 0 && (this.updateMatrixWorld(true), this.skeleton.calculateInverses(), e = this.matrixWorld), this.bindMatrix.copy(e), this.bindMatrixInverse.copy(e).invert();
    }
    pose() {
      this.skeleton.pose();
    }
    normalizeSkinWeights() {
      const t = new de(), e = this.geometry.attributes.skinWeight;
      for (let n = 0, i = e.count; n < i; n++) {
        t.fromBufferAttribute(e, n);
        const s = 1 / t.manhattanLength();
        s !== 1 / 0 ? t.multiplyScalar(s) : t.set(1, 0, 0, 0), e.setXYZW(n, t.x, t.y, t.z, t.w);
      }
    }
    updateMatrixWorld(t) {
      super.updateMatrixWorld(t), this.bindMode === Fl ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === Jp ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
    }
    applyBoneTransform(t, e) {
      const n = this.skeleton, i = this.geometry;
      sd.fromBufferAttribute(i.attributes.skinIndex, t), ad.fromBufferAttribute(i.attributes.skinWeight, t), rd.copy(e).applyMatrix4(this.bindMatrix), e.set(0, 0, 0);
      for (let s = 0; s < 4; s++) {
        const a = ad.getComponent(s);
        if (a !== 0) {
          const o = sd.getComponent(s);
          od.multiplyMatrices(n.bones[o].matrixWorld, n.boneInverses[o]), e.addScaledVector(q0.copy(rd).applyMatrix4(od), a);
        }
      }
      return e.applyMatrix4(this.bindMatrixInverse);
    }
  }
  class Wu extends _e {
    constructor() {
      super(), this.isBone = true, this.type = "Bone";
    }
  }
  class ju extends Ne {
    constructor(t = null, e = 1, n = 1, i, s, a, o, c, l = en, h = en, d, u) {
      super(null, a, o, c, l, h, i, s, d, u), this.isDataTexture = true, this.image = {
        data: t,
        width: e,
        height: n
      }, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1;
    }
  }
  const ld = new Ht(), Y0 = new Ht();
  class Bc {
    constructor(t = [], e = []) {
      this.uuid = An(), this.bones = t.slice(0), this.boneInverses = e, this.boneMatrices = null, this.boneTexture = null, this.init();
    }
    init() {
      const t = this.bones, e = this.boneInverses;
      if (this.boneMatrices = new Float32Array(t.length * 16), e.length === 0) this.calculateInverses();
      else if (t.length !== e.length) {
        console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
        for (let n = 0, i = this.bones.length; n < i; n++) this.boneInverses.push(new Ht());
      }
    }
    calculateInverses() {
      this.boneInverses.length = 0;
      for (let t = 0, e = this.bones.length; t < e; t++) {
        const n = new Ht();
        this.bones[t] && n.copy(this.bones[t].matrixWorld).invert(), this.boneInverses.push(n);
      }
    }
    pose() {
      for (let t = 0, e = this.bones.length; t < e; t++) {
        const n = this.bones[t];
        n && n.matrixWorld.copy(this.boneInverses[t]).invert();
      }
      for (let t = 0, e = this.bones.length; t < e; t++) {
        const n = this.bones[t];
        n && (n.parent && n.parent.isBone ? (n.matrix.copy(n.parent.matrixWorld).invert(), n.matrix.multiply(n.matrixWorld)) : n.matrix.copy(n.matrixWorld), n.matrix.decompose(n.position, n.quaternion, n.scale));
      }
    }
    update() {
      const t = this.bones, e = this.boneInverses, n = this.boneMatrices, i = this.boneTexture;
      for (let s = 0, a = t.length; s < a; s++) {
        const o = t[s] ? t[s].matrixWorld : Y0;
        ld.multiplyMatrices(o, e[s]), ld.toArray(n, s * 16);
      }
      i !== null && (i.needsUpdate = true);
    }
    clone() {
      return new Bc(this.bones, this.boneInverses);
    }
    computeBoneTexture() {
      let t = Math.sqrt(this.bones.length * 4);
      t = Math.ceil(t / 4) * 4, t = Math.max(t, 4);
      const e = new Float32Array(t * t * 4);
      e.set(this.boneMatrices);
      const n = new ju(e, t, t, Tn, Dn);
      return n.needsUpdate = true, this.boneMatrices = e, this.boneTexture = n, this;
    }
    getBoneByName(t) {
      for (let e = 0, n = this.bones.length; e < n; e++) {
        const i = this.bones[e];
        if (i.name === t) return i;
      }
    }
    dispose() {
      this.boneTexture !== null && (this.boneTexture.dispose(), this.boneTexture = null);
    }
    fromJSON(t, e) {
      this.uuid = t.uuid;
      for (let n = 0, i = t.bones.length; n < i; n++) {
        const s = t.bones[n];
        let a = e[s];
        a === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", s), a = new Wu()), this.bones.push(a), this.boneInverses.push(new Ht().fromArray(t.boneInverses[n]));
      }
      return this.init(), this;
    }
    toJSON() {
      const t = {
        metadata: {
          version: 4.6,
          type: "Skeleton",
          generator: "Skeleton.toJSON"
        },
        bones: [],
        boneInverses: []
      };
      t.uuid = this.uuid;
      const e = this.bones, n = this.boneInverses;
      for (let i = 0, s = e.length; i < s; i++) {
        const a = e[i];
        t.bones.push(a.uuid);
        const o = n[i];
        t.boneInverses.push(o.toArray());
      }
      return t;
    }
  }
  class Ec extends rn {
    constructor(t, e, n, i = 1) {
      super(t, e, n), this.isInstancedBufferAttribute = true, this.meshPerAttribute = i;
    }
    copy(t) {
      return super.copy(t), this.meshPerAttribute = t.meshPerAttribute, this;
    }
    toJSON() {
      const t = super.toJSON();
      return t.meshPerAttribute = this.meshPerAttribute, t.isInstancedBufferAttribute = true, t;
    }
  }
  const pr = new Ht(), hd = new Ht(), $s = [], dd = new Fn(), Z0 = new Ht(), Kr = new fe(), Yr = new On();
  class $0 extends fe {
    constructor(t, e, n) {
      super(t, e), this.isInstancedMesh = true, this.instanceMatrix = new Ec(new Float32Array(n * 16), 16), this.instanceColor = null, this.morphTexture = null, this.count = n, this.boundingBox = null, this.boundingSphere = null;
      for (let i = 0; i < n; i++) this.setMatrixAt(i, Z0);
    }
    computeBoundingBox() {
      const t = this.geometry, e = this.count;
      this.boundingBox === null && (this.boundingBox = new Fn()), t.boundingBox === null && t.computeBoundingBox(), this.boundingBox.makeEmpty();
      for (let n = 0; n < e; n++) this.getMatrixAt(n, pr), dd.copy(t.boundingBox).applyMatrix4(pr), this.boundingBox.union(dd);
    }
    computeBoundingSphere() {
      const t = this.geometry, e = this.count;
      this.boundingSphere === null && (this.boundingSphere = new On()), t.boundingSphere === null && t.computeBoundingSphere(), this.boundingSphere.makeEmpty();
      for (let n = 0; n < e; n++) this.getMatrixAt(n, pr), Yr.copy(t.boundingSphere).applyMatrix4(pr), this.boundingSphere.union(Yr);
    }
    copy(t, e) {
      return super.copy(t, e), this.instanceMatrix.copy(t.instanceMatrix), t.morphTexture !== null && (this.morphTexture = t.morphTexture.clone()), t.instanceColor !== null && (this.instanceColor = t.instanceColor.clone()), this.count = t.count, t.boundingBox !== null && (this.boundingBox = t.boundingBox.clone()), t.boundingSphere !== null && (this.boundingSphere = t.boundingSphere.clone()), this;
    }
    getColorAt(t, e) {
      e.fromArray(this.instanceColor.array, t * 3);
    }
    getMatrixAt(t, e) {
      e.fromArray(this.instanceMatrix.array, t * 16);
    }
    getMorphAt(t, e) {
      const n = e.morphTargetInfluences, i = this.morphTexture.source.data.data, s = n.length + 1, a = t * s + 1;
      for (let o = 0; o < n.length; o++) n[o] = i[a + o];
    }
    raycast(t, e) {
      const n = this.matrixWorld, i = this.count;
      if (Kr.geometry = this.geometry, Kr.material = this.material, Kr.material !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), Yr.copy(this.boundingSphere), Yr.applyMatrix4(n), t.ray.intersectsSphere(Yr) !== false)) for (let s = 0; s < i; s++) {
        this.getMatrixAt(s, pr), hd.multiplyMatrices(n, pr), Kr.matrixWorld = hd, Kr.raycast(t, $s);
        for (let a = 0, o = $s.length; a < o; a++) {
          const c = $s[a];
          c.instanceId = s, c.object = this, e.push(c);
        }
        $s.length = 0;
      }
    }
    setColorAt(t, e) {
      this.instanceColor === null && (this.instanceColor = new Ec(new Float32Array(this.instanceMatrix.count * 3), 3)), e.toArray(this.instanceColor.array, t * 3);
    }
    setMatrixAt(t, e) {
      e.toArray(this.instanceMatrix.array, t * 16);
    }
    setMorphAt(t, e) {
      const n = e.morphTargetInfluences, i = n.length + 1;
      this.morphTexture === null && (this.morphTexture = new ju(new Float32Array(i * this.count), i, this.count, _u, Dn));
      const s = this.morphTexture.source.data.data;
      let a = 0;
      for (let l = 0; l < n.length; l++) a += n[l];
      const o = this.geometry.morphTargetsRelative ? 1 : 1 - a, c = i * t;
      s[c] = o, s.set(n, c + 1);
    }
    updateMorphTargets() {
    }
    dispose() {
      return this.dispatchEvent({
        type: "dispose"
      }), this.morphTexture !== null && (this.morphTexture.dispose(), this.morphTexture = null), this;
    }
  }
  class Ha extends Rn {
    constructor(t) {
      super(), this.isLineBasicMaterial = true, this.type = "LineBasicMaterial", this.color = new Ct(16777215), this.map = null, this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = true, this.setValues(t);
    }
    copy(t) {
      return super.copy(t), this.color.copy(t.color), this.map = t.map, this.linewidth = t.linewidth, this.linecap = t.linecap, this.linejoin = t.linejoin, this.fog = t.fog, this;
    }
  }
  const ya = new L(), va = new L(), ud = new Ht(), Zr = new bs(), Js = new On(), tc = new L(), pd = new L();
  class zc extends _e {
    constructor(t = new sn(), e = new Ha()) {
      super(), this.isLine = true, this.type = "Line", this.geometry = t, this.material = e, this.updateMorphTargets();
    }
    copy(t, e) {
      return super.copy(t, e), this.material = Array.isArray(t.material) ? t.material.slice() : t.material, this.geometry = t.geometry, this;
    }
    computeLineDistances() {
      const t = this.geometry;
      if (t.index === null) {
        const e = t.attributes.position, n = [
          0
        ];
        for (let i = 1, s = e.count; i < s; i++) ya.fromBufferAttribute(e, i - 1), va.fromBufferAttribute(e, i), n[i] = n[i - 1], n[i] += ya.distanceTo(va);
        t.setAttribute("lineDistance", new We(n, 1));
      } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
      return this;
    }
    raycast(t, e) {
      const n = this.geometry, i = this.matrixWorld, s = t.params.Line.threshold, a = n.drawRange;
      if (n.boundingSphere === null && n.computeBoundingSphere(), Js.copy(n.boundingSphere), Js.applyMatrix4(i), Js.radius += s, t.ray.intersectsSphere(Js) === false) return;
      ud.copy(i).invert(), Zr.copy(t.ray).applyMatrix4(ud);
      const o = s / ((this.scale.x + this.scale.y + this.scale.z) / 3), c = o * o, l = this.isLineSegments ? 2 : 1, h = n.index, u = n.attributes.position;
      if (h !== null) {
        const p = Math.max(0, a.start), w = Math.min(h.count, a.start + a.count);
        for (let b = p, m = w - 1; b < m; b += l) {
          const _ = h.getX(b), E = h.getX(b + 1), v = Qs(this, t, Zr, c, _, E);
          v && e.push(v);
        }
        if (this.isLineLoop) {
          const b = h.getX(w - 1), m = h.getX(p), _ = Qs(this, t, Zr, c, b, m);
          _ && e.push(_);
        }
      } else {
        const p = Math.max(0, a.start), w = Math.min(u.count, a.start + a.count);
        for (let b = p, m = w - 1; b < m; b += l) {
          const _ = Qs(this, t, Zr, c, b, b + 1);
          _ && e.push(_);
        }
        if (this.isLineLoop) {
          const b = Qs(this, t, Zr, c, w - 1, p);
          b && e.push(b);
        }
      }
    }
    updateMorphTargets() {
      const e = this.geometry.morphAttributes, n = Object.keys(e);
      if (n.length > 0) {
        const i = e[n[0]];
        if (i !== void 0) {
          this.morphTargetInfluences = [], this.morphTargetDictionary = {};
          for (let s = 0, a = i.length; s < a; s++) {
            const o = i[s].name || String(s);
            this.morphTargetInfluences.push(0), this.morphTargetDictionary[o] = s;
          }
        }
      }
    }
  }
  function Qs(r, t, e, n, i, s) {
    const a = r.geometry.attributes.position;
    if (ya.fromBufferAttribute(a, i), va.fromBufferAttribute(a, s), e.distanceSqToSegment(ya, va, tc, pd) > n) return;
    tc.applyMatrix4(r.matrixWorld);
    const c = t.ray.origin.distanceTo(tc);
    if (!(c < t.near || c > t.far)) return {
      distance: c,
      point: pd.clone().applyMatrix4(r.matrixWorld),
      index: i,
      face: null,
      faceIndex: null,
      object: r
    };
  }
  const fd = new L(), _d = new L();
  class Xu extends zc {
    constructor(t, e) {
      super(t, e), this.isLineSegments = true, this.type = "LineSegments";
    }
    computeLineDistances() {
      const t = this.geometry;
      if (t.index === null) {
        const e = t.attributes.position, n = [];
        for (let i = 0, s = e.count; i < s; i += 2) fd.fromBufferAttribute(e, i), _d.fromBufferAttribute(e, i + 1), n[i] = i === 0 ? 0 : n[i - 1], n[i + 1] = n[i] + fd.distanceTo(_d);
        t.setAttribute("lineDistance", new We(n, 1));
      } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
      return this;
    }
  }
  class qu extends zc {
    constructor(t, e) {
      super(t, e), this.isLineLoop = true, this.type = "LineLoop";
    }
  }
  class Ku extends Rn {
    constructor(t) {
      super(), this.isPointsMaterial = true, this.type = "PointsMaterial", this.color = new Ct(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = true, this.fog = true, this.setValues(t);
    }
    copy(t) {
      return super.copy(t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.size = t.size, this.sizeAttenuation = t.sizeAttenuation, this.fog = t.fog, this;
    }
  }
  const md = new Ht(), Tc = new bs(), ta = new On(), ea = new L();
  class J0 extends _e {
    constructor(t = new sn(), e = new Ku()) {
      super(), this.isPoints = true, this.type = "Points", this.geometry = t, this.material = e, this.updateMorphTargets();
    }
    copy(t, e) {
      return super.copy(t, e), this.material = Array.isArray(t.material) ? t.material.slice() : t.material, this.geometry = t.geometry, this;
    }
    raycast(t, e) {
      const n = this.geometry, i = this.matrixWorld, s = t.params.Points.threshold, a = n.drawRange;
      if (n.boundingSphere === null && n.computeBoundingSphere(), ta.copy(n.boundingSphere), ta.applyMatrix4(i), ta.radius += s, t.ray.intersectsSphere(ta) === false) return;
      md.copy(i).invert(), Tc.copy(t.ray).applyMatrix4(md);
      const o = s / ((this.scale.x + this.scale.y + this.scale.z) / 3), c = o * o, l = n.index, d = n.attributes.position;
      if (l !== null) {
        const u = Math.max(0, a.start), p = Math.min(l.count, a.start + a.count);
        for (let w = u, b = p; w < b; w++) {
          const m = l.getX(w);
          ea.fromBufferAttribute(d, m), gd(ea, m, c, i, t, e, this);
        }
      } else {
        const u = Math.max(0, a.start), p = Math.min(d.count, a.start + a.count);
        for (let w = u, b = p; w < b; w++) ea.fromBufferAttribute(d, w), gd(ea, w, c, i, t, e, this);
      }
    }
    updateMorphTargets() {
      const e = this.geometry.morphAttributes, n = Object.keys(e);
      if (n.length > 0) {
        const i = e[n[0]];
        if (i !== void 0) {
          this.morphTargetInfluences = [], this.morphTargetDictionary = {};
          for (let s = 0, a = i.length; s < a; s++) {
            const o = i[s].name || String(s);
            this.morphTargetInfluences.push(0), this.morphTargetDictionary[o] = s;
          }
        }
      }
    }
  }
  function gd(r, t, e, n, i, s, a) {
    const o = Tc.distanceSqToPoint(r);
    if (o < e) {
      const c = new L();
      Tc.closestPointToPoint(r, c), c.applyMatrix4(n);
      const l = i.ray.origin.distanceTo(c);
      if (l < i.near || l > i.far) return;
      s.push({
        distance: l,
        distanceToRay: Math.sqrt(o),
        point: c,
        index: t,
        face: null,
        object: a
      });
    }
  }
  class Q0 extends Ne {
    constructor(t, e, n, i, s, a, o, c, l) {
      super(t, e, n, i, s, a, o, c, l), this.isCanvasTexture = true, this.needsUpdate = true;
    }
  }
  class Ga extends sn {
    constructor(t = 1, e = 1, n = 1, i = 32, s = 1, a = false, o = 0, c = Math.PI * 2) {
      super(), this.type = "CylinderGeometry", this.parameters = {
        radiusTop: t,
        radiusBottom: e,
        height: n,
        radialSegments: i,
        heightSegments: s,
        openEnded: a,
        thetaStart: o,
        thetaLength: c
      };
      const l = this;
      i = Math.floor(i), s = Math.floor(s);
      const h = [], d = [], u = [], p = [];
      let w = 0;
      const b = [], m = n / 2;
      let _ = 0;
      E(), a === false && (t > 0 && v(true), e > 0 && v(false)), this.setIndex(h), this.setAttribute("position", new We(d, 3)), this.setAttribute("normal", new We(u, 3)), this.setAttribute("uv", new We(p, 2));
      function E() {
        const T = new L(), O = new L();
        let R = 0;
        const P = (e - t) / n;
        for (let z = 0; z <= s; z++) {
          const A = [], S = z / s, F = S * (e - t) + t;
          for (let W = 0; W <= i; W++) {
            const V = W / i, Z = V * c + o, tt = Math.sin(Z), Y = Math.cos(Z);
            O.x = F * tt, O.y = -S * n + m, O.z = F * Y, d.push(O.x, O.y, O.z), T.set(tt, P, Y).normalize(), u.push(T.x, T.y, T.z), p.push(V, 1 - S), A.push(w++);
          }
          b.push(A);
        }
        for (let z = 0; z < i; z++) for (let A = 0; A < s; A++) {
          const S = b[A][z], F = b[A + 1][z], W = b[A + 1][z + 1], V = b[A][z + 1];
          h.push(S, F, V), h.push(F, W, V), R += 6;
        }
        l.addGroup(_, R, 0), _ += R;
      }
      function v(T) {
        const O = w, R = new vt(), P = new L();
        let z = 0;
        const A = T === true ? t : e, S = T === true ? 1 : -1;
        for (let W = 1; W <= i; W++) d.push(0, m * S, 0), u.push(0, S, 0), p.push(0.5, 0.5), w++;
        const F = w;
        for (let W = 0; W <= i; W++) {
          const Z = W / i * c + o, tt = Math.cos(Z), Y = Math.sin(Z);
          P.x = A * Y, P.y = m * S, P.z = A * tt, d.push(P.x, P.y, P.z), u.push(0, S, 0), R.x = tt * 0.5 + 0.5, R.y = Y * 0.5 * S + 0.5, p.push(R.x, R.y), w++;
        }
        for (let W = 0; W < i; W++) {
          const V = O + W, Z = F + W;
          T === true ? h.push(Z, Z + 1, V) : h.push(Z + 1, Z, V), z += 3;
        }
        l.addGroup(_, z, T === true ? 1 : 2), _ += z;
      }
    }
    copy(t) {
      return super.copy(t), this.parameters = Object.assign({}, t.parameters), this;
    }
    static fromJSON(t) {
      return new Ga(t.radiusTop, t.radiusBottom, t.height, t.radialSegments, t.heightSegments, t.openEnded, t.thetaStart, t.thetaLength);
    }
  }
  class ss extends sn {
    constructor(t = 1, e = 32, n = 16, i = 0, s = Math.PI * 2, a = 0, o = Math.PI) {
      super(), this.type = "SphereGeometry", this.parameters = {
        radius: t,
        widthSegments: e,
        heightSegments: n,
        phiStart: i,
        phiLength: s,
        thetaStart: a,
        thetaLength: o
      }, e = Math.max(3, Math.floor(e)), n = Math.max(2, Math.floor(n));
      const c = Math.min(a + o, Math.PI);
      let l = 0;
      const h = [], d = new L(), u = new L(), p = [], w = [], b = [], m = [];
      for (let _ = 0; _ <= n; _++) {
        const E = [], v = _ / n;
        let T = 0;
        _ === 0 && a === 0 ? T = 0.5 / e : _ === n && c === Math.PI && (T = -0.5 / e);
        for (let O = 0; O <= e; O++) {
          const R = O / e;
          d.x = -t * Math.cos(i + R * s) * Math.sin(a + v * o), d.y = t * Math.cos(a + v * o), d.z = t * Math.sin(i + R * s) * Math.sin(a + v * o), w.push(d.x, d.y, d.z), u.copy(d).normalize(), b.push(u.x, u.y, u.z), m.push(R + T, 1 - v), E.push(l++);
        }
        h.push(E);
      }
      for (let _ = 0; _ < n; _++) for (let E = 0; E < e; E++) {
        const v = h[_][E + 1], T = h[_][E], O = h[_ + 1][E], R = h[_ + 1][E + 1];
        (_ !== 0 || a > 0) && p.push(v, T, R), (_ !== n - 1 || c < Math.PI) && p.push(T, O, R);
      }
      this.setIndex(p), this.setAttribute("position", new We(w, 3)), this.setAttribute("normal", new We(b, 3)), this.setAttribute("uv", new We(m, 2));
    }
    copy(t) {
      return super.copy(t), this.parameters = Object.assign({}, t.parameters), this;
    }
    static fromJSON(t) {
      return new ss(t.radius, t.widthSegments, t.heightSegments, t.phiStart, t.phiLength, t.thetaStart, t.thetaLength);
    }
  }
  class Un extends Rn {
    constructor(t) {
      super(), this.isMeshStandardMaterial = true, this.defines = {
        STANDARD: ""
      }, this.type = "MeshStandardMaterial", this.color = new Ct(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Ct(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = yu, this.normalScale = new vt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Pn(), this.envMapIntensity = 1, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = false, this.fog = true, this.setValues(t);
    }
    copy(t) {
      return super.copy(t), this.defines = {
        STANDARD: ""
      }, this.color.copy(t.color), this.roughness = t.roughness, this.metalness = t.metalness, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.roughnessMap = t.roughnessMap, this.metalnessMap = t.metalnessMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapRotation.copy(t.envMapRotation), this.envMapIntensity = t.envMapIntensity, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.flatShading = t.flatShading, this.fog = t.fog, this;
    }
  }
  class Bn extends Un {
    constructor(t) {
      super(), this.isMeshPhysicalMaterial = true, this.defines = {
        STANDARD: "",
        PHYSICAL: ""
      }, this.type = "MeshPhysicalMaterial", this.anisotropyRotation = 0, this.anisotropyMap = null, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new vt(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
        get: function() {
          return Ge(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
        },
        set: function(e) {
          this.ior = (1 + 0.4 * e) / (1 - 0.4 * e);
        }
      }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [
        100,
        400
      ], this.iridescenceThicknessMap = null, this.sheenColor = new Ct(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 1 / 0, this.attenuationColor = new Ct(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new Ct(1, 1, 1), this.specularColorMap = null, this._anisotropy = 0, this._clearcoat = 0, this._dispersion = 0, this._iridescence = 0, this._sheen = 0, this._transmission = 0, this.setValues(t);
    }
    get anisotropy() {
      return this._anisotropy;
    }
    set anisotropy(t) {
      this._anisotropy > 0 != t > 0 && this.version++, this._anisotropy = t;
    }
    get clearcoat() {
      return this._clearcoat;
    }
    set clearcoat(t) {
      this._clearcoat > 0 != t > 0 && this.version++, this._clearcoat = t;
    }
    get iridescence() {
      return this._iridescence;
    }
    set iridescence(t) {
      this._iridescence > 0 != t > 0 && this.version++, this._iridescence = t;
    }
    get dispersion() {
      return this._dispersion;
    }
    set dispersion(t) {
      this._dispersion > 0 != t > 0 && this.version++, this._dispersion = t;
    }
    get sheen() {
      return this._sheen;
    }
    set sheen(t) {
      this._sheen > 0 != t > 0 && this.version++, this._sheen = t;
    }
    get transmission() {
      return this._transmission;
    }
    set transmission(t) {
      this._transmission > 0 != t > 0 && this.version++, this._transmission = t;
    }
    copy(t) {
      return super.copy(t), this.defines = {
        STANDARD: "",
        PHYSICAL: ""
      }, this.anisotropy = t.anisotropy, this.anisotropyRotation = t.anisotropyRotation, this.anisotropyMap = t.anisotropyMap, this.clearcoat = t.clearcoat, this.clearcoatMap = t.clearcoatMap, this.clearcoatRoughness = t.clearcoatRoughness, this.clearcoatRoughnessMap = t.clearcoatRoughnessMap, this.clearcoatNormalMap = t.clearcoatNormalMap, this.clearcoatNormalScale.copy(t.clearcoatNormalScale), this.dispersion = t.dispersion, this.ior = t.ior, this.iridescence = t.iridescence, this.iridescenceMap = t.iridescenceMap, this.iridescenceIOR = t.iridescenceIOR, this.iridescenceThicknessRange = [
        ...t.iridescenceThicknessRange
      ], this.iridescenceThicknessMap = t.iridescenceThicknessMap, this.sheen = t.sheen, this.sheenColor.copy(t.sheenColor), this.sheenColorMap = t.sheenColorMap, this.sheenRoughness = t.sheenRoughness, this.sheenRoughnessMap = t.sheenRoughnessMap, this.transmission = t.transmission, this.transmissionMap = t.transmissionMap, this.thickness = t.thickness, this.thicknessMap = t.thicknessMap, this.attenuationDistance = t.attenuationDistance, this.attenuationColor.copy(t.attenuationColor), this.specularIntensity = t.specularIntensity, this.specularIntensityMap = t.specularIntensityMap, this.specularColor.copy(t.specularColor), this.specularColorMap = t.specularColorMap, this;
    }
  }
  function na(r, t, e) {
    return !r || !e && r.constructor === t ? r : typeof t.BYTES_PER_ELEMENT == "number" ? new t(r) : Array.prototype.slice.call(r);
  }
  function tb(r) {
    return ArrayBuffer.isView(r) && !(r instanceof DataView);
  }
  function eb(r) {
    function t(i, s) {
      return r[i] - r[s];
    }
    const e = r.length, n = new Array(e);
    for (let i = 0; i !== e; ++i) n[i] = i;
    return n.sort(t), n;
  }
  function wd(r, t, e) {
    const n = r.length, i = new r.constructor(n);
    for (let s = 0, a = 0; a !== n; ++s) {
      const o = e[s] * t;
      for (let c = 0; c !== t; ++c) i[a++] = r[o + c];
    }
    return i;
  }
  function Yu(r, t, e, n) {
    let i = 1, s = r[0];
    for (; s !== void 0 && s[n] === void 0; ) s = r[i++];
    if (s === void 0) return;
    let a = s[n];
    if (a !== void 0) if (Array.isArray(a)) do
      a = s[n], a !== void 0 && (t.push(s.time), e.push.apply(e, a)), s = r[i++];
    while (s !== void 0);
    else if (a.toArray !== void 0) do
      a = s[n], a !== void 0 && (t.push(s.time), a.toArray(e, e.length)), s = r[i++];
    while (s !== void 0);
    else do
      a = s[n], a !== void 0 && (t.push(s.time), e.push(a)), s = r[i++];
    while (s !== void 0);
  }
  class vs {
    constructor(t, e, n, i) {
      this.parameterPositions = t, this._cachedIndex = 0, this.resultBuffer = i !== void 0 ? i : new e.constructor(n), this.sampleValues = e, this.valueSize = n, this.settings = null, this.DefaultSettings_ = {};
    }
    evaluate(t) {
      const e = this.parameterPositions;
      let n = this._cachedIndex, i = e[n], s = e[n - 1];
      n: {
        t: {
          let a;
          e: {
            i: if (!(t < i)) {
              for (let o = n + 2; ; ) {
                if (i === void 0) {
                  if (t < s) break i;
                  return n = e.length, this._cachedIndex = n, this.copySampleValue_(n - 1);
                }
                if (n === o) break;
                if (s = i, i = e[++n], t < i) break t;
              }
              a = e.length;
              break e;
            }
            if (!(t >= s)) {
              const o = e[1];
              t < o && (n = 2, s = o);
              for (let c = n - 2; ; ) {
                if (s === void 0) return this._cachedIndex = 0, this.copySampleValue_(0);
                if (n === c) break;
                if (i = s, s = e[--n - 1], t >= s) break t;
              }
              a = n, n = 0;
              break e;
            }
            break n;
          }
          for (; n < a; ) {
            const o = n + a >>> 1;
            t < e[o] ? a = o : n = o + 1;
          }
          if (i = e[n], s = e[n - 1], s === void 0) return this._cachedIndex = 0, this.copySampleValue_(0);
          if (i === void 0) return n = e.length, this._cachedIndex = n, this.copySampleValue_(n - 1);
        }
        this._cachedIndex = n, this.intervalChanged_(n, s, i);
      }
      return this.interpolate_(n, s, t, i);
    }
    getSettings_() {
      return this.settings || this.DefaultSettings_;
    }
    copySampleValue_(t) {
      const e = this.resultBuffer, n = this.sampleValues, i = this.valueSize, s = t * i;
      for (let a = 0; a !== i; ++a) e[a] = n[s + a];
      return e;
    }
    interpolate_() {
      throw new Error("call to abstract method");
    }
    intervalChanged_() {
    }
  }
  class nb extends vs {
    constructor(t, e, n, i) {
      super(t, e, n, i), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
        endingStart: lh,
        endingEnd: lh
      };
    }
    intervalChanged_(t, e, n) {
      const i = this.parameterPositions;
      let s = t - 2, a = t + 1, o = i[s], c = i[a];
      if (o === void 0) switch (this.getSettings_().endingStart) {
        case hh:
          s = t, o = 2 * e - n;
          break;
        case dh:
          s = i.length - 2, o = e + i[s] - i[s + 1];
          break;
        default:
          s = t, o = n;
      }
      if (c === void 0) switch (this.getSettings_().endingEnd) {
        case hh:
          a = t, c = 2 * n - e;
          break;
        case dh:
          a = 1, c = n + i[1] - i[0];
          break;
        default:
          a = t - 1, c = e;
      }
      const l = (n - e) * 0.5, h = this.valueSize;
      this._weightPrev = l / (e - o), this._weightNext = l / (c - n), this._offsetPrev = s * h, this._offsetNext = a * h;
    }
    interpolate_(t, e, n, i) {
      const s = this.resultBuffer, a = this.sampleValues, o = this.valueSize, c = t * o, l = c - o, h = this._offsetPrev, d = this._offsetNext, u = this._weightPrev, p = this._weightNext, w = (n - e) / (i - e), b = w * w, m = b * w, _ = -u * m + 2 * u * b - u * w, E = (1 + u) * m + (-1.5 - 2 * u) * b + (-0.5 + u) * w + 1, v = (-1 - p) * m + (1.5 + p) * b + 0.5 * w, T = p * m - p * b;
      for (let O = 0; O !== o; ++O) s[O] = _ * a[h + O] + E * a[l + O] + v * a[c + O] + T * a[d + O];
      return s;
    }
  }
  class ib extends vs {
    constructor(t, e, n, i) {
      super(t, e, n, i);
    }
    interpolate_(t, e, n, i) {
      const s = this.resultBuffer, a = this.sampleValues, o = this.valueSize, c = t * o, l = c - o, h = (n - e) / (i - e), d = 1 - h;
      for (let u = 0; u !== o; ++u) s[u] = a[l + u] * d + a[c + u] * h;
      return s;
    }
  }
  class rb extends vs {
    constructor(t, e, n, i) {
      super(t, e, n, i);
    }
    interpolate_(t) {
      return this.copySampleValue_(t - 1);
    }
  }
  class zn {
    constructor(t, e, n, i) {
      if (t === void 0) throw new Error("THREE.KeyframeTrack: track name is undefined");
      if (e === void 0 || e.length === 0) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t);
      this.name = t, this.times = na(e, this.TimeBufferType), this.values = na(n, this.ValueBufferType), this.setInterpolation(i || this.DefaultInterpolation);
    }
    static toJSON(t) {
      const e = t.constructor;
      let n;
      if (e.toJSON !== this.toJSON) n = e.toJSON(t);
      else {
        n = {
          name: t.name,
          times: na(t.times, Array),
          values: na(t.values, Array)
        };
        const i = t.getInterpolation();
        i !== t.DefaultInterpolation && (n.interpolation = i);
      }
      return n.type = t.ValueTypeName, n;
    }
    InterpolantFactoryMethodDiscrete(t) {
      return new rb(this.times, this.values, this.getValueSize(), t);
    }
    InterpolantFactoryMethodLinear(t) {
      return new ib(this.times, this.values, this.getValueSize(), t);
    }
    InterpolantFactoryMethodSmooth(t) {
      return new nb(this.times, this.values, this.getValueSize(), t);
    }
    setInterpolation(t) {
      let e;
      switch (t) {
        case cs:
          e = this.InterpolantFactoryMethodDiscrete;
          break;
        case ls:
          e = this.InterpolantFactoryMethodLinear;
          break;
        case Eo:
          e = this.InterpolantFactoryMethodSmooth;
          break;
      }
      if (e === void 0) {
        const n = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
        if (this.createInterpolant === void 0) if (t !== this.DefaultInterpolation) this.setInterpolation(this.DefaultInterpolation);
        else throw new Error(n);
        return console.warn("THREE.KeyframeTrack:", n), this;
      }
      return this.createInterpolant = e, this;
    }
    getInterpolation() {
      switch (this.createInterpolant) {
        case this.InterpolantFactoryMethodDiscrete:
          return cs;
        case this.InterpolantFactoryMethodLinear:
          return ls;
        case this.InterpolantFactoryMethodSmooth:
          return Eo;
      }
    }
    getValueSize() {
      return this.values.length / this.times.length;
    }
    shift(t) {
      if (t !== 0) {
        const e = this.times;
        for (let n = 0, i = e.length; n !== i; ++n) e[n] += t;
      }
      return this;
    }
    scale(t) {
      if (t !== 1) {
        const e = this.times;
        for (let n = 0, i = e.length; n !== i; ++n) e[n] *= t;
      }
      return this;
    }
    trim(t, e) {
      const n = this.times, i = n.length;
      let s = 0, a = i - 1;
      for (; s !== i && n[s] < t; ) ++s;
      for (; a !== -1 && n[a] > e; ) --a;
      if (++a, s !== 0 || a !== i) {
        s >= a && (a = Math.max(a, 1), s = a - 1);
        const o = this.getValueSize();
        this.times = n.slice(s, a), this.values = this.values.slice(s * o, a * o);
      }
      return this;
    }
    validate() {
      let t = true;
      const e = this.getValueSize();
      e - Math.floor(e) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), t = false);
      const n = this.times, i = this.values, s = n.length;
      s === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this), t = false);
      let a = null;
      for (let o = 0; o !== s; o++) {
        const c = n[o];
        if (typeof c == "number" && isNaN(c)) {
          console.error("THREE.KeyframeTrack: Time is not a valid number.", this, o, c), t = false;
          break;
        }
        if (a !== null && a > c) {
          console.error("THREE.KeyframeTrack: Out of order keys.", this, o, c, a), t = false;
          break;
        }
        a = c;
      }
      if (i !== void 0 && tb(i)) for (let o = 0, c = i.length; o !== c; ++o) {
        const l = i[o];
        if (isNaN(l)) {
          console.error("THREE.KeyframeTrack: Value is not a valid number.", this, o, l), t = false;
          break;
        }
      }
      return t;
    }
    optimize() {
      const t = this.times.slice(), e = this.values.slice(), n = this.getValueSize(), i = this.getInterpolation() === Eo, s = t.length - 1;
      let a = 1;
      for (let o = 1; o < s; ++o) {
        let c = false;
        const l = t[o], h = t[o + 1];
        if (l !== h && (o !== 1 || l !== t[0])) if (i) c = true;
        else {
          const d = o * n, u = d - n, p = d + n;
          for (let w = 0; w !== n; ++w) {
            const b = e[d + w];
            if (b !== e[u + w] || b !== e[p + w]) {
              c = true;
              break;
            }
          }
        }
        if (c) {
          if (o !== a) {
            t[a] = t[o];
            const d = o * n, u = a * n;
            for (let p = 0; p !== n; ++p) e[u + p] = e[d + p];
          }
          ++a;
        }
      }
      if (s > 0) {
        t[a] = t[s];
        for (let o = s * n, c = a * n, l = 0; l !== n; ++l) e[c + l] = e[o + l];
        ++a;
      }
      return a !== t.length ? (this.times = t.slice(0, a), this.values = e.slice(0, a * n)) : (this.times = t, this.values = e), this;
    }
    clone() {
      const t = this.times.slice(), e = this.values.slice(), n = this.constructor, i = new n(this.name, t, e);
      return i.createInterpolant = this.createInterpolant, i;
    }
  }
  zn.prototype.TimeBufferType = Float32Array;
  zn.prototype.ValueBufferType = Float32Array;
  zn.prototype.DefaultInterpolation = ls;
  class Ur extends zn {
    constructor(t, e, n) {
      super(t, e, n);
    }
  }
  Ur.prototype.ValueTypeName = "bool";
  Ur.prototype.ValueBufferType = Array;
  Ur.prototype.DefaultInterpolation = cs;
  Ur.prototype.InterpolantFactoryMethodLinear = void 0;
  Ur.prototype.InterpolantFactoryMethodSmooth = void 0;
  class Zu extends zn {
  }
  Zu.prototype.ValueTypeName = "color";
  class Rr extends zn {
  }
  Rr.prototype.ValueTypeName = "number";
  class sb extends vs {
    constructor(t, e, n, i) {
      super(t, e, n, i);
    }
    interpolate_(t, e, n, i) {
      const s = this.resultBuffer, a = this.sampleValues, o = this.valueSize, c = (n - e) / (i - e);
      let l = t * o;
      for (let h = l + o; l !== h; l += 4) Ve.slerpFlat(s, 0, a, l - o, a, l, c);
      return s;
    }
  }
  class Cr extends zn {
    InterpolantFactoryMethodLinear(t) {
      return new sb(this.times, this.values, this.getValueSize(), t);
    }
  }
  Cr.prototype.ValueTypeName = "quaternion";
  Cr.prototype.InterpolantFactoryMethodSmooth = void 0;
  class Fr extends zn {
    constructor(t, e, n) {
      super(t, e, n);
    }
  }
  Fr.prototype.ValueTypeName = "string";
  Fr.prototype.ValueBufferType = Array;
  Fr.prototype.DefaultInterpolation = cs;
  Fr.prototype.InterpolantFactoryMethodLinear = void 0;
  Fr.prototype.InterpolantFactoryMethodSmooth = void 0;
  class Pr extends zn {
  }
  Pr.prototype.ValueTypeName = "vector";
  class ab {
    constructor(t = "", e = -1, n = [], i = lf) {
      this.name = t, this.tracks = n, this.duration = e, this.blendMode = i, this.uuid = An(), this.duration < 0 && this.resetDuration();
    }
    static parse(t) {
      const e = [], n = t.tracks, i = 1 / (t.fps || 1);
      for (let a = 0, o = n.length; a !== o; ++a) e.push(cb(n[a]).scale(i));
      const s = new this(t.name, t.duration, e, t.blendMode);
      return s.uuid = t.uuid, s;
    }
    static toJSON(t) {
      const e = [], n = t.tracks, i = {
        name: t.name,
        duration: t.duration,
        tracks: e,
        uuid: t.uuid,
        blendMode: t.blendMode
      };
      for (let s = 0, a = n.length; s !== a; ++s) e.push(zn.toJSON(n[s]));
      return i;
    }
    static CreateFromMorphTargetSequence(t, e, n, i) {
      const s = e.length, a = [];
      for (let o = 0; o < s; o++) {
        let c = [], l = [];
        c.push((o + s - 1) % s, o, (o + 1) % s), l.push(0, 1, 0);
        const h = eb(c);
        c = wd(c, 1, h), l = wd(l, 1, h), !i && c[0] === 0 && (c.push(s), l.push(l[0])), a.push(new Rr(".morphTargetInfluences[" + e[o].name + "]", c, l).scale(1 / n));
      }
      return new this(t, -1, a);
    }
    static findByName(t, e) {
      let n = t;
      if (!Array.isArray(t)) {
        const i = t;
        n = i.geometry && i.geometry.animations || i.animations;
      }
      for (let i = 0; i < n.length; i++) if (n[i].name === e) return n[i];
      return null;
    }
    static CreateClipsFromMorphTargetSequences(t, e, n) {
      const i = {}, s = /^([\w-]*?)([\d]+)$/;
      for (let o = 0, c = t.length; o < c; o++) {
        const l = t[o], h = l.name.match(s);
        if (h && h.length > 1) {
          const d = h[1];
          let u = i[d];
          u || (i[d] = u = []), u.push(l);
        }
      }
      const a = [];
      for (const o in i) a.push(this.CreateFromMorphTargetSequence(o, i[o], e, n));
      return a;
    }
    static parseAnimation(t, e) {
      if (!t) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
      const n = function(d, u, p, w, b) {
        if (p.length !== 0) {
          const m = [], _ = [];
          Yu(p, m, _, w), m.length !== 0 && b.push(new d(u, m, _));
        }
      }, i = [], s = t.name || "default", a = t.fps || 30, o = t.blendMode;
      let c = t.length || -1;
      const l = t.hierarchy || [];
      for (let d = 0; d < l.length; d++) {
        const u = l[d].keys;
        if (!(!u || u.length === 0)) if (u[0].morphTargets) {
          const p = {};
          let w;
          for (w = 0; w < u.length; w++) if (u[w].morphTargets) for (let b = 0; b < u[w].morphTargets.length; b++) p[u[w].morphTargets[b]] = -1;
          for (const b in p) {
            const m = [], _ = [];
            for (let E = 0; E !== u[w].morphTargets.length; ++E) {
              const v = u[w];
              m.push(v.time), _.push(v.morphTarget === b ? 1 : 0);
            }
            i.push(new Rr(".morphTargetInfluence[" + b + "]", m, _));
          }
          c = p.length * a;
        } else {
          const p = ".bones[" + e[d].name + "]";
          n(Pr, p + ".position", u, "pos", i), n(Cr, p + ".quaternion", u, "rot", i), n(Pr, p + ".scale", u, "scl", i);
        }
      }
      return i.length === 0 ? null : new this(s, c, i, o);
    }
    resetDuration() {
      const t = this.tracks;
      let e = 0;
      for (let n = 0, i = t.length; n !== i; ++n) {
        const s = this.tracks[n];
        e = Math.max(e, s.times[s.times.length - 1]);
      }
      return this.duration = e, this;
    }
    trim() {
      for (let t = 0; t < this.tracks.length; t++) this.tracks[t].trim(0, this.duration);
      return this;
    }
    validate() {
      let t = true;
      for (let e = 0; e < this.tracks.length; e++) t = t && this.tracks[e].validate();
      return t;
    }
    optimize() {
      for (let t = 0; t < this.tracks.length; t++) this.tracks[t].optimize();
      return this;
    }
    clone() {
      const t = [];
      for (let e = 0; e < this.tracks.length; e++) t.push(this.tracks[e].clone());
      return new this.constructor(this.name, this.duration, t, this.blendMode);
    }
    toJSON() {
      return this.constructor.toJSON(this);
    }
  }
  function ob(r) {
    switch (r.toLowerCase()) {
      case "scalar":
      case "double":
      case "float":
      case "number":
      case "integer":
        return Rr;
      case "vector":
      case "vector2":
      case "vector3":
      case "vector4":
        return Pr;
      case "color":
        return Zu;
      case "quaternion":
        return Cr;
      case "bool":
      case "boolean":
        return Ur;
      case "string":
        return Fr;
    }
    throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + r);
  }
  function cb(r) {
    if (r.type === void 0) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
    const t = ob(r.type);
    if (r.times === void 0) {
      const e = [], n = [];
      Yu(r.keys, e, n, "value"), r.times = e, r.values = n;
    }
    return t.parse !== void 0 ? t.parse(r) : new t(r.name, r.times, r.values, r.interpolation);
  }
  const bi = {
    enabled: false,
    files: {},
    add: function(r, t) {
      this.enabled !== false && (this.files[r] = t);
    },
    get: function(r) {
      if (this.enabled !== false) return this.files[r];
    },
    remove: function(r) {
      delete this.files[r];
    },
    clear: function() {
      this.files = {};
    }
  };
  class lb {
    constructor(t, e, n) {
      const i = this;
      let s = false, a = 0, o = 0, c;
      const l = [];
      this.onStart = void 0, this.onLoad = t, this.onProgress = e, this.onError = n, this.itemStart = function(h) {
        o++, s === false && i.onStart !== void 0 && i.onStart(h, a, o), s = true;
      }, this.itemEnd = function(h) {
        a++, i.onProgress !== void 0 && i.onProgress(h, a, o), a === o && (s = false, i.onLoad !== void 0 && i.onLoad());
      }, this.itemError = function(h) {
        i.onError !== void 0 && i.onError(h);
      }, this.resolveURL = function(h) {
        return c ? c(h) : h;
      }, this.setURLModifier = function(h) {
        return c = h, this;
      }, this.addHandler = function(h, d) {
        return l.push(h, d), this;
      }, this.removeHandler = function(h) {
        const d = l.indexOf(h);
        return d !== -1 && l.splice(d, 2), this;
      }, this.getHandler = function(h) {
        for (let d = 0, u = l.length; d < u; d += 2) {
          const p = l[d], w = l[d + 1];
          if (p.global && (p.lastIndex = 0), p.test(h)) return w;
        }
        return null;
      };
    }
  }
  const hb = new lb();
  class Or {
    constructor(t) {
      this.manager = t !== void 0 ? t : hb, this.crossOrigin = "anonymous", this.withCredentials = false, this.path = "", this.resourcePath = "", this.requestHeader = {};
    }
    load() {
    }
    loadAsync(t, e) {
      const n = this;
      return new Promise(function(i, s) {
        n.load(t, i, e, s);
      });
    }
    parse() {
    }
    setCrossOrigin(t) {
      return this.crossOrigin = t, this;
    }
    setWithCredentials(t) {
      return this.withCredentials = t, this;
    }
    setPath(t) {
      return this.path = t, this;
    }
    setResourcePath(t) {
      return this.resourcePath = t, this;
    }
    setRequestHeader(t) {
      return this.requestHeader = t, this;
    }
  }
  Or.DEFAULT_MATERIAL_NAME = "__DEFAULT";
  const Xn = {};
  class db extends Error {
    constructor(t, e) {
      super(t), this.response = e;
    }
  }
  class $u extends Or {
    constructor(t) {
      super(t);
    }
    load(t, e, n, i) {
      t === void 0 && (t = ""), this.path !== void 0 && (t = this.path + t), t = this.manager.resolveURL(t);
      const s = bi.get(t);
      if (s !== void 0) return this.manager.itemStart(t), setTimeout(() => {
        e && e(s), this.manager.itemEnd(t);
      }, 0), s;
      if (Xn[t] !== void 0) {
        Xn[t].push({
          onLoad: e,
          onProgress: n,
          onError: i
        });
        return;
      }
      Xn[t] = [], Xn[t].push({
        onLoad: e,
        onProgress: n,
        onError: i
      });
      const a = new Request(t, {
        headers: new Headers(this.requestHeader),
        credentials: this.withCredentials ? "include" : "same-origin"
      }), o = this.mimeType, c = this.responseType;
      fetch(a).then((l) => {
        if (l.status === 200 || l.status === 0) {
          if (l.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."), typeof ReadableStream > "u" || l.body === void 0 || l.body.getReader === void 0) return l;
          const h = Xn[t], d = l.body.getReader(), u = l.headers.get("X-File-Size") || l.headers.get("Content-Length"), p = u ? parseInt(u) : 0, w = p !== 0;
          let b = 0;
          const m = new ReadableStream({
            start(_) {
              E();
              function E() {
                d.read().then(({ done: v, value: T }) => {
                  if (v) _.close();
                  else {
                    b += T.byteLength;
                    const O = new ProgressEvent("progress", {
                      lengthComputable: w,
                      loaded: b,
                      total: p
                    });
                    for (let R = 0, P = h.length; R < P; R++) {
                      const z = h[R];
                      z.onProgress && z.onProgress(O);
                    }
                    _.enqueue(T), E();
                  }
                }, (v) => {
                  _.error(v);
                });
              }
            }
          });
          return new Response(m);
        } else throw new db(`fetch for "${l.url}" responded with ${l.status}: ${l.statusText}`, l);
      }).then((l) => {
        switch (c) {
          case "arraybuffer":
            return l.arrayBuffer();
          case "blob":
            return l.blob();
          case "document":
            return l.text().then((h) => new DOMParser().parseFromString(h, o));
          case "json":
            return l.json();
          default:
            if (o === void 0) return l.text();
            {
              const d = /charset="?([^;"\s]*)"?/i.exec(o), u = d && d[1] ? d[1].toLowerCase() : void 0, p = new TextDecoder(u);
              return l.arrayBuffer().then((w) => p.decode(w));
            }
        }
      }).then((l) => {
        bi.add(t, l);
        const h = Xn[t];
        delete Xn[t];
        for (let d = 0, u = h.length; d < u; d++) {
          const p = h[d];
          p.onLoad && p.onLoad(l);
        }
      }).catch((l) => {
        const h = Xn[t];
        if (h === void 0) throw this.manager.itemError(t), l;
        delete Xn[t];
        for (let d = 0, u = h.length; d < u; d++) {
          const p = h[d];
          p.onError && p.onError(l);
        }
        this.manager.itemError(t);
      }).finally(() => {
        this.manager.itemEnd(t);
      }), this.manager.itemStart(t);
    }
    setResponseType(t) {
      return this.responseType = t, this;
    }
    setMimeType(t) {
      return this.mimeType = t, this;
    }
  }
  class ub extends Or {
    constructor(t) {
      super(t);
    }
    load(t, e, n, i) {
      this.path !== void 0 && (t = this.path + t), t = this.manager.resolveURL(t);
      const s = this, a = bi.get(t);
      if (a !== void 0) return s.manager.itemStart(t), setTimeout(function() {
        e && e(a), s.manager.itemEnd(t);
      }, 0), a;
      const o = hs("img");
      function c() {
        h(), bi.add(t, this), e && e(this), s.manager.itemEnd(t);
      }
      function l(d) {
        h(), i && i(d), s.manager.itemError(t), s.manager.itemEnd(t);
      }
      function h() {
        o.removeEventListener("load", c, false), o.removeEventListener("error", l, false);
      }
      return o.addEventListener("load", c, false), o.addEventListener("error", l, false), t.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (o.crossOrigin = this.crossOrigin), s.manager.itemStart(t), o.src = t, o;
    }
  }
  class Ju extends Or {
    constructor(t) {
      super(t);
    }
    load(t, e, n, i) {
      const s = new Ne(), a = new ub(this.manager);
      return a.setCrossOrigin(this.crossOrigin), a.setPath(this.path), a.load(t, function(o) {
        s.image = o, s.needsUpdate = true, e !== void 0 && e(s);
      }, n, i), s;
    }
  }
  class xs extends _e {
    constructor(t, e = 1) {
      super(), this.isLight = true, this.type = "Light", this.color = new Ct(t), this.intensity = e;
    }
    dispose() {
    }
    copy(t, e) {
      return super.copy(t, e), this.color.copy(t.color), this.intensity = t.intensity, this;
    }
    toJSON(t) {
      const e = super.toJSON(t);
      return e.object.color = this.color.getHex(), e.object.intensity = this.intensity, this.groundColor !== void 0 && (e.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (e.object.distance = this.distance), this.angle !== void 0 && (e.object.angle = this.angle), this.decay !== void 0 && (e.object.decay = this.decay), this.penumbra !== void 0 && (e.object.penumbra = this.penumbra), this.shadow !== void 0 && (e.object.shadow = this.shadow.toJSON()), e;
    }
  }
  class pb extends xs {
    constructor(t, e, n) {
      super(t, n), this.isHemisphereLight = true, this.type = "HemisphereLight", this.position.copy(_e.DEFAULT_UP), this.updateMatrix(), this.groundColor = new Ct(e);
    }
    copy(t, e) {
      return super.copy(t, e), this.groundColor.copy(t.groundColor), this;
    }
  }
  const ec = new Ht(), bd = new L(), yd = new L();
  class kc {
    constructor(t) {
      this.camera = t, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new vt(512, 512), this.map = null, this.mapPass = null, this.matrix = new Ht(), this.autoUpdate = true, this.needsUpdate = false, this._frustum = new Uc(), this._frameExtents = new vt(1, 1), this._viewportCount = 1, this._viewports = [
        new de(0, 0, 1, 1)
      ];
    }
    getViewportCount() {
      return this._viewportCount;
    }
    getFrustum() {
      return this._frustum;
    }
    updateMatrices(t) {
      const e = this.camera, n = this.matrix;
      bd.setFromMatrixPosition(t.matrixWorld), e.position.copy(bd), yd.setFromMatrixPosition(t.target.matrixWorld), e.lookAt(yd), e.updateMatrixWorld(), ec.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), this._frustum.setFromProjectionMatrix(ec), n.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1), n.multiply(ec);
    }
    getViewport(t) {
      return this._viewports[t];
    }
    getFrameExtents() {
      return this._frameExtents;
    }
    dispose() {
      this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
    }
    copy(t) {
      return this.camera = t.camera.clone(), this.bias = t.bias, this.radius = t.radius, this.mapSize.copy(t.mapSize), this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    toJSON() {
      const t = {};
      return this.bias !== 0 && (t.bias = this.bias), this.normalBias !== 0 && (t.normalBias = this.normalBias), this.radius !== 1 && (t.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (t.mapSize = this.mapSize.toArray()), t.camera = this.camera.toJSON(false).object, delete t.camera.matrix, t;
    }
  }
  class fb extends kc {
    constructor() {
      super(new tn(50, 1, 0.5, 500)), this.isSpotLightShadow = true, this.focus = 1;
    }
    updateMatrices(t) {
      const e = this.camera, n = Tr * 2 * t.angle * this.focus, i = this.mapSize.width / this.mapSize.height, s = t.distance || e.far;
      (n !== e.fov || i !== e.aspect || s !== e.far) && (e.fov = n, e.aspect = i, e.far = s, e.updateProjectionMatrix()), super.updateMatrices(t);
    }
    copy(t) {
      return super.copy(t), this.focus = t.focus, this;
    }
  }
  class Qu extends xs {
    constructor(t, e, n = 0, i = Math.PI / 3, s = 0, a = 2) {
      super(t, e), this.isSpotLight = true, this.type = "SpotLight", this.position.copy(_e.DEFAULT_UP), this.updateMatrix(), this.target = new _e(), this.distance = n, this.angle = i, this.penumbra = s, this.decay = a, this.map = null, this.shadow = new fb();
    }
    get power() {
      return this.intensity * Math.PI;
    }
    set power(t) {
      this.intensity = t / Math.PI;
    }
    dispose() {
      this.shadow.dispose();
    }
    copy(t, e) {
      return super.copy(t, e), this.distance = t.distance, this.angle = t.angle, this.penumbra = t.penumbra, this.decay = t.decay, this.target = t.target.clone(), this.shadow = t.shadow.clone(), this;
    }
  }
  const vd = new Ht(), $r = new L(), nc = new L();
  class _b extends kc {
    constructor() {
      super(new tn(90, 1, 0.5, 500)), this.isPointLightShadow = true, this._frameExtents = new vt(4, 2), this._viewportCount = 6, this._viewports = [
        new de(2, 1, 1, 1),
        new de(0, 1, 1, 1),
        new de(3, 1, 1, 1),
        new de(1, 1, 1, 1),
        new de(3, 0, 1, 1),
        new de(1, 0, 1, 1)
      ], this._cubeDirections = [
        new L(1, 0, 0),
        new L(-1, 0, 0),
        new L(0, 0, 1),
        new L(0, 0, -1),
        new L(0, 1, 0),
        new L(0, -1, 0)
      ], this._cubeUps = [
        new L(0, 1, 0),
        new L(0, 1, 0),
        new L(0, 1, 0),
        new L(0, 1, 0),
        new L(0, 0, 1),
        new L(0, 0, -1)
      ];
    }
    updateMatrices(t, e = 0) {
      const n = this.camera, i = this.matrix, s = t.distance || n.far;
      s !== n.far && (n.far = s, n.updateProjectionMatrix()), $r.setFromMatrixPosition(t.matrixWorld), n.position.copy($r), nc.copy(n.position), nc.add(this._cubeDirections[e]), n.up.copy(this._cubeUps[e]), n.lookAt(nc), n.updateMatrixWorld(), i.makeTranslation(-$r.x, -$r.y, -$r.z), vd.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(vd);
    }
  }
  class mb extends xs {
    constructor(t, e, n = 0, i = 2) {
      super(t, e), this.isPointLight = true, this.type = "PointLight", this.distance = n, this.decay = i, this.shadow = new _b();
    }
    get power() {
      return this.intensity * 4 * Math.PI;
    }
    set power(t) {
      this.intensity = t / (4 * Math.PI);
    }
    dispose() {
      this.shadow.dispose();
    }
    copy(t, e) {
      return super.copy(t, e), this.distance = t.distance, this.decay = t.decay, this.shadow = t.shadow.clone(), this;
    }
  }
  class gb extends kc {
    constructor() {
      super(new Fc(-5, 5, 5, -5, 0.5, 500)), this.isDirectionalLightShadow = true;
    }
  }
  class Ac extends xs {
    constructor(t, e) {
      super(t, e), this.isDirectionalLight = true, this.type = "DirectionalLight", this.position.copy(_e.DEFAULT_UP), this.updateMatrix(), this.target = new _e(), this.shadow = new gb();
    }
    dispose() {
      this.shadow.dispose();
    }
    copy(t) {
      return super.copy(t), this.target = t.target.clone(), this.shadow = t.shadow.clone(), this;
    }
  }
  class wb extends xs {
    constructor(t, e) {
      super(t, e), this.isAmbientLight = true, this.type = "AmbientLight";
    }
  }
  class as {
    static decodeText(t) {
      if (console.warn("THREE.LoaderUtils: decodeText() has been deprecated with r165 and will be removed with r175. Use TextDecoder instead."), typeof TextDecoder < "u") return new TextDecoder().decode(t);
      let e = "";
      for (let n = 0, i = t.length; n < i; n++) e += String.fromCharCode(t[n]);
      try {
        return decodeURIComponent(escape(e));
      } catch {
        return e;
      }
    }
    static extractUrlBase(t) {
      const e = t.lastIndexOf("/");
      return e === -1 ? "./" : t.slice(0, e + 1);
    }
    static resolveURL(t, e) {
      return typeof t != "string" || t === "" ? "" : (/^https?:\/\//i.test(e) && /^\//.test(t) && (e = e.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(t) || /^data:.*,.*$/i.test(t) || /^blob:.*$/i.test(t) ? t : e + t);
    }
  }
  class bb extends Or {
    constructor(t) {
      super(t), this.isImageBitmapLoader = true, typeof createImageBitmap > "u" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), typeof fetch > "u" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = {
        premultiplyAlpha: "none"
      };
    }
    setOptions(t) {
      return this.options = t, this;
    }
    load(t, e, n, i) {
      t === void 0 && (t = ""), this.path !== void 0 && (t = this.path + t), t = this.manager.resolveURL(t);
      const s = this, a = bi.get(t);
      if (a !== void 0) {
        if (s.manager.itemStart(t), a.then) {
          a.then((l) => {
            e && e(l), s.manager.itemEnd(t);
          }).catch((l) => {
            i && i(l);
          });
          return;
        }
        return setTimeout(function() {
          e && e(a), s.manager.itemEnd(t);
        }, 0), a;
      }
      const o = {};
      o.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include", o.headers = this.requestHeader;
      const c = fetch(t, o).then(function(l) {
        return l.blob();
      }).then(function(l) {
        return createImageBitmap(l, Object.assign(s.options, {
          colorSpaceConversion: "none"
        }));
      }).then(function(l) {
        return bi.add(t, l), e && e(l), s.manager.itemEnd(t), l;
      }).catch(function(l) {
        i && i(l), bi.remove(t), s.manager.itemError(t), s.manager.itemEnd(t);
      });
      bi.add(t, c), s.manager.itemStart(t);
    }
  }
  const Hc = "\\[\\]\\.:\\/", yb = new RegExp("[" + Hc + "]", "g"), Gc = "[^" + Hc + "]", vb = "[^" + Hc.replace("\\.", "") + "]", xb = /((?:WC+[\/:])*)/.source.replace("WC", Gc), Sb = /(WCOD+)?/.source.replace("WCOD", vb), Mb = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", Gc), Eb = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", Gc), Tb = new RegExp("^" + xb + Sb + Mb + Eb + "$"), Ab = [
    "material",
    "materials",
    "bones",
    "map"
  ];
  class Rb {
    constructor(t, e, n) {
      const i = n || oe.parseTrackName(e);
      this._targetGroup = t, this._bindings = t.subscribe_(e, i);
    }
    getValue(t, e) {
      this.bind();
      const n = this._targetGroup.nCachedObjects_, i = this._bindings[n];
      i !== void 0 && i.getValue(t, e);
    }
    setValue(t, e) {
      const n = this._bindings;
      for (let i = this._targetGroup.nCachedObjects_, s = n.length; i !== s; ++i) n[i].setValue(t, e);
    }
    bind() {
      const t = this._bindings;
      for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e) t[e].bind();
    }
    unbind() {
      const t = this._bindings;
      for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e) t[e].unbind();
    }
  }
  class oe {
    constructor(t, e, n) {
      this.path = e, this.parsedPath = n || oe.parseTrackName(e), this.node = oe.findNode(t, this.parsedPath.nodeName), this.rootNode = t, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
    }
    static create(t, e, n) {
      return t && t.isAnimationObjectGroup ? new oe.Composite(t, e, n) : new oe(t, e, n);
    }
    static sanitizeNodeName(t) {
      return t.replace(/\s/g, "_").replace(yb, "");
    }
    static parseTrackName(t) {
      const e = Tb.exec(t);
      if (e === null) throw new Error("PropertyBinding: Cannot parse trackName: " + t);
      const n = {
        nodeName: e[2],
        objectName: e[3],
        objectIndex: e[4],
        propertyName: e[5],
        propertyIndex: e[6]
      }, i = n.nodeName && n.nodeName.lastIndexOf(".");
      if (i !== void 0 && i !== -1) {
        const s = n.nodeName.substring(i + 1);
        Ab.indexOf(s) !== -1 && (n.nodeName = n.nodeName.substring(0, i), n.objectName = s);
      }
      if (n.propertyName === null || n.propertyName.length === 0) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t);
      return n;
    }
    static findNode(t, e) {
      if (e === void 0 || e === "" || e === "." || e === -1 || e === t.name || e === t.uuid) return t;
      if (t.skeleton) {
        const n = t.skeleton.getBoneByName(e);
        if (n !== void 0) return n;
      }
      if (t.children) {
        const n = function(s) {
          for (let a = 0; a < s.length; a++) {
            const o = s[a];
            if (o.name === e || o.uuid === e) return o;
            const c = n(o.children);
            if (c) return c;
          }
          return null;
        }, i = n(t.children);
        if (i) return i;
      }
      return null;
    }
    _getValue_unavailable() {
    }
    _setValue_unavailable() {
    }
    _getValue_direct(t, e) {
      t[e] = this.targetObject[this.propertyName];
    }
    _getValue_array(t, e) {
      const n = this.resolvedProperty;
      for (let i = 0, s = n.length; i !== s; ++i) t[e++] = n[i];
    }
    _getValue_arrayElement(t, e) {
      t[e] = this.resolvedProperty[this.propertyIndex];
    }
    _getValue_toArray(t, e) {
      this.resolvedProperty.toArray(t, e);
    }
    _setValue_direct(t, e) {
      this.targetObject[this.propertyName] = t[e];
    }
    _setValue_direct_setNeedsUpdate(t, e) {
      this.targetObject[this.propertyName] = t[e], this.targetObject.needsUpdate = true;
    }
    _setValue_direct_setMatrixWorldNeedsUpdate(t, e) {
      this.targetObject[this.propertyName] = t[e], this.targetObject.matrixWorldNeedsUpdate = true;
    }
    _setValue_array(t, e) {
      const n = this.resolvedProperty;
      for (let i = 0, s = n.length; i !== s; ++i) n[i] = t[e++];
    }
    _setValue_array_setNeedsUpdate(t, e) {
      const n = this.resolvedProperty;
      for (let i = 0, s = n.length; i !== s; ++i) n[i] = t[e++];
      this.targetObject.needsUpdate = true;
    }
    _setValue_array_setMatrixWorldNeedsUpdate(t, e) {
      const n = this.resolvedProperty;
      for (let i = 0, s = n.length; i !== s; ++i) n[i] = t[e++];
      this.targetObject.matrixWorldNeedsUpdate = true;
    }
    _setValue_arrayElement(t, e) {
      this.resolvedProperty[this.propertyIndex] = t[e];
    }
    _setValue_arrayElement_setNeedsUpdate(t, e) {
      this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.needsUpdate = true;
    }
    _setValue_arrayElement_setMatrixWorldNeedsUpdate(t, e) {
      this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.matrixWorldNeedsUpdate = true;
    }
    _setValue_fromArray(t, e) {
      this.resolvedProperty.fromArray(t, e);
    }
    _setValue_fromArray_setNeedsUpdate(t, e) {
      this.resolvedProperty.fromArray(t, e), this.targetObject.needsUpdate = true;
    }
    _setValue_fromArray_setMatrixWorldNeedsUpdate(t, e) {
      this.resolvedProperty.fromArray(t, e), this.targetObject.matrixWorldNeedsUpdate = true;
    }
    _getValue_unbound(t, e) {
      this.bind(), this.getValue(t, e);
    }
    _setValue_unbound(t, e) {
      this.bind(), this.setValue(t, e);
    }
    bind() {
      let t = this.node;
      const e = this.parsedPath, n = e.objectName, i = e.propertyName;
      let s = e.propertyIndex;
      if (t || (t = oe.findNode(this.rootNode, e.nodeName), this.node = t), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !t) {
        console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + ".");
        return;
      }
      if (n) {
        let l = e.objectIndex;
        switch (n) {
          case "materials":
            if (!t.material) {
              console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
              return;
            }
            if (!t.material.materials) {
              console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
              return;
            }
            t = t.material.materials;
            break;
          case "bones":
            if (!t.skeleton) {
              console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
              return;
            }
            t = t.skeleton.bones;
            for (let h = 0; h < t.length; h++) if (t[h].name === l) {
              l = h;
              break;
            }
            break;
          case "map":
            if ("map" in t) {
              t = t.map;
              break;
            }
            if (!t.material) {
              console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
              return;
            }
            if (!t.material.map) {
              console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
              return;
            }
            t = t.material.map;
            break;
          default:
            if (t[n] === void 0) {
              console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
              return;
            }
            t = t[n];
        }
        if (l !== void 0) {
          if (t[l] === void 0) {
            console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t);
            return;
          }
          t = t[l];
        }
      }
      const a = t[i];
      if (a === void 0) {
        const l = e.nodeName;
        console.error("THREE.PropertyBinding: Trying to update property for track: " + l + "." + i + " but it wasn't found.", t);
        return;
      }
      let o = this.Versioning.None;
      this.targetObject = t, t.needsUpdate !== void 0 ? o = this.Versioning.NeedsUpdate : t.matrixWorldNeedsUpdate !== void 0 && (o = this.Versioning.MatrixWorldNeedsUpdate);
      let c = this.BindingType.Direct;
      if (s !== void 0) {
        if (i === "morphTargetInfluences") {
          if (!t.geometry) {
            console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
            return;
          }
          if (!t.geometry.morphAttributes) {
            console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
            return;
          }
          t.morphTargetDictionary[s] !== void 0 && (s = t.morphTargetDictionary[s]);
        }
        c = this.BindingType.ArrayElement, this.resolvedProperty = a, this.propertyIndex = s;
      } else a.fromArray !== void 0 && a.toArray !== void 0 ? (c = this.BindingType.HasFromToArray, this.resolvedProperty = a) : Array.isArray(a) ? (c = this.BindingType.EntireArray, this.resolvedProperty = a) : this.propertyName = i;
      this.getValue = this.GetterByBindingType[c], this.setValue = this.SetterByBindingTypeAndVersioning[c][o];
    }
    unbind() {
      this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
    }
  }
  oe.Composite = Rb;
  oe.prototype.BindingType = {
    Direct: 0,
    EntireArray: 1,
    ArrayElement: 2,
    HasFromToArray: 3
  };
  oe.prototype.Versioning = {
    None: 0,
    NeedsUpdate: 1,
    MatrixWorldNeedsUpdate: 2
  };
  oe.prototype.GetterByBindingType = [
    oe.prototype._getValue_direct,
    oe.prototype._getValue_array,
    oe.prototype._getValue_arrayElement,
    oe.prototype._getValue_toArray
  ];
  oe.prototype.SetterByBindingTypeAndVersioning = [
    [
      oe.prototype._setValue_direct,
      oe.prototype._setValue_direct_setNeedsUpdate,
      oe.prototype._setValue_direct_setMatrixWorldNeedsUpdate
    ],
    [
      oe.prototype._setValue_array,
      oe.prototype._setValue_array_setNeedsUpdate,
      oe.prototype._setValue_array_setMatrixWorldNeedsUpdate
    ],
    [
      oe.prototype._setValue_arrayElement,
      oe.prototype._setValue_arrayElement_setNeedsUpdate,
      oe.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate
    ],
    [
      oe.prototype._setValue_fromArray,
      oe.prototype._setValue_fromArray_setNeedsUpdate,
      oe.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate
    ]
  ];
  class xd {
    constructor(t = 1, e = 0, n = 0) {
      return this.radius = t, this.phi = e, this.theta = n, this;
    }
    set(t, e, n) {
      return this.radius = t, this.phi = e, this.theta = n, this;
    }
    copy(t) {
      return this.radius = t.radius, this.phi = t.phi, this.theta = t.theta, this;
    }
    makeSafe() {
      return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this;
    }
    setFromVector3(t) {
      return this.setFromCartesianCoords(t.x, t.y, t.z);
    }
    setFromCartesianCoords(t, e, n) {
      return this.radius = Math.sqrt(t * t + e * e + n * n), this.radius === 0 ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(t, n), this.phi = Math.acos(Ge(e / this.radius, -1, 1))), this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  class Sd extends Xu {
    constructor(t = 1) {
      const e = [
        0,
        0,
        0,
        t,
        0,
        0,
        0,
        0,
        0,
        0,
        t,
        0,
        0,
        0,
        0,
        0,
        0,
        t
      ], n = [
        1,
        0,
        0,
        1,
        0.6,
        0,
        0,
        1,
        0,
        0.6,
        1,
        0,
        0,
        0,
        1,
        0,
        0.6,
        1
      ], i = new sn();
      i.setAttribute("position", new We(e, 3)), i.setAttribute("color", new We(n, 3));
      const s = new Ha({
        vertexColors: true,
        toneMapped: false
      });
      super(i, s), this.type = "AxesHelper";
    }
    setColors(t, e, n) {
      const i = new Ct(), s = this.geometry.attributes.color.array;
      return i.set(t), i.toArray(s, 0), i.toArray(s, 3), i.set(e), i.toArray(s, 6), i.toArray(s, 9), i.set(n), i.toArray(s, 12), i.toArray(s, 15), this.geometry.attributes.color.needsUpdate = true, this;
    }
    dispose() {
      this.geometry.dispose(), this.material.dispose();
    }
  }
  typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
    detail: {
      revision: Ic
    }
  }));
  typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = Ic);
  const Cb = "/assets/rapier_wasm3d_bg-bb0TTxsO.wasm", Pb = async (r = {}, t) => {
    let e;
    if (t.startsWith("data:")) {
      const n = t.replace(/^data:.*?base64,/, "");
      let i;
      if (typeof Buffer == "function" && typeof Buffer.from == "function") i = Buffer.from(n, "base64");
      else if (typeof atob == "function") {
        const s = atob(n);
        i = new Uint8Array(s.length);
        for (let a = 0; a < s.length; a++) i[a] = s.charCodeAt(a);
      } else throw new Error("Cannot decode base64-encoded data URL");
      e = await WebAssembly.instantiate(i, r);
    } else {
      const n = await fetch(t), i = n.headers.get("Content-Type") || "";
      if ("instantiateStreaming" in WebAssembly && i.startsWith("application/wasm")) e = await WebAssembly.instantiateStreaming(n, r);
      else {
        const s = await n.arrayBuffer();
        e = await WebAssembly.instantiate(s, r);
      }
    }
    return e.instance.exports;
  };
  let f;
  function Ib(r) {
    f = r;
  }
  const te = new Array(128).fill(void 0);
  te.push(void 0, null, true, false);
  function Jt(r) {
    return te[r];
  }
  let os = te.length;
  function he(r) {
    os === te.length && te.push(te.length + 1);
    const t = os;
    return os = te[t], te[t] = r, t;
  }
  function Va(r, t) {
    try {
      return r.apply(this, t);
    } catch (e) {
      f.__wbindgen_export_0(he(e));
    }
  }
  const Lb = typeof TextDecoder > "u" ? (0, module.require)("util").TextDecoder : TextDecoder;
  let tp = new Lb("utf-8", {
    ignoreBOM: true,
    fatal: true
  });
  tp.decode();
  let ia = null;
  function Db() {
    return (ia === null || ia.byteLength === 0) && (ia = new Uint8Array(f.memory.buffer)), ia;
  }
  function Vc(r, t) {
    return r = r >>> 0, tp.decode(Db().subarray(r, r + t));
  }
  function Et(r) {
    return r == null;
  }
  let fr = null;
  function Le() {
    return (fr === null || fr.buffer.detached === true || fr.buffer.detached === void 0 && fr.buffer !== f.memory.buffer) && (fr = new DataView(f.memory.buffer)), fr;
  }
  function Nb(r) {
    r < 132 || (te[r] = os, os = r);
  }
  function us(r) {
    const t = Jt(r);
    return Nb(r), t;
  }
  function Ub() {
    let r, t;
    try {
      const i = f.__wbindgen_add_to_stack_pointer(-16);
      f.version(i);
      var e = Le().getInt32(i + 0, true), n = Le().getInt32(i + 4, true);
      return r = e, t = n, Vc(e, n);
    } finally {
      f.__wbindgen_add_to_stack_pointer(16), f.__wbindgen_export_1(r, t, 1);
    }
  }
  function Fb(r) {
    f.reserve_memory(r);
  }
  function C(r, t) {
    if (!(r instanceof t)) throw new Error(`expected instance of ${t.name}`);
  }
  let le = 128;
  function ge(r) {
    if (le == 1) throw new Error("out of js stack");
    return te[--le] = r, le;
  }
  let ra = null;
  function Ob() {
    return (ra === null || ra.byteLength === 0) && (ra = new Int32Array(f.memory.buffer)), ra;
  }
  function Bb(r, t) {
    return r = r >>> 0, Ob().subarray(r / 4, r / 4 + t);
  }
  let sa = null;
  function ep() {
    return (sa === null || sa.byteLength === 0) && (sa = new Float32Array(f.memory.buffer)), sa;
  }
  function Md(r, t) {
    return r = r >>> 0, ep().subarray(r / 4, r / 4 + t);
  }
  let aa = null;
  function np() {
    return (aa === null || aa.byteLength === 0) && (aa = new Uint32Array(f.memory.buffer)), aa;
  }
  function zb(r, t) {
    return r = r >>> 0, np().subarray(r / 4, r / 4 + t);
  }
  let Qe = 0;
  function Jr(r, t) {
    const e = t(r.length * 4, 4) >>> 0;
    return np().set(r, e / 4), Qe = r.length, e;
  }
  function pi(r, t) {
    const e = t(r.length * 4, 4) >>> 0;
    return ep().set(r, e / 4), Qe = r.length, e;
  }
  const Wa = Object.freeze({
    LinX: 0,
    0: "LinX",
    LinY: 1,
    1: "LinY",
    LinZ: 2,
    2: "LinZ",
    AngX: 3,
    3: "AngX",
    AngY: 4,
    4: "AngY",
    AngZ: 5,
    5: "AngZ"
  }), Sn = Object.freeze({
    Revolute: 0,
    0: "Revolute",
    Fixed: 1,
    1: "Fixed",
    Prismatic: 2,
    2: "Prismatic",
    Rope: 3,
    3: "Rope",
    Spring: 4,
    4: "Spring",
    Spherical: 5,
    5: "Spherical",
    Generic: 6,
    6: "Generic"
  }), ze = Object.freeze({
    Ball: 0,
    0: "Ball",
    Cuboid: 1,
    1: "Cuboid",
    Capsule: 2,
    2: "Capsule",
    Segment: 3,
    3: "Segment",
    Polyline: 4,
    4: "Polyline",
    Triangle: 5,
    5: "Triangle",
    TriMesh: 6,
    6: "TriMesh",
    HeightField: 7,
    7: "HeightField",
    Compound: 8,
    8: "Compound",
    ConvexPolyhedron: 9,
    9: "ConvexPolyhedron",
    Cylinder: 10,
    10: "Cylinder",
    Cone: 11,
    11: "Cone",
    RoundCuboid: 12,
    12: "RoundCuboid",
    RoundTriangle: 13,
    13: "RoundTriangle",
    RoundCylinder: 14,
    14: "RoundCylinder",
    RoundCone: 15,
    15: "RoundCone",
    RoundConvexPolyhedron: 16,
    16: "RoundConvexPolyhedron",
    HalfSpace: 17,
    17: "HalfSpace",
    Voxels: 18,
    18: "Voxels"
  }), ic = typeof FinalizationRegistry > "u" ? {
    register: () => {
    },
    unregister: () => {
    }
  } : new FinalizationRegistry((r) => f.__wbg_rawbroadphase_free(r >>> 0, 1));
  class ti {
    static __wrap(t) {
      t = t >>> 0;
      const e = Object.create(ti.prototype);
      return e.__wbg_ptr = t, ic.register(e, e.__wbg_ptr, e), e;
    }
    __destroy_into_raw() {
      const t = this.__wbg_ptr;
      return this.__wbg_ptr = 0, ic.unregister(this), t;
    }
    free() {
      const t = this.__destroy_into_raw();
      f.__wbg_rawbroadphase_free(t, 0);
    }
    constructor() {
      const t = f.rawbroadphase_new();
      return this.__wbg_ptr = t >>> 0, ic.register(this, this.__wbg_ptr, this), this;
    }
    castRay(t, e, n, i, s, a, o, c, l, h, d, u) {
      try {
        C(t, De), C(e, pe), C(n, ve), C(i, N), C(s, N);
        const p = f.rawbroadphase_castRay(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr, n.__wbg_ptr, i.__wbg_ptr, s.__wbg_ptr, a, o, c, Et(l) ? 4294967297 : l >>> 0, !Et(h), Et(h) ? 0 : h, !Et(d), Et(d) ? 0 : d, ge(u));
        return p === 0 ? void 0 : Kc.__wrap(p);
      } finally {
        te[le++] = void 0;
      }
    }
    castRayAndGetNormal(t, e, n, i, s, a, o, c, l, h, d, u) {
      try {
        C(t, De), C(e, pe), C(n, ve), C(i, N), C(s, N);
        const p = f.rawbroadphase_castRayAndGetNormal(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr, n.__wbg_ptr, i.__wbg_ptr, s.__wbg_ptr, a, o, c, Et(l) ? 4294967297 : l >>> 0, !Et(h), Et(h) ? 0 : h, !Et(d), Et(d) ? 0 : d, ge(u));
        return p === 0 ? void 0 : qa.__wrap(p);
      } finally {
        te[le++] = void 0;
      }
    }
    intersectionsWithRay(t, e, n, i, s, a, o, c, l, h, d, u, p) {
      try {
        C(t, De), C(e, pe), C(n, ve), C(i, N), C(s, N), f.rawbroadphase_intersectionsWithRay(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr, n.__wbg_ptr, i.__wbg_ptr, s.__wbg_ptr, a, o, ge(c), l, Et(h) ? 4294967297 : h >>> 0, !Et(d), Et(d) ? 0 : d, !Et(u), Et(u) ? 0 : u, ge(p));
      } finally {
        te[le++] = void 0, te[le++] = void 0;
      }
    }
    intersectionWithShape(t, e, n, i, s, a, o, c, l, h, d) {
      try {
        const w = f.__wbindgen_add_to_stack_pointer(-16);
        C(t, De), C(e, pe), C(n, ve), C(i, N), C(s, Wt), C(a, xt), f.rawbroadphase_intersectionWithShape(w, this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr, n.__wbg_ptr, i.__wbg_ptr, s.__wbg_ptr, a.__wbg_ptr, o, Et(c) ? 4294967297 : c >>> 0, !Et(l), Et(l) ? 0 : l, !Et(h), Et(h) ? 0 : h, ge(d));
        var u = Le().getInt32(w + 0, true), p = Le().getFloat64(w + 8, true);
        return u === 0 ? void 0 : p;
      } finally {
        f.__wbindgen_add_to_stack_pointer(16), te[le++] = void 0;
      }
    }
    projectPoint(t, e, n, i, s, a, o, c, l, h) {
      try {
        C(t, De), C(e, pe), C(n, ve), C(i, N);
        const d = f.rawbroadphase_projectPoint(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr, n.__wbg_ptr, i.__wbg_ptr, s, a, Et(o) ? 4294967297 : o >>> 0, !Et(c), Et(c) ? 0 : c, !Et(l), Et(l) ? 0 : l, ge(h));
        return d === 0 ? void 0 : xa.__wrap(d);
      } finally {
        te[le++] = void 0;
      }
    }
    projectPointAndGetFeature(t, e, n, i, s, a, o, c, l) {
      try {
        C(t, De), C(e, pe), C(n, ve), C(i, N);
        const h = f.rawbroadphase_projectPointAndGetFeature(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr, n.__wbg_ptr, i.__wbg_ptr, s, Et(a) ? 4294967297 : a >>> 0, !Et(o), Et(o) ? 0 : o, !Et(c), Et(c) ? 0 : c, ge(l));
        return h === 0 ? void 0 : xa.__wrap(h);
      } finally {
        te[le++] = void 0;
      }
    }
    intersectionsWithPoint(t, e, n, i, s, a, o, c, l, h) {
      try {
        C(t, De), C(e, pe), C(n, ve), C(i, N), f.rawbroadphase_intersectionsWithPoint(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr, n.__wbg_ptr, i.__wbg_ptr, ge(s), a, Et(o) ? 4294967297 : o >>> 0, !Et(c), Et(c) ? 0 : c, !Et(l), Et(l) ? 0 : l, ge(h));
      } finally {
        te[le++] = void 0, te[le++] = void 0;
      }
    }
    castShape(t, e, n, i, s, a, o, c, l, h, d, u, p, w, b) {
      try {
        C(t, De), C(e, pe), C(n, ve), C(i, N), C(s, Wt), C(a, N), C(o, xt);
        const m = f.rawbroadphase_castShape(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr, n.__wbg_ptr, i.__wbg_ptr, s.__wbg_ptr, a.__wbg_ptr, o.__wbg_ptr, c, l, h, d, Et(u) ? 4294967297 : u >>> 0, !Et(p), Et(p) ? 0 : p, !Et(w), Et(w) ? 0 : w, ge(b));
        return m === 0 ? void 0 : ja.__wrap(m);
      } finally {
        te[le++] = void 0;
      }
    }
    intersectionsWithShape(t, e, n, i, s, a, o, c, l, h, d, u) {
      try {
        C(t, De), C(e, pe), C(n, ve), C(i, N), C(s, Wt), C(a, xt), f.rawbroadphase_intersectionsWithShape(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr, n.__wbg_ptr, i.__wbg_ptr, s.__wbg_ptr, a.__wbg_ptr, ge(o), c, Et(l) ? 4294967297 : l >>> 0, !Et(h), Et(h) ? 0 : h, !Et(d), Et(d) ? 0 : d, ge(u));
      } finally {
        te[le++] = void 0, te[le++] = void 0;
      }
    }
    collidersWithAabbIntersectingAabb(t, e, n, i, s, a) {
      try {
        C(t, De), C(e, pe), C(n, ve), C(i, N), C(s, N), f.rawbroadphase_collidersWithAabbIntersectingAabb(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr, n.__wbg_ptr, i.__wbg_ptr, s.__wbg_ptr, ge(a));
      } finally {
        te[le++] = void 0;
      }
    }
  }
  const Ed = typeof FinalizationRegistry > "u" ? {
    register: () => {
    },
    unregister: () => {
    }
  } : new FinalizationRegistry((r) => f.__wbg_rawccdsolver_free(r >>> 0, 1));
  class Rc {
    __destroy_into_raw() {
      const t = this.__wbg_ptr;
      return this.__wbg_ptr = 0, Ed.unregister(this), t;
    }
    free() {
      const t = this.__destroy_into_raw();
      f.__wbg_rawccdsolver_free(t, 0);
    }
    constructor() {
      const t = f.rawccdsolver_new();
      return this.__wbg_ptr = t >>> 0, Ed.register(this, this.__wbg_ptr, this), this;
    }
  }
  const Td = typeof FinalizationRegistry > "u" ? {
    register: () => {
    },
    unregister: () => {
    }
  } : new FinalizationRegistry((r) => f.__wbg_rawcharactercollision_free(r >>> 0, 1));
  class ip {
    __destroy_into_raw() {
      const t = this.__wbg_ptr;
      return this.__wbg_ptr = 0, Td.unregister(this), t;
    }
    free() {
      const t = this.__destroy_into_raw();
      f.__wbg_rawcharactercollision_free(t, 0);
    }
    constructor() {
      const t = f.rawcharactercollision_new();
      return this.__wbg_ptr = t >>> 0, Td.register(this, this.__wbg_ptr, this), this;
    }
    handle() {
      return f.rawcharactercollision_handle(this.__wbg_ptr);
    }
    translationDeltaApplied() {
      const t = f.rawcharactercollision_translationDeltaApplied(this.__wbg_ptr);
      return N.__wrap(t);
    }
    translationDeltaRemaining() {
      const t = f.rawcharactercollision_translationDeltaRemaining(this.__wbg_ptr);
      return N.__wrap(t);
    }
    toi() {
      return f.rawcharactercollision_toi(this.__wbg_ptr);
    }
    worldWitness1() {
      const t = f.rawcharactercollision_worldWitness1(this.__wbg_ptr);
      return N.__wrap(t);
    }
    worldWitness2() {
      const t = f.rawcharactercollision_worldWitness2(this.__wbg_ptr);
      return N.__wrap(t);
    }
    worldNormal1() {
      const t = f.rawcharactercollision_worldNormal1(this.__wbg_ptr);
      return N.__wrap(t);
    }
    worldNormal2() {
      const t = f.rawcharactercollision_worldNormal2(this.__wbg_ptr);
      return N.__wrap(t);
    }
  }
  const rc = typeof FinalizationRegistry > "u" ? {
    register: () => {
    },
    unregister: () => {
    }
  } : new FinalizationRegistry((r) => f.__wbg_rawcolliderset_free(r >>> 0, 1));
  class ve {
    static __wrap(t) {
      t = t >>> 0;
      const e = Object.create(ve.prototype);
      return e.__wbg_ptr = t, rc.register(e, e.__wbg_ptr, e), e;
    }
    __destroy_into_raw() {
      const t = this.__wbg_ptr;
      return this.__wbg_ptr = 0, rc.unregister(this), t;
    }
    free() {
      const t = this.__destroy_into_raw();
      f.__wbg_rawcolliderset_free(t, 0);
    }
    coTranslation(t) {
      const e = f.rawcolliderset_coTranslation(this.__wbg_ptr, t);
      return N.__wrap(e);
    }
    coRotation(t) {
      const e = f.rawcolliderset_coRotation(this.__wbg_ptr, t);
      return Wt.__wrap(e);
    }
    coTranslationWrtParent(t) {
      const e = f.rawcolliderset_coTranslationWrtParent(this.__wbg_ptr, t);
      return e === 0 ? void 0 : N.__wrap(e);
    }
    coRotationWrtParent(t) {
      const e = f.rawcolliderset_coRotationWrtParent(this.__wbg_ptr, t);
      return e === 0 ? void 0 : Wt.__wrap(e);
    }
    coSetTranslation(t, e, n, i) {
      f.rawcolliderset_coSetTranslation(this.__wbg_ptr, t, e, n, i);
    }
    coSetTranslationWrtParent(t, e, n, i) {
      f.rawcolliderset_coSetTranslationWrtParent(this.__wbg_ptr, t, e, n, i);
    }
    coSetRotation(t, e, n, i, s) {
      f.rawcolliderset_coSetRotation(this.__wbg_ptr, t, e, n, i, s);
    }
    coSetRotationWrtParent(t, e, n, i, s) {
      f.rawcolliderset_coSetRotationWrtParent(this.__wbg_ptr, t, e, n, i, s);
    }
    coIsSensor(t) {
      return f.rawcolliderset_coIsSensor(this.__wbg_ptr, t) !== 0;
    }
    coShapeType(t) {
      return f.rawcolliderset_coShapeType(this.__wbg_ptr, t);
    }
    coHalfspaceNormal(t) {
      const e = f.rawcolliderset_coHalfspaceNormal(this.__wbg_ptr, t);
      return e === 0 ? void 0 : N.__wrap(e);
    }
    coHalfExtents(t) {
      const e = f.rawcolliderset_coHalfExtents(this.__wbg_ptr, t);
      return e === 0 ? void 0 : N.__wrap(e);
    }
    coSetHalfExtents(t, e) {
      C(e, N), f.rawcolliderset_coSetHalfExtents(this.__wbg_ptr, t, e.__wbg_ptr);
    }
    coRadius(t) {
      const e = f.rawcolliderset_coRadius(this.__wbg_ptr, t);
      return e === 4294967297 ? void 0 : e;
    }
    coSetRadius(t, e) {
      f.rawcolliderset_coSetRadius(this.__wbg_ptr, t, e);
    }
    coHalfHeight(t) {
      const e = f.rawcolliderset_coHalfHeight(this.__wbg_ptr, t);
      return e === 4294967297 ? void 0 : e;
    }
    coSetHalfHeight(t, e) {
      f.rawcolliderset_coSetHalfHeight(this.__wbg_ptr, t, e);
    }
    coRoundRadius(t) {
      const e = f.rawcolliderset_coRoundRadius(this.__wbg_ptr, t);
      return e === 4294967297 ? void 0 : e;
    }
    coSetRoundRadius(t, e) {
      f.rawcolliderset_coSetRoundRadius(this.__wbg_ptr, t, e);
    }
    coVoxelData(t) {
      try {
        const i = f.__wbindgen_add_to_stack_pointer(-16);
        f.rawcolliderset_coVoxelData(i, this.__wbg_ptr, t);
        var e = Le().getInt32(i + 0, true), n = Le().getInt32(i + 4, true);
        let s;
        return e !== 0 && (s = Bb(e, n).slice(), f.__wbindgen_export_1(e, n * 4, 4)), s;
      } finally {
        f.__wbindgen_add_to_stack_pointer(16);
      }
    }
    coVoxelSize(t) {
      const e = f.rawcolliderset_coVoxelSize(this.__wbg_ptr, t);
      return e === 0 ? void 0 : N.__wrap(e);
    }
    coSetVoxel(t, e, n, i, s) {
      f.rawcolliderset_coSetVoxel(this.__wbg_ptr, t, e, n, i, s);
    }
    coPropagateVoxelChange(t, e, n, i, s, a, o, c) {
      f.rawcolliderset_coPropagateVoxelChange(this.__wbg_ptr, t, e, n, i, s, a, o, c);
    }
    coCombineVoxelStates(t, e, n, i, s) {
      f.rawcolliderset_coCombineVoxelStates(this.__wbg_ptr, t, e, n, i, s);
    }
    coVertices(t) {
      try {
        const i = f.__wbindgen_add_to_stack_pointer(-16);
        f.rawcolliderset_coVertices(i, this.__wbg_ptr, t);
        var e = Le().getInt32(i + 0, true), n = Le().getInt32(i + 4, true);
        let s;
        return e !== 0 && (s = Md(e, n).slice(), f.__wbindgen_export_1(e, n * 4, 4)), s;
      } finally {
        f.__wbindgen_add_to_stack_pointer(16);
      }
    }
    coIndices(t) {
      try {
        const i = f.__wbindgen_add_to_stack_pointer(-16);
        f.rawcolliderset_coIndices(i, this.__wbg_ptr, t);
        var e = Le().getInt32(i + 0, true), n = Le().getInt32(i + 4, true);
        let s;
        return e !== 0 && (s = zb(e, n).slice(), f.__wbindgen_export_1(e, n * 4, 4)), s;
      } finally {
        f.__wbindgen_add_to_stack_pointer(16);
      }
    }
    coTriMeshFlags(t) {
      const e = f.rawcolliderset_coTriMeshFlags(this.__wbg_ptr, t);
      return e === 4294967297 ? void 0 : e;
    }
    coHeightFieldFlags(t) {
      const e = f.rawcolliderset_coHeightFieldFlags(this.__wbg_ptr, t);
      return e === 4294967297 ? void 0 : e;
    }
    coHeightfieldHeights(t) {
      try {
        const i = f.__wbindgen_add_to_stack_pointer(-16);
        f.rawcolliderset_coHeightfieldHeights(i, this.__wbg_ptr, t);
        var e = Le().getInt32(i + 0, true), n = Le().getInt32(i + 4, true);
        let s;
        return e !== 0 && (s = Md(e, n).slice(), f.__wbindgen_export_1(e, n * 4, 4)), s;
      } finally {
        f.__wbindgen_add_to_stack_pointer(16);
      }
    }
    coHeightfieldScale(t) {
      const e = f.rawcolliderset_coHeightfieldScale(this.__wbg_ptr, t);
      return e === 0 ? void 0 : N.__wrap(e);
    }
    coHeightfieldNRows(t) {
      const e = f.rawcolliderset_coHeightfieldNRows(this.__wbg_ptr, t);
      return e === 4294967297 ? void 0 : e;
    }
    coHeightfieldNCols(t) {
      const e = f.rawcolliderset_coHeightfieldNCols(this.__wbg_ptr, t);
      return e === 4294967297 ? void 0 : e;
    }
    coParent(t) {
      try {
        const i = f.__wbindgen_add_to_stack_pointer(-16);
        f.rawcolliderset_coParent(i, this.__wbg_ptr, t);
        var e = Le().getInt32(i + 0, true), n = Le().getFloat64(i + 8, true);
        return e === 0 ? void 0 : n;
      } finally {
        f.__wbindgen_add_to_stack_pointer(16);
      }
    }
    coSetEnabled(t, e) {
      f.rawcolliderset_coSetEnabled(this.__wbg_ptr, t, e);
    }
    coIsEnabled(t) {
      return f.rawcolliderset_coIsEnabled(this.__wbg_ptr, t) !== 0;
    }
    coSetContactSkin(t, e) {
      f.rawcolliderset_coSetContactSkin(this.__wbg_ptr, t, e);
    }
    coContactSkin(t) {
      return f.rawcolliderset_coContactSkin(this.__wbg_ptr, t);
    }
    coFriction(t) {
      return f.rawcolliderset_coFriction(this.__wbg_ptr, t);
    }
    coRestitution(t) {
      return f.rawcolliderset_coRestitution(this.__wbg_ptr, t);
    }
    coDensity(t) {
      return f.rawcolliderset_coDensity(this.__wbg_ptr, t);
    }
    coMass(t) {
      return f.rawcolliderset_coMass(this.__wbg_ptr, t);
    }
    coVolume(t) {
      return f.rawcolliderset_coVolume(this.__wbg_ptr, t);
    }
    coCollisionGroups(t) {
      return f.rawcolliderset_coCollisionGroups(this.__wbg_ptr, t) >>> 0;
    }
    coSolverGroups(t) {
      return f.rawcolliderset_coSolverGroups(this.__wbg_ptr, t) >>> 0;
    }
    coActiveHooks(t) {
      return f.rawcolliderset_coActiveHooks(this.__wbg_ptr, t) >>> 0;
    }
    coActiveCollisionTypes(t) {
      return f.rawcolliderset_coActiveCollisionTypes(this.__wbg_ptr, t);
    }
    coActiveEvents(t) {
      return f.rawcolliderset_coActiveEvents(this.__wbg_ptr, t) >>> 0;
    }
    coContactForceEventThreshold(t) {
      return f.rawcolliderset_coContactForceEventThreshold(this.__wbg_ptr, t);
    }
    coContainsPoint(t, e) {
      return C(e, N), f.rawcolliderset_coContainsPoint(this.__wbg_ptr, t, e.__wbg_ptr) !== 0;
    }
    coCastShape(t, e, n, i, s, a, o, c, l) {
      C(e, N), C(n, xt), C(i, N), C(s, Wt), C(a, N);
      const h = f.rawcolliderset_coCastShape(this.__wbg_ptr, t, e.__wbg_ptr, n.__wbg_ptr, i.__wbg_ptr, s.__wbg_ptr, a.__wbg_ptr, o, c, l);
      return h === 0 ? void 0 : Ya.__wrap(h);
    }
    coCastCollider(t, e, n, i, s, a, o) {
      C(e, N), C(i, N);
      const c = f.rawcolliderset_coCastCollider(this.__wbg_ptr, t, e.__wbg_ptr, n, i.__wbg_ptr, s, a, o);
      return c === 0 ? void 0 : ja.__wrap(c);
    }
    coIntersectsShape(t, e, n, i) {
      return C(e, xt), C(n, N), C(i, Wt), f.rawcolliderset_coIntersectsShape(this.__wbg_ptr, t, e.__wbg_ptr, n.__wbg_ptr, i.__wbg_ptr) !== 0;
    }
    coContactShape(t, e, n, i, s) {
      C(e, xt), C(n, N), C(i, Wt);
      const a = f.rawcolliderset_coContactShape(this.__wbg_ptr, t, e.__wbg_ptr, n.__wbg_ptr, i.__wbg_ptr, s);
      return a === 0 ? void 0 : ps.__wrap(a);
    }
    coContactCollider(t, e, n) {
      const i = f.rawcolliderset_coContactCollider(this.__wbg_ptr, t, e, n);
      return i === 0 ? void 0 : ps.__wrap(i);
    }
    coProjectPoint(t, e, n) {
      C(e, N);
      const i = f.rawcolliderset_coProjectPoint(this.__wbg_ptr, t, e.__wbg_ptr, n);
      return Xa.__wrap(i);
    }
    coIntersectsRay(t, e, n, i) {
      return C(e, N), C(n, N), f.rawcolliderset_coIntersectsRay(this.__wbg_ptr, t, e.__wbg_ptr, n.__wbg_ptr, i) !== 0;
    }
    coCastRay(t, e, n, i, s) {
      return C(e, N), C(n, N), f.rawcolliderset_coCastRay(this.__wbg_ptr, t, e.__wbg_ptr, n.__wbg_ptr, i, s);
    }
    coCastRayAndGetNormal(t, e, n, i, s) {
      C(e, N), C(n, N);
      const a = f.rawcolliderset_coCastRayAndGetNormal(this.__wbg_ptr, t, e.__wbg_ptr, n.__wbg_ptr, i, s);
      return a === 0 ? void 0 : Ka.__wrap(a);
    }
    coSetSensor(t, e) {
      f.rawcolliderset_coSetSensor(this.__wbg_ptr, t, e);
    }
    coSetRestitution(t, e) {
      f.rawcolliderset_coSetRestitution(this.__wbg_ptr, t, e);
    }
    coSetFriction(t, e) {
      f.rawcolliderset_coSetFriction(this.__wbg_ptr, t, e);
    }
    coFrictionCombineRule(t) {
      return f.rawcolliderset_coFrictionCombineRule(this.__wbg_ptr, t) >>> 0;
    }
    coSetFrictionCombineRule(t, e) {
      f.rawcolliderset_coSetFrictionCombineRule(this.__wbg_ptr, t, e);
    }
    coRestitutionCombineRule(t) {
      return f.rawcolliderset_coRestitutionCombineRule(this.__wbg_ptr, t) >>> 0;
    }
    coSetRestitutionCombineRule(t, e) {
      f.rawcolliderset_coSetRestitutionCombineRule(this.__wbg_ptr, t, e);
    }
    coSetCollisionGroups(t, e) {
      f.rawcolliderset_coSetCollisionGroups(this.__wbg_ptr, t, e);
    }
    coSetSolverGroups(t, e) {
      f.rawcolliderset_coSetSolverGroups(this.__wbg_ptr, t, e);
    }
    coSetActiveHooks(t, e) {
      f.rawcolliderset_coSetActiveHooks(this.__wbg_ptr, t, e);
    }
    coSetActiveEvents(t, e) {
      f.rawcolliderset_coSetActiveEvents(this.__wbg_ptr, t, e);
    }
    coSetActiveCollisionTypes(t, e) {
      f.rawcolliderset_coSetActiveCollisionTypes(this.__wbg_ptr, t, e);
    }
    coSetShape(t, e) {
      C(e, xt), f.rawcolliderset_coSetShape(this.__wbg_ptr, t, e.__wbg_ptr);
    }
    coSetContactForceEventThreshold(t, e) {
      f.rawcolliderset_coSetContactForceEventThreshold(this.__wbg_ptr, t, e);
    }
    coSetDensity(t, e) {
      f.rawcolliderset_coSetDensity(this.__wbg_ptr, t, e);
    }
    coSetMass(t, e) {
      f.rawcolliderset_coSetMass(this.__wbg_ptr, t, e);
    }
    coSetMassProperties(t, e, n, i, s) {
      C(n, N), C(i, N), C(s, Wt), f.rawcolliderset_coSetMassProperties(this.__wbg_ptr, t, e, n.__wbg_ptr, i.__wbg_ptr, s.__wbg_ptr);
    }
    constructor() {
      const t = f.rawcolliderset_new();
      return this.__wbg_ptr = t >>> 0, rc.register(this, this.__wbg_ptr, this), this;
    }
    len() {
      return f.rawcolliderset_len(this.__wbg_ptr) >>> 0;
    }
    contains(t) {
      return f.rawcolliderset_contains(this.__wbg_ptr, t) !== 0;
    }
    createCollider(t, e, n, i, s, a, o, c, l, h, d, u, p, w, b, m, _, E, v, T, O, R, P, z, A) {
      try {
        const W = f.__wbindgen_add_to_stack_pointer(-16);
        C(e, xt), C(n, N), C(i, Wt), C(o, N), C(c, N), C(l, Wt), C(A, pe), f.rawcolliderset_createCollider(W, this.__wbg_ptr, t, e.__wbg_ptr, n.__wbg_ptr, i.__wbg_ptr, s, a, o.__wbg_ptr, c.__wbg_ptr, l.__wbg_ptr, h, d, u, p, w, b, m, _, E, v, T, O, R, P, z, A.__wbg_ptr);
        var S = Le().getInt32(W + 0, true), F = Le().getFloat64(W + 8, true);
        return S === 0 ? void 0 : F;
      } finally {
        f.__wbindgen_add_to_stack_pointer(16);
      }
    }
    remove(t, e, n, i) {
      C(e, ni), C(n, pe), f.rawcolliderset_remove(this.__wbg_ptr, t, e.__wbg_ptr, n.__wbg_ptr, i);
    }
    isHandleValid(t) {
      return f.rawcolliderset_contains(this.__wbg_ptr, t) !== 0;
    }
    forEachColliderHandle(t) {
      try {
        f.rawcolliderset_forEachColliderHandle(this.__wbg_ptr, ge(t));
      } finally {
        te[le++] = void 0;
      }
    }
  }
  const Ad = typeof FinalizationRegistry > "u" ? {
    register: () => {
    },
    unregister: () => {
    }
  } : new FinalizationRegistry((r) => f.__wbg_rawcollidershapecasthit_free(r >>> 0, 1));
  class ja {
    static __wrap(t) {
      t = t >>> 0;
      const e = Object.create(ja.prototype);
      return e.__wbg_ptr = t, Ad.register(e, e.__wbg_ptr, e), e;
    }
    __destroy_into_raw() {
      const t = this.__wbg_ptr;
      return this.__wbg_ptr = 0, Ad.unregister(this), t;
    }
    free() {
      const t = this.__destroy_into_raw();
      f.__wbg_rawcollidershapecasthit_free(t, 0);
    }
    colliderHandle() {
      return f.rawcharactercollision_handle(this.__wbg_ptr);
    }
    time_of_impact() {
      return f.rawcollidershapecasthit_time_of_impact(this.__wbg_ptr);
    }
    witness1() {
      const t = f.rawcollidershapecasthit_witness1(this.__wbg_ptr);
      return N.__wrap(t);
    }
    witness2() {
      const t = f.rawcollidershapecasthit_witness2(this.__wbg_ptr);
      return N.__wrap(t);
    }
    normal1() {
      const t = f.rawcharactercollision_translationDeltaApplied(this.__wbg_ptr);
      return N.__wrap(t);
    }
    normal2() {
      const t = f.rawcharactercollision_translationDeltaRemaining(this.__wbg_ptr);
      return N.__wrap(t);
    }
  }
  const Rd = typeof FinalizationRegistry > "u" ? {
    register: () => {
    },
    unregister: () => {
    }
  } : new FinalizationRegistry((r) => f.__wbg_rawcontactforceevent_free(r >>> 0, 1));
  class Wc {
    static __wrap(t) {
      t = t >>> 0;
      const e = Object.create(Wc.prototype);
      return e.__wbg_ptr = t, Rd.register(e, e.__wbg_ptr, e), e;
    }
    __destroy_into_raw() {
      const t = this.__wbg_ptr;
      return this.__wbg_ptr = 0, Rd.unregister(this), t;
    }
    free() {
      const t = this.__destroy_into_raw();
      f.__wbg_rawcontactforceevent_free(t, 0);
    }
    collider1() {
      return f.rawcharactercollision_handle(this.__wbg_ptr);
    }
    collider2() {
      return f.rawcontactforceevent_collider2(this.__wbg_ptr);
    }
    total_force() {
      const t = f.rawcontactforceevent_total_force(this.__wbg_ptr);
      return N.__wrap(t);
    }
    total_force_magnitude() {
      return f.rawcontactforceevent_total_force_magnitude(this.__wbg_ptr);
    }
    max_force_direction() {
      const t = f.rawcontactforceevent_max_force_direction(this.__wbg_ptr);
      return N.__wrap(t);
    }
    max_force_magnitude() {
      return f.rawcontactforceevent_max_force_magnitude(this.__wbg_ptr);
    }
  }
  const Cd = typeof FinalizationRegistry > "u" ? {
    register: () => {
    },
    unregister: () => {
    }
  } : new FinalizationRegistry((r) => f.__wbg_rawcontactmanifold_free(r >>> 0, 1));
  class jc {
    static __wrap(t) {
      t = t >>> 0;
      const e = Object.create(jc.prototype);
      return e.__wbg_ptr = t, Cd.register(e, e.__wbg_ptr, e), e;
    }
    __destroy_into_raw() {
      const t = this.__wbg_ptr;
      return this.__wbg_ptr = 0, Cd.unregister(this), t;
    }
    free() {
      const t = this.__destroy_into_raw();
      f.__wbg_rawcontactmanifold_free(t, 0);
    }
    normal() {
      const t = f.rawcontactmanifold_normal(this.__wbg_ptr);
      return N.__wrap(t);
    }
    local_n1() {
      const t = f.rawcontactmanifold_local_n1(this.__wbg_ptr);
      return N.__wrap(t);
    }
    local_n2() {
      const t = f.rawcontactmanifold_local_n2(this.__wbg_ptr);
      return N.__wrap(t);
    }
    subshape1() {
      return f.rawcontactmanifold_subshape1(this.__wbg_ptr) >>> 0;
    }
    subshape2() {
      return f.rawcontactmanifold_subshape2(this.__wbg_ptr) >>> 0;
    }
    num_contacts() {
      return f.rawcontactmanifold_num_contacts(this.__wbg_ptr) >>> 0;
    }
    contact_local_p1(t) {
      const e = f.rawcontactmanifold_contact_local_p1(this.__wbg_ptr, t);
      return e === 0 ? void 0 : N.__wrap(e);
    }
    contact_local_p2(t) {
      const e = f.rawcontactmanifold_contact_local_p2(this.__wbg_ptr, t);
      return e === 0 ? void 0 : N.__wrap(e);
    }
    contact_dist(t) {
      return f.rawcontactmanifold_contact_dist(this.__wbg_ptr, t);
    }
    contact_fid1(t) {
      return f.rawcontactmanifold_contact_fid1(this.__wbg_ptr, t) >>> 0;
    }
    contact_fid2(t) {
      return f.rawcontactmanifold_contact_fid2(this.__wbg_ptr, t) >>> 0;
    }
    contact_impulse(t) {
      return f.rawcontactmanifold_contact_impulse(this.__wbg_ptr, t);
    }
    contact_tangent_impulse_x(t) {
      return f.rawcontactmanifold_contact_tangent_impulse_x(this.__wbg_ptr, t);
    }
    contact_tangent_impulse_y(t) {
      return f.rawcontactmanifold_contact_tangent_impulse_y(this.__wbg_ptr, t);
    }
    num_solver_contacts() {
      return f.rawcontactmanifold_num_solver_contacts(this.__wbg_ptr) >>> 0;
    }
    solver_contact_point(t) {
      const e = f.rawcontactmanifold_solver_contact_point(this.__wbg_ptr, t);
      return e === 0 ? void 0 : N.__wrap(e);
    }
    solver_contact_dist(t) {
      return f.rawcontactmanifold_solver_contact_dist(this.__wbg_ptr, t);
    }
    solver_contact_friction(t) {
      return f.rawcontactmanifold_solver_contact_friction(this.__wbg_ptr, t);
    }
    solver_contact_restitution(t) {
      return f.rawcontactmanifold_solver_contact_restitution(this.__wbg_ptr, t);
    }
    solver_contact_tangent_velocity(t) {
      const e = f.rawcontactmanifold_solver_contact_tangent_velocity(this.__wbg_ptr, t);
      return N.__wrap(e);
    }
  }
  const Pd = typeof FinalizationRegistry > "u" ? {
    register: () => {
    },
    unregister: () => {
    }
  } : new FinalizationRegistry((r) => f.__wbg_rawcontactpair_free(r >>> 0, 1));
  class Xc {
    static __wrap(t) {
      t = t >>> 0;
      const e = Object.create(Xc.prototype);
      return e.__wbg_ptr = t, Pd.register(e, e.__wbg_ptr, e), e;
    }
    __destroy_into_raw() {
      const t = this.__wbg_ptr;
      return this.__wbg_ptr = 0, Pd.unregister(this), t;
    }
    free() {
      const t = this.__destroy_into_raw();
      f.__wbg_rawcontactpair_free(t, 0);
    }
    collider1() {
      return f.rawcontactpair_collider1(this.__wbg_ptr);
    }
    collider2() {
      return f.rawcontactpair_collider2(this.__wbg_ptr);
    }
    numContactManifolds() {
      return f.rawcontactpair_numContactManifolds(this.__wbg_ptr) >>> 0;
    }
    contactManifold(t) {
      const e = f.rawcontactpair_contactManifold(this.__wbg_ptr, t);
      return e === 0 ? void 0 : jc.__wrap(e);
    }
  }
  const Id = typeof FinalizationRegistry > "u" ? {
    register: () => {
    },
    unregister: () => {
    }
  } : new FinalizationRegistry((r) => f.__wbg_rawdebugrenderpipeline_free(r >>> 0, 1));
  class kb {
    __destroy_into_raw() {
      const t = this.__wbg_ptr;
      return this.__wbg_ptr = 0, Id.unregister(this), t;
    }
    free() {
      const t = this.__destroy_into_raw();
      f.__wbg_rawdebugrenderpipeline_free(t, 0);
    }
    constructor() {
      const t = f.rawdebugrenderpipeline_new();
      return this.__wbg_ptr = t >>> 0, Id.register(this, this.__wbg_ptr, this), this;
    }
    vertices() {
      const t = f.rawdebugrenderpipeline_vertices(this.__wbg_ptr);
      return us(t);
    }
    colors() {
      const t = f.rawdebugrenderpipeline_colors(this.__wbg_ptr);
      return us(t);
    }
    render(t, e, n, i, s, a, o) {
      try {
        C(t, pe), C(e, ve), C(n, ei), C(i, ii), C(s, De), f.rawdebugrenderpipeline_render(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr, n.__wbg_ptr, i.__wbg_ptr, s.__wbg_ptr, a, ge(o));
      } finally {
        te[le++] = void 0;
      }
    }
  }
  const Ld = typeof FinalizationRegistry > "u" ? {
    register: () => {
    },
    unregister: () => {
    }
  } : new FinalizationRegistry((r) => f.__wbg_rawdeserializedworld_free(r >>> 0, 1));
  class qc {
    static __wrap(t) {
      t = t >>> 0;
      const e = Object.create(qc.prototype);
      return e.__wbg_ptr = t, Ld.register(e, e.__wbg_ptr, e), e;
    }
    __destroy_into_raw() {
      const t = this.__wbg_ptr;
      return this.__wbg_ptr = 0, Ld.unregister(this), t;
    }
    free() {
      const t = this.__destroy_into_raw();
      f.__wbg_rawdeserializedworld_free(t, 0);
    }
    takeGravity() {
      const t = f.rawdeserializedworld_takeGravity(this.__wbg_ptr);
      return t === 0 ? void 0 : N.__wrap(t);
    }
    takeIntegrationParameters() {
      const t = f.rawdeserializedworld_takeIntegrationParameters(this.__wbg_ptr);
      return t === 0 ? void 0 : zi.__wrap(t);
    }
    takeIslandManager() {
      const t = f.rawdeserializedworld_takeIslandManager(this.__wbg_ptr);
      return t === 0 ? void 0 : ni.__wrap(t);
    }
    takeBroadPhase() {
      const t = f.rawdeserializedworld_takeBroadPhase(this.__wbg_ptr);
      return t === 0 ? void 0 : ti.__wrap(t);
    }
    takeNarrowPhase() {
      const t = f.rawdeserializedworld_takeNarrowPhase(this.__wbg_ptr);
      return t === 0 ? void 0 : De.__wrap(t);
    }
    takeBodies() {
      const t = f.rawdeserializedworld_takeBodies(this.__wbg_ptr);
      return t === 0 ? void 0 : pe.__wrap(t);
    }
    takeColliders() {
      const t = f.rawdeserializedworld_takeColliders(this.__wbg_ptr);
      return t === 0 ? void 0 : ve.__wrap(t);
    }
    takeImpulseJoints() {
      const t = f.rawdeserializedworld_takeImpulseJoints(this.__wbg_ptr);
      return t === 0 ? void 0 : ei.__wrap(t);
    }
    takeMultibodyJoints() {
      const t = f.rawdeserializedworld_takeMultibodyJoints(this.__wbg_ptr);
      return t === 0 ? void 0 : ii.__wrap(t);
    }
  }
  const Dd = typeof FinalizationRegistry > "u" ? {
    register: () => {
    },
    unregister: () => {
    }
  } : new FinalizationRegistry((r) => f.__wbg_rawdynamicraycastvehiclecontroller_free(r >>> 0, 1));
  class Hb {
    __destroy_into_raw() {
      const t = this.__wbg_ptr;
      return this.__wbg_ptr = 0, Dd.unregister(this), t;
    }
    free() {
      const t = this.__destroy_into_raw();
      f.__wbg_rawdynamicraycastvehiclecontroller_free(t, 0);
    }
    constructor(t) {
      const e = f.rawdynamicraycastvehiclecontroller_new(t);
      return this.__wbg_ptr = e >>> 0, Dd.register(this, this.__wbg_ptr, this), this;
    }
    current_vehicle_speed() {
      return f.rawdynamicraycastvehiclecontroller_current_vehicle_speed(this.__wbg_ptr);
    }
    chassis() {
      return f.rawdynamicraycastvehiclecontroller_chassis(this.__wbg_ptr);
    }
    index_up_axis() {
      return f.rawdynamicraycastvehiclecontroller_index_up_axis(this.__wbg_ptr) >>> 0;
    }
    set_index_up_axis(t) {
      f.rawdynamicraycastvehiclecontroller_set_index_up_axis(this.__wbg_ptr, t);
    }
    index_forward_axis() {
      return f.rawdynamicraycastvehiclecontroller_index_forward_axis(this.__wbg_ptr) >>> 0;
    }
    set_index_forward_axis(t) {
      f.rawdynamicraycastvehiclecontroller_set_index_forward_axis(this.__wbg_ptr, t);
    }
    add_wheel(t, e, n, i, s) {
      C(t, N), C(e, N), C(n, N), f.rawdynamicraycastvehiclecontroller_add_wheel(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr, n.__wbg_ptr, i, s);
    }
    num_wheels() {
      return f.rawdynamicraycastvehiclecontroller_num_wheels(this.__wbg_ptr) >>> 0;
    }
    update_vehicle(t, e, n, i, s, a, o, c) {
      try {
        C(e, ti), C(n, De), C(i, pe), C(s, ve), f.rawdynamicraycastvehiclecontroller_update_vehicle(this.__wbg_ptr, t, e.__wbg_ptr, n.__wbg_ptr, i.__wbg_ptr, s.__wbg_ptr, a, Et(o) ? 4294967297 : o >>> 0, ge(c));
      } finally {
        te[le++] = void 0;
      }
    }
    wheel_chassis_connection_point_cs(t) {
      const e = f.rawdynamicraycastvehiclecontroller_wheel_chassis_connection_point_cs(this.__wbg_ptr, t);
      return e === 0 ? void 0 : N.__wrap(e);
    }
    set_wheel_chassis_connection_point_cs(t, e) {
      C(e, N), f.rawdynamicraycastvehiclecontroller_set_wheel_chassis_connection_point_cs(this.__wbg_ptr, t, e.__wbg_ptr);
    }
    wheel_suspension_rest_length(t) {
      const e = f.rawdynamicraycastvehiclecontroller_wheel_suspension_rest_length(this.__wbg_ptr, t);
      return e === 4294967297 ? void 0 : e;
    }
    set_wheel_suspension_rest_length(t, e) {
      f.rawdynamicraycastvehiclecontroller_set_wheel_suspension_rest_length(this.__wbg_ptr, t, e);
    }
    wheel_max_suspension_travel(t) {
      const e = f.rawdynamicraycastvehiclecontroller_wheel_max_suspension_travel(this.__wbg_ptr, t);
      return e === 4294967297 ? void 0 : e;
    }
    set_wheel_max_suspension_travel(t, e) {
      f.rawdynamicraycastvehiclecontroller_set_wheel_max_suspension_travel(this.__wbg_ptr, t, e);
    }
    wheel_radius(t) {
      const e = f.rawdynamicraycastvehiclecontroller_wheel_radius(this.__wbg_ptr, t);
      return e === 4294967297 ? void 0 : e;
    }
    set_wheel_radius(t, e) {
      f.rawdynamicraycastvehiclecontroller_set_wheel_radius(this.__wbg_ptr, t, e);
    }
    wheel_suspension_stiffness(t) {
      const e = f.rawdynamicraycastvehiclecontroller_wheel_suspension_stiffness(this.__wbg_ptr, t);
      return e === 4294967297 ? void 0 : e;
    }
    set_wheel_suspension_stiffness(t, e) {
      f.rawdynamicraycastvehiclecontroller_set_wheel_suspension_stiffness(this.__wbg_ptr, t, e);
    }
    wheel_suspension_compression(t) {
      const e = f.rawdynamicraycastvehiclecontroller_wheel_suspension_compression(this.__wbg_ptr, t);
      return e === 4294967297 ? void 0 : e;
    }
    set_wheel_suspension_compression(t, e) {
      f.rawdynamicraycastvehiclecontroller_set_wheel_suspension_compression(this.__wbg_ptr, t, e);
    }
    wheel_suspension_relaxation(t) {
      const e = f.rawdynamicraycastvehiclecontroller_wheel_suspension_relaxation(this.__wbg_ptr, t);
      return e === 4294967297 ? void 0 : e;
    }
    set_wheel_suspension_relaxation(t, e) {
      f.rawdynamicraycastvehiclecontroller_set_wheel_suspension_relaxation(this.__wbg_ptr, t, e);
    }
    wheel_max_suspension_force(t) {
      const e = f.rawdynamicraycastvehiclecontroller_wheel_max_suspension_force(this.__wbg_ptr, t);
      return e === 4294967297 ? void 0 : e;
    }
    set_wheel_max_suspension_force(t, e) {
      f.rawdynamicraycastvehiclecontroller_set_wheel_max_suspension_force(this.__wbg_ptr, t, e);
    }
    wheel_brake(t) {
      const e = f.rawdynamicraycastvehiclecontroller_wheel_brake(this.__wbg_ptr, t);
      return e === 4294967297 ? void 0 : e;
    }
    set_wheel_brake(t, e) {
      f.rawdynamicraycastvehiclecontroller_set_wheel_brake(this.__wbg_ptr, t, e);
    }
    wheel_steering(t) {
      const e = f.rawdynamicraycastvehiclecontroller_wheel_steering(this.__wbg_ptr, t);
      return e === 4294967297 ? void 0 : e;
    }
    set_wheel_steering(t, e) {
      f.rawdynamicraycastvehiclecontroller_set_wheel_steering(this.__wbg_ptr, t, e);
    }
    wheel_engine_force(t) {
      const e = f.rawdynamicraycastvehiclecontroller_wheel_engine_force(this.__wbg_ptr, t);
      return e === 4294967297 ? void 0 : e;
    }
    set_wheel_engine_force(t, e) {
      f.rawdynamicraycastvehiclecontroller_set_wheel_engine_force(this.__wbg_ptr, t, e);
    }
    wheel_direction_cs(t) {
      const e = f.rawdynamicraycastvehiclecontroller_wheel_direction_cs(this.__wbg_ptr, t);
      return e === 0 ? void 0 : N.__wrap(e);
    }
    set_wheel_direction_cs(t, e) {
      C(e, N), f.rawdynamicraycastvehiclecontroller_set_wheel_direction_cs(this.__wbg_ptr, t, e.__wbg_ptr);
    }
    wheel_axle_cs(t) {
      const e = f.rawdynamicraycastvehiclecontroller_wheel_axle_cs(this.__wbg_ptr, t);
      return e === 0 ? void 0 : N.__wrap(e);
    }
    set_wheel_axle_cs(t, e) {
      C(e, N), f.rawdynamicraycastvehiclecontroller_set_wheel_axle_cs(this.__wbg_ptr, t, e.__wbg_ptr);
    }
    wheel_friction_slip(t) {
      const e = f.rawdynamicraycastvehiclecontroller_wheel_friction_slip(this.__wbg_ptr, t);
      return e === 4294967297 ? void 0 : e;
    }
    set_wheel_friction_slip(t, e) {
      f.rawdynamicraycastvehiclecontroller_set_wheel_friction_slip(this.__wbg_ptr, t, e);
    }
    wheel_side_friction_stiffness(t) {
      const e = f.rawdynamicraycastvehiclecontroller_wheel_side_friction_stiffness(this.__wbg_ptr, t);
      return e === 4294967297 ? void 0 : e;
    }
    set_wheel_side_friction_stiffness(t, e) {
      f.rawdynamicraycastvehiclecontroller_set_wheel_side_friction_stiffness(this.__wbg_ptr, t, e);
    }
    wheel_rotation(t) {
      const e = f.rawdynamicraycastvehiclecontroller_wheel_rotation(this.__wbg_ptr, t);
      return e === 4294967297 ? void 0 : e;
    }
    wheel_forward_impulse(t) {
      const e = f.rawdynamicraycastvehiclecontroller_wheel_forward_impulse(this.__wbg_ptr, t);
      return e === 4294967297 ? void 0 : e;
    }
    wheel_side_impulse(t) {
      const e = f.rawdynamicraycastvehiclecontroller_wheel_side_impulse(this.__wbg_ptr, t);
      return e === 4294967297 ? void 0 : e;
    }
    wheel_suspension_force(t) {
      const e = f.rawdynamicraycastvehiclecontroller_wheel_suspension_force(this.__wbg_ptr, t);
      return e === 4294967297 ? void 0 : e;
    }
    wheel_contact_normal_ws(t) {
      const e = f.rawdynamicraycastvehiclecontroller_wheel_contact_normal_ws(this.__wbg_ptr, t);
      return e === 0 ? void 0 : N.__wrap(e);
    }
    wheel_contact_point_ws(t) {
      const e = f.rawdynamicraycastvehiclecontroller_wheel_contact_point_ws(this.__wbg_ptr, t);
      return e === 0 ? void 0 : N.__wrap(e);
    }
    wheel_suspension_length(t) {
      const e = f.rawdynamicraycastvehiclecontroller_wheel_suspension_length(this.__wbg_ptr, t);
      return e === 4294967297 ? void 0 : e;
    }
    wheel_hard_point_ws(t) {
      const e = f.rawdynamicraycastvehiclecontroller_wheel_hard_point_ws(this.__wbg_ptr, t);
      return e === 0 ? void 0 : N.__wrap(e);
    }
    wheel_is_in_contact(t) {
      return f.rawdynamicraycastvehiclecontroller_wheel_is_in_contact(this.__wbg_ptr, t) !== 0;
    }
    wheel_ground_object(t) {
      try {
        const i = f.__wbindgen_add_to_stack_pointer(-16);
        f.rawdynamicraycastvehiclecontroller_wheel_ground_object(i, this.__wbg_ptr, t);
        var e = Le().getInt32(i + 0, true), n = Le().getFloat64(i + 8, true);
        return e === 0 ? void 0 : n;
      } finally {
        f.__wbindgen_add_to_stack_pointer(16);
      }
    }
  }
  const Nd = typeof FinalizationRegistry > "u" ? {
    register: () => {
    },
    unregister: () => {
    }
  } : new FinalizationRegistry((r) => f.__wbg_raweventqueue_free(r >>> 0, 1));
  class rp {
    __destroy_into_raw() {
      const t = this.__wbg_ptr;
      return this.__wbg_ptr = 0, Nd.unregister(this), t;
    }
    free() {
      const t = this.__destroy_into_raw();
      f.__wbg_raweventqueue_free(t, 0);
    }
    constructor(t) {
      const e = f.raweventqueue_new(t);
      return this.__wbg_ptr = e >>> 0, Nd.register(this, this.__wbg_ptr, this), this;
    }
    drainCollisionEvents(t) {
      try {
        f.raweventqueue_drainCollisionEvents(this.__wbg_ptr, ge(t));
      } finally {
        te[le++] = void 0;
      }
    }
    drainContactForceEvents(t) {
      try {
        f.raweventqueue_drainContactForceEvents(this.__wbg_ptr, ge(t));
      } finally {
        te[le++] = void 0;
      }
    }
    clear() {
      f.raweventqueue_clear(this.__wbg_ptr);
    }
  }
  const Ud = typeof FinalizationRegistry > "u" ? {
    register: () => {
    },
    unregister: () => {
    }
  } : new FinalizationRegistry((r) => f.__wbg_rawgenericjoint_free(r >>> 0, 1));
  class He {
    static __wrap(t) {
      t = t >>> 0;
      const e = Object.create(He.prototype);
      return e.__wbg_ptr = t, Ud.register(e, e.__wbg_ptr, e), e;
    }
    __destroy_into_raw() {
      const t = this.__wbg_ptr;
      return this.__wbg_ptr = 0, Ud.unregister(this), t;
    }
    free() {
      const t = this.__destroy_into_raw();
      f.__wbg_rawgenericjoint_free(t, 0);
    }
    static generic(t, e, n, i) {
      C(t, N), C(e, N), C(n, N);
      const s = f.rawgenericjoint_generic(t.__wbg_ptr, e.__wbg_ptr, n.__wbg_ptr, i);
      return s === 0 ? void 0 : He.__wrap(s);
    }
    static spring(t, e, n, i, s) {
      C(i, N), C(s, N);
      const a = f.rawgenericjoint_spring(t, e, n, i.__wbg_ptr, s.__wbg_ptr);
      return He.__wrap(a);
    }
    static rope(t, e, n) {
      C(e, N), C(n, N);
      const i = f.rawgenericjoint_rope(t, e.__wbg_ptr, n.__wbg_ptr);
      return He.__wrap(i);
    }
    static spherical(t, e) {
      C(t, N), C(e, N);
      const n = f.rawgenericjoint_spherical(t.__wbg_ptr, e.__wbg_ptr);
      return He.__wrap(n);
    }
    static prismatic(t, e, n, i, s, a) {
      C(t, N), C(e, N), C(n, N);
      const o = f.rawgenericjoint_prismatic(t.__wbg_ptr, e.__wbg_ptr, n.__wbg_ptr, i, s, a);
      return o === 0 ? void 0 : He.__wrap(o);
    }
    static fixed(t, e, n, i) {
      C(t, N), C(e, Wt), C(n, N), C(i, Wt);
      const s = f.rawgenericjoint_fixed(t.__wbg_ptr, e.__wbg_ptr, n.__wbg_ptr, i.__wbg_ptr);
      return He.__wrap(s);
    }
    static revolute(t, e, n) {
      C(t, N), C(e, N), C(n, N);
      const i = f.rawgenericjoint_revolute(t.__wbg_ptr, e.__wbg_ptr, n.__wbg_ptr);
      return i === 0 ? void 0 : He.__wrap(i);
    }
  }
  const sc = typeof FinalizationRegistry > "u" ? {
    register: () => {
    },
    unregister: () => {
    }
  } : new FinalizationRegistry((r) => f.__wbg_rawimpulsejointset_free(r >>> 0, 1));
  class ei {
    static __wrap(t) {
      t = t >>> 0;
      const e = Object.create(ei.prototype);
      return e.__wbg_ptr = t, sc.register(e, e.__wbg_ptr, e), e;
    }
    __destroy_into_raw() {
      const t = this.__wbg_ptr;
      return this.__wbg_ptr = 0, sc.unregister(this), t;
    }
    free() {
      const t = this.__destroy_into_raw();
      f.__wbg_rawimpulsejointset_free(t, 0);
    }
    jointType(t) {
      return f.rawimpulsejointset_jointType(this.__wbg_ptr, t);
    }
    jointBodyHandle1(t) {
      return f.rawimpulsejointset_jointBodyHandle1(this.__wbg_ptr, t);
    }
    jointBodyHandle2(t) {
      return f.rawimpulsejointset_jointBodyHandle2(this.__wbg_ptr, t);
    }
    jointFrameX1(t) {
      const e = f.rawimpulsejointset_jointFrameX1(this.__wbg_ptr, t);
      return Wt.__wrap(e);
    }
    jointFrameX2(t) {
      const e = f.rawimpulsejointset_jointFrameX2(this.__wbg_ptr, t);
      return Wt.__wrap(e);
    }
    jointAnchor1(t) {
      const e = f.rawimpulsejointset_jointAnchor1(this.__wbg_ptr, t);
      return N.__wrap(e);
    }
    jointAnchor2(t) {
      const e = f.rawimpulsejointset_jointAnchor2(this.__wbg_ptr, t);
      return N.__wrap(e);
    }
    jointSetAnchor1(t, e) {
      C(e, N), f.rawimpulsejointset_jointSetAnchor1(this.__wbg_ptr, t, e.__wbg_ptr);
    }
    jointSetAnchor2(t, e) {
      C(e, N), f.rawimpulsejointset_jointSetAnchor2(this.__wbg_ptr, t, e.__wbg_ptr);
    }
    jointContactsEnabled(t) {
      return f.rawimpulsejointset_jointContactsEnabled(this.__wbg_ptr, t) !== 0;
    }
    jointSetContactsEnabled(t, e) {
      f.rawimpulsejointset_jointSetContactsEnabled(this.__wbg_ptr, t, e);
    }
    jointLimitsEnabled(t, e) {
      return f.rawimpulsejointset_jointLimitsEnabled(this.__wbg_ptr, t, e) !== 0;
    }
    jointLimitsMin(t, e) {
      return f.rawimpulsejointset_jointLimitsMin(this.__wbg_ptr, t, e);
    }
    jointLimitsMax(t, e) {
      return f.rawimpulsejointset_jointLimitsMax(this.__wbg_ptr, t, e);
    }
    jointSetLimits(t, e, n, i) {
      f.rawimpulsejointset_jointSetLimits(this.__wbg_ptr, t, e, n, i);
    }
    jointConfigureMotorModel(t, e, n) {
      f.rawimpulsejointset_jointConfigureMotorModel(this.__wbg_ptr, t, e, n);
    }
    jointConfigureMotorVelocity(t, e, n, i) {
      f.rawimpulsejointset_jointConfigureMotorVelocity(this.__wbg_ptr, t, e, n, i);
    }
    jointConfigureMotorPosition(t, e, n, i, s) {
      f.rawimpulsejointset_jointConfigureMotorPosition(this.__wbg_ptr, t, e, n, i, s);
    }
    jointConfigureMotor(t, e, n, i, s, a) {
      f.rawimpulsejointset_jointConfigureMotor(this.__wbg_ptr, t, e, n, i, s, a);
    }
    constructor() {
      const t = f.rawimpulsejointset_new();
      return this.__wbg_ptr = t >>> 0, sc.register(this, this.__wbg_ptr, this), this;
    }
    createJoint(t, e, n, i) {
      return C(t, He), f.rawimpulsejointset_createJoint(this.__wbg_ptr, t.__wbg_ptr, e, n, i);
    }
    remove(t, e) {
      f.rawimpulsejointset_remove(this.__wbg_ptr, t, e);
    }
    len() {
      return f.rawimpulsejointset_len(this.__wbg_ptr) >>> 0;
    }
    contains(t) {
      return f.rawimpulsejointset_contains(this.__wbg_ptr, t) !== 0;
    }
    forEachJointHandle(t) {
      try {
        f.rawimpulsejointset_forEachJointHandle(this.__wbg_ptr, ge(t));
      } finally {
        te[le++] = void 0;
      }
    }
    forEachJointAttachedToRigidBody(t, e) {
      try {
        f.rawimpulsejointset_forEachJointAttachedToRigidBody(this.__wbg_ptr, t, ge(e));
      } finally {
        te[le++] = void 0;
      }
    }
  }
  const ac = typeof FinalizationRegistry > "u" ? {
    register: () => {
    },
    unregister: () => {
    }
  } : new FinalizationRegistry((r) => f.__wbg_rawintegrationparameters_free(r >>> 0, 1));
  class zi {
    static __wrap(t) {
      t = t >>> 0;
      const e = Object.create(zi.prototype);
      return e.__wbg_ptr = t, ac.register(e, e.__wbg_ptr, e), e;
    }
    __destroy_into_raw() {
      const t = this.__wbg_ptr;
      return this.__wbg_ptr = 0, ac.unregister(this), t;
    }
    free() {
      const t = this.__destroy_into_raw();
      f.__wbg_rawintegrationparameters_free(t, 0);
    }
    constructor() {
      const t = f.rawintegrationparameters_new();
      return this.__wbg_ptr = t >>> 0, ac.register(this, this.__wbg_ptr, this), this;
    }
    get dt() {
      return f.rawintegrationparameters_dt(this.__wbg_ptr);
    }
    get contact_erp() {
      return f.rawintegrationparameters_contact_erp(this.__wbg_ptr);
    }
    get normalizedAllowedLinearError() {
      return f.rawintegrationparameters_normalizedAllowedLinearError(this.__wbg_ptr);
    }
    get normalizedPredictionDistance() {
      return f.rawintegrationparameters_normalizedPredictionDistance(this.__wbg_ptr);
    }
    get numSolverIterations() {
      return f.rawintegrationparameters_numSolverIterations(this.__wbg_ptr) >>> 0;
    }
    get numInternalPgsIterations() {
      return f.rawdynamicraycastvehiclecontroller_index_up_axis(this.__wbg_ptr) >>> 0;
    }
    get minIslandSize() {
      return f.rawintegrationparameters_minIslandSize(this.__wbg_ptr) >>> 0;
    }
    get maxCcdSubsteps() {
      return f.rawintegrationparameters_maxCcdSubsteps(this.__wbg_ptr) >>> 0;
    }
    get lengthUnit() {
      return f.rawcontactforceevent_total_force_magnitude(this.__wbg_ptr);
    }
    set dt(t) {
      f.rawintegrationparameters_set_dt(this.__wbg_ptr, t);
    }
    set contact_natural_frequency(t) {
      f.rawintegrationparameters_set_contact_natural_frequency(this.__wbg_ptr, t);
    }
    set normalizedAllowedLinearError(t) {
      f.rawintegrationparameters_set_normalizedAllowedLinearError(this.__wbg_ptr, t);
    }
    set normalizedPredictionDistance(t) {
      f.rawintegrationparameters_set_normalizedPredictionDistance(this.__wbg_ptr, t);
    }
    set numSolverIterations(t) {
      f.rawintegrationparameters_set_numSolverIterations(this.__wbg_ptr, t);
    }
    set numInternalPgsIterations(t) {
      f.rawdynamicraycastvehiclecontroller_set_index_up_axis(this.__wbg_ptr, t);
    }
    set minIslandSize(t) {
      f.rawintegrationparameters_set_minIslandSize(this.__wbg_ptr, t);
    }
    set maxCcdSubsteps(t) {
      f.rawintegrationparameters_set_maxCcdSubsteps(this.__wbg_ptr, t);
    }
    set lengthUnit(t) {
      f.rawintegrationparameters_set_lengthUnit(this.__wbg_ptr, t);
    }
  }
  const oc = typeof FinalizationRegistry > "u" ? {
    register: () => {
    },
    unregister: () => {
    }
  } : new FinalizationRegistry((r) => f.__wbg_rawislandmanager_free(r >>> 0, 1));
  class ni {
    static __wrap(t) {
      t = t >>> 0;
      const e = Object.create(ni.prototype);
      return e.__wbg_ptr = t, oc.register(e, e.__wbg_ptr, e), e;
    }
    __destroy_into_raw() {
      const t = this.__wbg_ptr;
      return this.__wbg_ptr = 0, oc.unregister(this), t;
    }
    free() {
      const t = this.__destroy_into_raw();
      f.__wbg_rawislandmanager_free(t, 0);
    }
    constructor() {
      const t = f.rawislandmanager_new();
      return this.__wbg_ptr = t >>> 0, oc.register(this, this.__wbg_ptr, this), this;
    }
    forEachActiveRigidBodyHandle(t) {
      try {
        f.rawislandmanager_forEachActiveRigidBodyHandle(this.__wbg_ptr, ge(t));
      } finally {
        te[le++] = void 0;
      }
    }
  }
  const Fd = typeof FinalizationRegistry > "u" ? {
    register: () => {
    },
    unregister: () => {
    }
  } : new FinalizationRegistry((r) => f.__wbg_rawkinematiccharactercontroller_free(r >>> 0, 1));
  class Gb {
    __destroy_into_raw() {
      const t = this.__wbg_ptr;
      return this.__wbg_ptr = 0, Fd.unregister(this), t;
    }
    free() {
      const t = this.__destroy_into_raw();
      f.__wbg_rawkinematiccharactercontroller_free(t, 0);
    }
    constructor(t) {
      const e = f.rawkinematiccharactercontroller_new(t);
      return this.__wbg_ptr = e >>> 0, Fd.register(this, this.__wbg_ptr, this), this;
    }
    up() {
      const t = f.rawcharactercollision_translationDeltaApplied(this.__wbg_ptr);
      return N.__wrap(t);
    }
    setUp(t) {
      C(t, N), f.rawkinematiccharactercontroller_setUp(this.__wbg_ptr, t.__wbg_ptr);
    }
    normalNudgeFactor() {
      return f.rawkinematiccharactercontroller_normalNudgeFactor(this.__wbg_ptr);
    }
    setNormalNudgeFactor(t) {
      f.rawkinematiccharactercontroller_setNormalNudgeFactor(this.__wbg_ptr, t);
    }
    offset() {
      return f.rawkinematiccharactercontroller_offset(this.__wbg_ptr);
    }
    setOffset(t) {
      f.rawkinematiccharactercontroller_setOffset(this.__wbg_ptr, t);
    }
    slideEnabled() {
      return f.rawkinematiccharactercontroller_slideEnabled(this.__wbg_ptr) !== 0;
    }
    setSlideEnabled(t) {
      f.rawkinematiccharactercontroller_setSlideEnabled(this.__wbg_ptr, t);
    }
    autostepMaxHeight() {
      const t = f.rawkinematiccharactercontroller_autostepMaxHeight(this.__wbg_ptr);
      return t === 4294967297 ? void 0 : t;
    }
    autostepMinWidth() {
      const t = f.rawkinematiccharactercontroller_autostepMinWidth(this.__wbg_ptr);
      return t === 4294967297 ? void 0 : t;
    }
    autostepIncludesDynamicBodies() {
      const t = f.rawkinematiccharactercontroller_autostepIncludesDynamicBodies(this.__wbg_ptr);
      return t === 16777215 ? void 0 : t !== 0;
    }
    autostepEnabled() {
      return f.rawkinematiccharactercontroller_autostepEnabled(this.__wbg_ptr) !== 0;
    }
    enableAutostep(t, e, n) {
      f.rawkinematiccharactercontroller_enableAutostep(this.__wbg_ptr, t, e, n);
    }
    disableAutostep() {
      f.rawkinematiccharactercontroller_disableAutostep(this.__wbg_ptr);
    }
    maxSlopeClimbAngle() {
      return f.rawkinematiccharactercontroller_maxSlopeClimbAngle(this.__wbg_ptr);
    }
    setMaxSlopeClimbAngle(t) {
      f.rawkinematiccharactercontroller_setMaxSlopeClimbAngle(this.__wbg_ptr, t);
    }
    minSlopeSlideAngle() {
      return f.rawkinematiccharactercontroller_minSlopeSlideAngle(this.__wbg_ptr);
    }
    setMinSlopeSlideAngle(t) {
      f.rawkinematiccharactercontroller_setMinSlopeSlideAngle(this.__wbg_ptr, t);
    }
    snapToGroundDistance() {
      const t = f.rawkinematiccharactercontroller_snapToGroundDistance(this.__wbg_ptr);
      return t === 4294967297 ? void 0 : t;
    }
    enableSnapToGround(t) {
      f.rawkinematiccharactercontroller_enableSnapToGround(this.__wbg_ptr, t);
    }
    disableSnapToGround() {
      f.rawkinematiccharactercontroller_disableSnapToGround(this.__wbg_ptr);
    }
    snapToGroundEnabled() {
      return f.rawkinematiccharactercontroller_snapToGroundEnabled(this.__wbg_ptr) !== 0;
    }
    computeColliderMovement(t, e, n, i, s, a, o, c, l, h, d, u) {
      try {
        C(e, ti), C(n, De), C(i, pe), C(s, ve), C(o, N), f.rawkinematiccharactercontroller_computeColliderMovement(this.__wbg_ptr, t, e.__wbg_ptr, n.__wbg_ptr, i.__wbg_ptr, s.__wbg_ptr, a, o.__wbg_ptr, c, Et(l) ? 4294967297 : Math.fround(l), h, Et(d) ? 4294967297 : d >>> 0, ge(u));
      } finally {
        te[le++] = void 0;
      }
    }
    computedMovement() {
      const t = f.rawkinematiccharactercontroller_computedMovement(this.__wbg_ptr);
      return N.__wrap(t);
    }
    computedGrounded() {
      return f.rawkinematiccharactercontroller_computedGrounded(this.__wbg_ptr) !== 0;
    }
    numComputedCollisions() {
      return f.rawkinematiccharactercontroller_numComputedCollisions(this.__wbg_ptr) >>> 0;
    }
    computedCollision(t, e) {
      return C(e, ip), f.rawkinematiccharactercontroller_computedCollision(this.__wbg_ptr, t, e.__wbg_ptr) !== 0;
    }
  }
  const cc = typeof FinalizationRegistry > "u" ? {
    register: () => {
    },
    unregister: () => {
    }
  } : new FinalizationRegistry((r) => f.__wbg_rawmultibodyjointset_free(r >>> 0, 1));
  class ii {
    static __wrap(t) {
      t = t >>> 0;
      const e = Object.create(ii.prototype);
      return e.__wbg_ptr = t, cc.register(e, e.__wbg_ptr, e), e;
    }
    __destroy_into_raw() {
      const t = this.__wbg_ptr;
      return this.__wbg_ptr = 0, cc.unregister(this), t;
    }
    free() {
      const t = this.__destroy_into_raw();
      f.__wbg_rawmultibodyjointset_free(t, 0);
    }
    jointType(t) {
      return f.rawmultibodyjointset_jointType(this.__wbg_ptr, t);
    }
    jointFrameX1(t) {
      const e = f.rawmultibodyjointset_jointFrameX1(this.__wbg_ptr, t);
      return Wt.__wrap(e);
    }
    jointFrameX2(t) {
      const e = f.rawmultibodyjointset_jointFrameX2(this.__wbg_ptr, t);
      return Wt.__wrap(e);
    }
    jointAnchor1(t) {
      const e = f.rawmultibodyjointset_jointAnchor1(this.__wbg_ptr, t);
      return N.__wrap(e);
    }
    jointAnchor2(t) {
      const e = f.rawmultibodyjointset_jointAnchor2(this.__wbg_ptr, t);
      return N.__wrap(e);
    }
    jointContactsEnabled(t) {
      return f.rawmultibodyjointset_jointContactsEnabled(this.__wbg_ptr, t) !== 0;
    }
    jointSetContactsEnabled(t, e) {
      f.rawmultibodyjointset_jointSetContactsEnabled(this.__wbg_ptr, t, e);
    }
    jointLimitsEnabled(t, e) {
      return f.rawmultibodyjointset_jointLimitsEnabled(this.__wbg_ptr, t, e) !== 0;
    }
    jointLimitsMin(t, e) {
      return f.rawmultibodyjointset_jointLimitsMin(this.__wbg_ptr, t, e);
    }
    jointLimitsMax(t, e) {
      return f.rawmultibodyjointset_jointLimitsMax(this.__wbg_ptr, t, e);
    }
    constructor() {
      const t = f.rawmultibodyjointset_new();
      return this.__wbg_ptr = t >>> 0, cc.register(this, this.__wbg_ptr, this), this;
    }
    createJoint(t, e, n, i) {
      return C(t, He), f.rawmultibodyjointset_createJoint(this.__wbg_ptr, t.__wbg_ptr, e, n, i);
    }
    remove(t, e) {
      f.rawmultibodyjointset_remove(this.__wbg_ptr, t, e);
    }
    contains(t) {
      return f.rawmultibodyjointset_contains(this.__wbg_ptr, t) !== 0;
    }
    forEachJointHandle(t) {
      try {
        f.rawmultibodyjointset_forEachJointHandle(this.__wbg_ptr, ge(t));
      } finally {
        te[le++] = void 0;
      }
    }
    forEachJointAttachedToRigidBody(t, e) {
      try {
        f.rawmultibodyjointset_forEachJointAttachedToRigidBody(this.__wbg_ptr, t, ge(e));
      } finally {
        te[le++] = void 0;
      }
    }
  }
  const lc = typeof FinalizationRegistry > "u" ? {
    register: () => {
    },
    unregister: () => {
    }
  } : new FinalizationRegistry((r) => f.__wbg_rawnarrowphase_free(r >>> 0, 1));
  class De {
    static __wrap(t) {
      t = t >>> 0;
      const e = Object.create(De.prototype);
      return e.__wbg_ptr = t, lc.register(e, e.__wbg_ptr, e), e;
    }
    __destroy_into_raw() {
      const t = this.__wbg_ptr;
      return this.__wbg_ptr = 0, lc.unregister(this), t;
    }
    free() {
      const t = this.__destroy_into_raw();
      f.__wbg_rawnarrowphase_free(t, 0);
    }
    constructor() {
      const t = f.rawnarrowphase_new();
      return this.__wbg_ptr = t >>> 0, lc.register(this, this.__wbg_ptr, this), this;
    }
    contact_pairs_with(t, e) {
      f.rawnarrowphase_contact_pairs_with(this.__wbg_ptr, t, he(e));
    }
    contact_pair(t, e) {
      const n = f.rawnarrowphase_contact_pair(this.__wbg_ptr, t, e);
      return n === 0 ? void 0 : Xc.__wrap(n);
    }
    intersection_pairs_with(t, e) {
      f.rawnarrowphase_intersection_pairs_with(this.__wbg_ptr, t, he(e));
    }
    intersection_pair(t, e) {
      return f.rawnarrowphase_intersection_pair(this.__wbg_ptr, t, e) !== 0;
    }
  }
  const Od = typeof FinalizationRegistry > "u" ? {
    register: () => {
    },
    unregister: () => {
    }
  } : new FinalizationRegistry((r) => f.__wbg_rawphysicspipeline_free(r >>> 0, 1));
  class Vb {
    __destroy_into_raw() {
      const t = this.__wbg_ptr;
      return this.__wbg_ptr = 0, Od.unregister(this), t;
    }
    free() {
      const t = this.__destroy_into_raw();
      f.__wbg_rawphysicspipeline_free(t, 0);
    }
    constructor() {
      const t = f.rawphysicspipeline_new();
      return this.__wbg_ptr = t >>> 0, Od.register(this, this.__wbg_ptr, this), this;
    }
    set_profiler_enabled(t) {
      f.rawphysicspipeline_set_profiler_enabled(this.__wbg_ptr, t);
    }
    is_profiler_enabled() {
      return f.rawphysicspipeline_is_profiler_enabled(this.__wbg_ptr) !== 0;
    }
    timing_step() {
      return f.rawphysicspipeline_timing_step(this.__wbg_ptr);
    }
    timing_collision_detection() {
      return f.rawphysicspipeline_timing_collision_detection(this.__wbg_ptr);
    }
    timing_broad_phase() {
      return f.rawphysicspipeline_timing_broad_phase(this.__wbg_ptr);
    }
    timing_narrow_phase() {
      return f.rawphysicspipeline_timing_narrow_phase(this.__wbg_ptr);
    }
    timing_solver() {
      return f.rawphysicspipeline_timing_solver(this.__wbg_ptr);
    }
    timing_velocity_assembly() {
      return f.rawphysicspipeline_timing_velocity_assembly(this.__wbg_ptr);
    }
    timing_velocity_resolution() {
      return f.rawphysicspipeline_timing_velocity_resolution(this.__wbg_ptr);
    }
    timing_velocity_update() {
      return f.rawphysicspipeline_timing_velocity_update(this.__wbg_ptr);
    }
    timing_velocity_writeback() {
      return f.rawphysicspipeline_timing_velocity_writeback(this.__wbg_ptr);
    }
    timing_ccd() {
      return f.rawphysicspipeline_timing_ccd(this.__wbg_ptr);
    }
    timing_ccd_toi_computation() {
      return f.rawphysicspipeline_timing_ccd_toi_computation(this.__wbg_ptr);
    }
    timing_ccd_broad_phase() {
      return f.rawphysicspipeline_timing_ccd_broad_phase(this.__wbg_ptr);
    }
    timing_ccd_narrow_phase() {
      return f.rawphysicspipeline_timing_ccd_narrow_phase(this.__wbg_ptr);
    }
    timing_ccd_solver() {
      return f.rawphysicspipeline_timing_ccd_solver(this.__wbg_ptr);
    }
    timing_island_construction() {
      return f.rawphysicspipeline_timing_island_construction(this.__wbg_ptr);
    }
    timing_user_changes() {
      return f.rawphysicspipeline_timing_user_changes(this.__wbg_ptr);
    }
    step(t, e, n, i, s, a, o, c, l, h) {
      C(t, N), C(e, zi), C(n, ni), C(i, ti), C(s, De), C(a, pe), C(o, ve), C(c, ei), C(l, ii), C(h, Rc), f.rawphysicspipeline_step(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr, n.__wbg_ptr, i.__wbg_ptr, s.__wbg_ptr, a.__wbg_ptr, o.__wbg_ptr, c.__wbg_ptr, l.__wbg_ptr, h.__wbg_ptr);
    }
    stepWithEvents(t, e, n, i, s, a, o, c, l, h, d, u, p, w) {
      C(t, N), C(e, zi), C(n, ni), C(i, ti), C(s, De), C(a, pe), C(o, ve), C(c, ei), C(l, ii), C(h, Rc), C(d, rp), f.rawphysicspipeline_stepWithEvents(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr, n.__wbg_ptr, i.__wbg_ptr, s.__wbg_ptr, a.__wbg_ptr, o.__wbg_ptr, c.__wbg_ptr, l.__wbg_ptr, h.__wbg_ptr, d.__wbg_ptr, he(u), he(p), he(w));
    }
  }
  const Bd = typeof FinalizationRegistry > "u" ? {
    register: () => {
    },
    unregister: () => {
    }
  } : new FinalizationRegistry((r) => f.__wbg_rawpidcontroller_free(r >>> 0, 1));
  class Wb {
    __destroy_into_raw() {
      const t = this.__wbg_ptr;
      return this.__wbg_ptr = 0, Bd.unregister(this), t;
    }
    free() {
      const t = this.__destroy_into_raw();
      f.__wbg_rawpidcontroller_free(t, 0);
    }
    constructor(t, e, n, i) {
      const s = f.rawpidcontroller_new(t, e, n, i);
      return this.__wbg_ptr = s >>> 0, Bd.register(this, this.__wbg_ptr, this), this;
    }
    set_kp(t, e) {
      f.rawpidcontroller_set_kp(this.__wbg_ptr, t, e);
    }
    set_ki(t, e) {
      f.rawpidcontroller_set_ki(this.__wbg_ptr, t, e);
    }
    set_kd(t, e) {
      f.rawpidcontroller_set_kd(this.__wbg_ptr, t, e);
    }
    set_axes_mask(t) {
      f.rawpidcontroller_set_axes_mask(this.__wbg_ptr, t);
    }
    reset_integrals() {
      f.rawpidcontroller_reset_integrals(this.__wbg_ptr);
    }
    apply_linear_correction(t, e, n, i, s) {
      C(e, pe), C(i, N), C(s, N), f.rawpidcontroller_apply_linear_correction(this.__wbg_ptr, t, e.__wbg_ptr, n, i.__wbg_ptr, s.__wbg_ptr);
    }
    apply_angular_correction(t, e, n, i, s) {
      C(e, pe), C(i, Wt), C(s, N), f.rawpidcontroller_apply_angular_correction(this.__wbg_ptr, t, e.__wbg_ptr, n, i.__wbg_ptr, s.__wbg_ptr);
    }
    linear_correction(t, e, n, i, s) {
      C(e, pe), C(i, N), C(s, N);
      const a = f.rawpidcontroller_linear_correction(this.__wbg_ptr, t, e.__wbg_ptr, n, i.__wbg_ptr, s.__wbg_ptr);
      return N.__wrap(a);
    }
    angular_correction(t, e, n, i, s) {
      C(e, pe), C(i, Wt), C(s, N);
      const a = f.rawpidcontroller_angular_correction(this.__wbg_ptr, t, e.__wbg_ptr, n, i.__wbg_ptr, s.__wbg_ptr);
      return N.__wrap(a);
    }
  }
  const zd = typeof FinalizationRegistry > "u" ? {
    register: () => {
    },
    unregister: () => {
    }
  } : new FinalizationRegistry((r) => f.__wbg_rawpointcolliderprojection_free(r >>> 0, 1));
  class xa {
    static __wrap(t) {
      t = t >>> 0;
      const e = Object.create(xa.prototype);
      return e.__wbg_ptr = t, zd.register(e, e.__wbg_ptr, e), e;
    }
    __destroy_into_raw() {
      const t = this.__wbg_ptr;
      return this.__wbg_ptr = 0, zd.unregister(this), t;
    }
    free() {
      const t = this.__destroy_into_raw();
      f.__wbg_rawpointcolliderprojection_free(t, 0);
    }
    colliderHandle() {
      return f.rawpointcolliderprojection_colliderHandle(this.__wbg_ptr);
    }
    point() {
      const t = f.rawpointcolliderprojection_point(this.__wbg_ptr);
      return N.__wrap(t);
    }
    isInside() {
      return f.rawpointcolliderprojection_isInside(this.__wbg_ptr) !== 0;
    }
    featureType() {
      return f.rawpointcolliderprojection_featureType(this.__wbg_ptr);
    }
    featureId() {
      const t = f.rawpointcolliderprojection_featureId(this.__wbg_ptr);
      return t === 4294967297 ? void 0 : t;
    }
  }
  const kd = typeof FinalizationRegistry > "u" ? {
    register: () => {
    },
    unregister: () => {
    }
  } : new FinalizationRegistry((r) => f.__wbg_rawpointprojection_free(r >>> 0, 1));
  class Xa {
    static __wrap(t) {
      t = t >>> 0;
      const e = Object.create(Xa.prototype);
      return e.__wbg_ptr = t, kd.register(e, e.__wbg_ptr, e), e;
    }
    __destroy_into_raw() {
      const t = this.__wbg_ptr;
      return this.__wbg_ptr = 0, kd.unregister(this), t;
    }
    free() {
      const t = this.__destroy_into_raw();
      f.__wbg_rawpointprojection_free(t, 0);
    }
    point() {
      const t = f.rawpointprojection_point(this.__wbg_ptr);
      return N.__wrap(t);
    }
    isInside() {
      return f.rawpointprojection_isInside(this.__wbg_ptr) !== 0;
    }
  }
  const Hd = typeof FinalizationRegistry > "u" ? {
    register: () => {
    },
    unregister: () => {
    }
  } : new FinalizationRegistry((r) => f.__wbg_rawraycolliderhit_free(r >>> 0, 1));
  class Kc {
    static __wrap(t) {
      t = t >>> 0;
      const e = Object.create(Kc.prototype);
      return e.__wbg_ptr = t, Hd.register(e, e.__wbg_ptr, e), e;
    }
    __destroy_into_raw() {
      const t = this.__wbg_ptr;
      return this.__wbg_ptr = 0, Hd.unregister(this), t;
    }
    free() {
      const t = this.__destroy_into_raw();
      f.__wbg_rawraycolliderhit_free(t, 0);
    }
    colliderHandle() {
      return f.rawcharactercollision_handle(this.__wbg_ptr);
    }
    timeOfImpact() {
      return f.rawcollidershapecasthit_time_of_impact(this.__wbg_ptr);
    }
  }
  const Gd = typeof FinalizationRegistry > "u" ? {
    register: () => {
    },
    unregister: () => {
    }
  } : new FinalizationRegistry((r) => f.__wbg_rawraycolliderintersection_free(r >>> 0, 1));
  class qa {
    static __wrap(t) {
      t = t >>> 0;
      const e = Object.create(qa.prototype);
      return e.__wbg_ptr = t, Gd.register(e, e.__wbg_ptr, e), e;
    }
    __destroy_into_raw() {
      const t = this.__wbg_ptr;
      return this.__wbg_ptr = 0, Gd.unregister(this), t;
    }
    free() {
      const t = this.__destroy_into_raw();
      f.__wbg_rawraycolliderintersection_free(t, 0);
    }
    colliderHandle() {
      return f.rawpointcolliderprojection_colliderHandle(this.__wbg_ptr);
    }
    normal() {
      const t = f.rawcollidershapecasthit_witness1(this.__wbg_ptr);
      return N.__wrap(t);
    }
    time_of_impact() {
      return f.rawcollidershapecasthit_time_of_impact(this.__wbg_ptr);
    }
    featureType() {
      return f.rawpointcolliderprojection_featureType(this.__wbg_ptr);
    }
    featureId() {
      const t = f.rawpointcolliderprojection_featureId(this.__wbg_ptr);
      return t === 4294967297 ? void 0 : t;
    }
  }
  const Vd = typeof FinalizationRegistry > "u" ? {
    register: () => {
    },
    unregister: () => {
    }
  } : new FinalizationRegistry((r) => f.__wbg_rawrayintersection_free(r >>> 0, 1));
  class Ka {
    static __wrap(t) {
      t = t >>> 0;
      const e = Object.create(Ka.prototype);
      return e.__wbg_ptr = t, Vd.register(e, e.__wbg_ptr, e), e;
    }
    __destroy_into_raw() {
      const t = this.__wbg_ptr;
      return this.__wbg_ptr = 0, Vd.unregister(this), t;
    }
    free() {
      const t = this.__destroy_into_raw();
      f.__wbg_rawrayintersection_free(t, 0);
    }
    normal() {
      const t = f.rawcollidershapecasthit_witness1(this.__wbg_ptr);
      return N.__wrap(t);
    }
    time_of_impact() {
      return f.rawcollidershapecasthit_time_of_impact(this.__wbg_ptr);
    }
    featureType() {
      return f.rawpointcolliderprojection_featureType(this.__wbg_ptr);
    }
    featureId() {
      const t = f.rawpointcolliderprojection_featureId(this.__wbg_ptr);
      return t === 4294967297 ? void 0 : t;
    }
  }
  const hc = typeof FinalizationRegistry > "u" ? {
    register: () => {
    },
    unregister: () => {
    }
  } : new FinalizationRegistry((r) => f.__wbg_rawrigidbodyset_free(r >>> 0, 1));
  class pe {
    static __wrap(t) {
      t = t >>> 0;
      const e = Object.create(pe.prototype);
      return e.__wbg_ptr = t, hc.register(e, e.__wbg_ptr, e), e;
    }
    __destroy_into_raw() {
      const t = this.__wbg_ptr;
      return this.__wbg_ptr = 0, hc.unregister(this), t;
    }
    free() {
      const t = this.__destroy_into_raw();
      f.__wbg_rawrigidbodyset_free(t, 0);
    }
    rbTranslation(t) {
      const e = f.rawrigidbodyset_rbTranslation(this.__wbg_ptr, t);
      return N.__wrap(e);
    }
    rbRotation(t) {
      const e = f.rawrigidbodyset_rbRotation(this.__wbg_ptr, t);
      return Wt.__wrap(e);
    }
    rbSleep(t) {
      f.rawrigidbodyset_rbSleep(this.__wbg_ptr, t);
    }
    rbIsSleeping(t) {
      return f.rawrigidbodyset_rbIsSleeping(this.__wbg_ptr, t) !== 0;
    }
    rbIsMoving(t) {
      return f.rawrigidbodyset_rbIsMoving(this.__wbg_ptr, t) !== 0;
    }
    rbNextTranslation(t) {
      const e = f.rawrigidbodyset_rbNextTranslation(this.__wbg_ptr, t);
      return N.__wrap(e);
    }
    rbNextRotation(t) {
      const e = f.rawrigidbodyset_rbNextRotation(this.__wbg_ptr, t);
      return Wt.__wrap(e);
    }
    rbSetTranslation(t, e, n, i, s) {
      f.rawrigidbodyset_rbSetTranslation(this.__wbg_ptr, t, e, n, i, s);
    }
    rbSetRotation(t, e, n, i, s, a) {
      f.rawrigidbodyset_rbSetRotation(this.__wbg_ptr, t, e, n, i, s, a);
    }
    rbSetLinvel(t, e, n) {
      C(e, N), f.rawrigidbodyset_rbSetLinvel(this.__wbg_ptr, t, e.__wbg_ptr, n);
    }
    rbSetAngvel(t, e, n) {
      C(e, N), f.rawrigidbodyset_rbSetAngvel(this.__wbg_ptr, t, e.__wbg_ptr, n);
    }
    rbSetNextKinematicTranslation(t, e, n, i) {
      f.rawrigidbodyset_rbSetNextKinematicTranslation(this.__wbg_ptr, t, e, n, i);
    }
    rbSetNextKinematicRotation(t, e, n, i, s) {
      f.rawrigidbodyset_rbSetNextKinematicRotation(this.__wbg_ptr, t, e, n, i, s);
    }
    rbRecomputeMassPropertiesFromColliders(t, e) {
      C(e, ve), f.rawrigidbodyset_rbRecomputeMassPropertiesFromColliders(this.__wbg_ptr, t, e.__wbg_ptr);
    }
    rbSetAdditionalMass(t, e, n) {
      f.rawrigidbodyset_rbSetAdditionalMass(this.__wbg_ptr, t, e, n);
    }
    rbSetAdditionalMassProperties(t, e, n, i, s, a) {
      C(n, N), C(i, N), C(s, Wt), f.rawrigidbodyset_rbSetAdditionalMassProperties(this.__wbg_ptr, t, e, n.__wbg_ptr, i.__wbg_ptr, s.__wbg_ptr, a);
    }
    rbLinvel(t) {
      const e = f.rawrigidbodyset_rbLinvel(this.__wbg_ptr, t);
      return N.__wrap(e);
    }
    rbAngvel(t) {
      const e = f.rawrigidbodyset_rbAngvel(this.__wbg_ptr, t);
      return N.__wrap(e);
    }
    rbVelocityAtPoint(t, e) {
      C(e, N);
      const n = f.rawrigidbodyset_rbVelocityAtPoint(this.__wbg_ptr, t, e.__wbg_ptr);
      return N.__wrap(n);
    }
    rbLockTranslations(t, e, n) {
      f.rawrigidbodyset_rbLockTranslations(this.__wbg_ptr, t, e, n);
    }
    rbSetEnabledTranslations(t, e, n, i, s) {
      f.rawrigidbodyset_rbSetEnabledTranslations(this.__wbg_ptr, t, e, n, i, s);
    }
    rbLockRotations(t, e, n) {
      f.rawrigidbodyset_rbLockRotations(this.__wbg_ptr, t, e, n);
    }
    rbSetEnabledRotations(t, e, n, i, s) {
      f.rawrigidbodyset_rbSetEnabledRotations(this.__wbg_ptr, t, e, n, i, s);
    }
    rbDominanceGroup(t) {
      return f.rawrigidbodyset_rbDominanceGroup(this.__wbg_ptr, t);
    }
    rbSetDominanceGroup(t, e) {
      f.rawrigidbodyset_rbSetDominanceGroup(this.__wbg_ptr, t, e);
    }
    rbEnableCcd(t, e) {
      f.rawrigidbodyset_rbEnableCcd(this.__wbg_ptr, t, e);
    }
    rbSetSoftCcdPrediction(t, e) {
      f.rawrigidbodyset_rbSetSoftCcdPrediction(this.__wbg_ptr, t, e);
    }
    rbMass(t) {
      return f.rawrigidbodyset_rbMass(this.__wbg_ptr, t);
    }
    rbInvMass(t) {
      return f.rawrigidbodyset_rbInvMass(this.__wbg_ptr, t);
    }
    rbEffectiveInvMass(t) {
      const e = f.rawrigidbodyset_rbEffectiveInvMass(this.__wbg_ptr, t);
      return N.__wrap(e);
    }
    rbLocalCom(t) {
      const e = f.rawrigidbodyset_rbLocalCom(this.__wbg_ptr, t);
      return N.__wrap(e);
    }
    rbWorldCom(t) {
      const e = f.rawrigidbodyset_rbWorldCom(this.__wbg_ptr, t);
      return N.__wrap(e);
    }
    rbInvPrincipalInertia(t) {
      const e = f.rawrigidbodyset_rbInvPrincipalInertia(this.__wbg_ptr, t);
      return N.__wrap(e);
    }
    rbPrincipalInertiaLocalFrame(t) {
      const e = f.rawrigidbodyset_rbPrincipalInertiaLocalFrame(this.__wbg_ptr, t);
      return Wt.__wrap(e);
    }
    rbPrincipalInertia(t) {
      const e = f.rawrigidbodyset_rbPrincipalInertia(this.__wbg_ptr, t);
      return N.__wrap(e);
    }
    rbEffectiveWorldInvInertia(t) {
      const e = f.rawrigidbodyset_rbEffectiveWorldInvInertia(this.__wbg_ptr, t);
      return Sa.__wrap(e);
    }
    rbEffectiveAngularInertia(t) {
      const e = f.rawrigidbodyset_rbEffectiveAngularInertia(this.__wbg_ptr, t);
      return Sa.__wrap(e);
    }
    rbWakeUp(t) {
      f.rawrigidbodyset_rbWakeUp(this.__wbg_ptr, t);
    }
    rbIsCcdEnabled(t) {
      return f.rawrigidbodyset_rbIsCcdEnabled(this.__wbg_ptr, t) !== 0;
    }
    rbSoftCcdPrediction(t) {
      return f.rawrigidbodyset_rbSoftCcdPrediction(this.__wbg_ptr, t);
    }
    rbNumColliders(t) {
      return f.rawrigidbodyset_rbNumColliders(this.__wbg_ptr, t) >>> 0;
    }
    rbCollider(t, e) {
      return f.rawrigidbodyset_rbCollider(this.__wbg_ptr, t, e);
    }
    rbBodyType(t) {
      return f.rawrigidbodyset_rbBodyType(this.__wbg_ptr, t);
    }
    rbSetBodyType(t, e, n) {
      f.rawrigidbodyset_rbSetBodyType(this.__wbg_ptr, t, e, n);
    }
    rbIsFixed(t) {
      return f.rawrigidbodyset_rbIsFixed(this.__wbg_ptr, t) !== 0;
    }
    rbIsKinematic(t) {
      return f.rawrigidbodyset_rbIsKinematic(this.__wbg_ptr, t) !== 0;
    }
    rbIsDynamic(t) {
      return f.rawrigidbodyset_rbIsDynamic(this.__wbg_ptr, t) !== 0;
    }
    rbLinearDamping(t) {
      return f.rawrigidbodyset_rbLinearDamping(this.__wbg_ptr, t);
    }
    rbAngularDamping(t) {
      return f.rawrigidbodyset_rbAngularDamping(this.__wbg_ptr, t);
    }
    rbSetLinearDamping(t, e) {
      f.rawrigidbodyset_rbSetLinearDamping(this.__wbg_ptr, t, e);
    }
    rbSetAngularDamping(t, e) {
      f.rawrigidbodyset_rbSetAngularDamping(this.__wbg_ptr, t, e);
    }
    rbSetEnabled(t, e) {
      f.rawrigidbodyset_rbSetEnabled(this.__wbg_ptr, t, e);
    }
    rbIsEnabled(t) {
      return f.rawrigidbodyset_rbIsEnabled(this.__wbg_ptr, t) !== 0;
    }
    rbGravityScale(t) {
      return f.rawrigidbodyset_rbGravityScale(this.__wbg_ptr, t);
    }
    rbSetGravityScale(t, e, n) {
      f.rawrigidbodyset_rbSetGravityScale(this.__wbg_ptr, t, e, n);
    }
    rbResetForces(t, e) {
      f.rawrigidbodyset_rbResetForces(this.__wbg_ptr, t, e);
    }
    rbResetTorques(t, e) {
      f.rawrigidbodyset_rbResetTorques(this.__wbg_ptr, t, e);
    }
    rbAddForce(t, e, n) {
      C(e, N), f.rawrigidbodyset_rbAddForce(this.__wbg_ptr, t, e.__wbg_ptr, n);
    }
    rbApplyImpulse(t, e, n) {
      C(e, N), f.rawrigidbodyset_rbApplyImpulse(this.__wbg_ptr, t, e.__wbg_ptr, n);
    }
    rbAddTorque(t, e, n) {
      C(e, N), f.rawrigidbodyset_rbAddTorque(this.__wbg_ptr, t, e.__wbg_ptr, n);
    }
    rbApplyTorqueImpulse(t, e, n) {
      C(e, N), f.rawrigidbodyset_rbApplyTorqueImpulse(this.__wbg_ptr, t, e.__wbg_ptr, n);
    }
    rbAddForceAtPoint(t, e, n, i) {
      C(e, N), C(n, N), f.rawrigidbodyset_rbAddForceAtPoint(this.__wbg_ptr, t, e.__wbg_ptr, n.__wbg_ptr, i);
    }
    rbApplyImpulseAtPoint(t, e, n, i) {
      C(e, N), C(n, N), f.rawrigidbodyset_rbApplyImpulseAtPoint(this.__wbg_ptr, t, e.__wbg_ptr, n.__wbg_ptr, i);
    }
    rbAdditionalSolverIterations(t) {
      return f.rawrigidbodyset_rbAdditionalSolverIterations(this.__wbg_ptr, t) >>> 0;
    }
    rbSetAdditionalSolverIterations(t, e) {
      f.rawrigidbodyset_rbSetAdditionalSolverIterations(this.__wbg_ptr, t, e);
    }
    rbUserData(t) {
      return f.rawrigidbodyset_rbUserData(this.__wbg_ptr, t) >>> 0;
    }
    rbSetUserData(t, e) {
      f.rawrigidbodyset_rbSetUserData(this.__wbg_ptr, t, e);
    }
    rbUserForce(t) {
      const e = f.rawrigidbodyset_rbUserForce(this.__wbg_ptr, t);
      return N.__wrap(e);
    }
    rbUserTorque(t) {
      const e = f.rawrigidbodyset_rbUserTorque(this.__wbg_ptr, t);
      return N.__wrap(e);
    }
    constructor() {
      const t = f.rawrigidbodyset_new();
      return this.__wbg_ptr = t >>> 0, hc.register(this, this.__wbg_ptr, this), this;
    }
    createRigidBody(t, e, n, i, s, a, o, c, l, h, d, u, p, w, b, m, _, E, v, T, O, R, P, z, A, S) {
      return C(e, N), C(n, Wt), C(o, N), C(c, N), C(l, N), C(h, N), C(d, Wt), f.rawrigidbodyset_createRigidBody(this.__wbg_ptr, t, e.__wbg_ptr, n.__wbg_ptr, i, s, a, o.__wbg_ptr, c.__wbg_ptr, l.__wbg_ptr, h.__wbg_ptr, d.__wbg_ptr, u, p, w, b, m, _, E, v, T, O, R, P, z, A, S);
    }
    remove(t, e, n, i, s) {
      C(e, ni), C(n, ve), C(i, ei), C(s, ii), f.rawrigidbodyset_remove(this.__wbg_ptr, t, e.__wbg_ptr, n.__wbg_ptr, i.__wbg_ptr, s.__wbg_ptr);
    }
    len() {
      return f.rawrigidbodyset_len(this.__wbg_ptr) >>> 0;
    }
    contains(t) {
      return f.rawrigidbodyset_contains(this.__wbg_ptr, t) !== 0;
    }
    forEachRigidBodyHandle(t) {
      try {
        f.rawrigidbodyset_forEachRigidBodyHandle(this.__wbg_ptr, ge(t));
      } finally {
        te[le++] = void 0;
      }
    }
    propagateModifiedBodyPositionsToColliders(t) {
      C(t, ve), f.rawrigidbodyset_propagateModifiedBodyPositionsToColliders(this.__wbg_ptr, t.__wbg_ptr);
    }
  }
  const dc = typeof FinalizationRegistry > "u" ? {
    register: () => {
    },
    unregister: () => {
    }
  } : new FinalizationRegistry((r) => f.__wbg_rawrotation_free(r >>> 0, 1));
  class Wt {
    static __wrap(t) {
      t = t >>> 0;
      const e = Object.create(Wt.prototype);
      return e.__wbg_ptr = t, dc.register(e, e.__wbg_ptr, e), e;
    }
    __destroy_into_raw() {
      const t = this.__wbg_ptr;
      return this.__wbg_ptr = 0, dc.unregister(this), t;
    }
    free() {
      const t = this.__destroy_into_raw();
      f.__wbg_rawrotation_free(t, 0);
    }
    constructor(t, e, n, i) {
      const s = f.rawrotation_new(t, e, n, i);
      return this.__wbg_ptr = s >>> 0, dc.register(this, this.__wbg_ptr, this), this;
    }
    static identity() {
      const t = f.rawrotation_identity();
      return Wt.__wrap(t);
    }
    get x() {
      return f.rawintegrationparameters_dt(this.__wbg_ptr);
    }
    get y() {
      return f.rawkinematiccharactercontroller_offset(this.__wbg_ptr);
    }
    get z() {
      return f.rawcollidershapecasthit_time_of_impact(this.__wbg_ptr);
    }
    get w() {
      return f.rawrotation_w(this.__wbg_ptr);
    }
  }
  const Wd = typeof FinalizationRegistry > "u" ? {
    register: () => {
    },
    unregister: () => {
    }
  } : new FinalizationRegistry((r) => f.__wbg_rawsdpmatrix3_free(r >>> 0, 1));
  class Sa {
    static __wrap(t) {
      t = t >>> 0;
      const e = Object.create(Sa.prototype);
      return e.__wbg_ptr = t, Wd.register(e, e.__wbg_ptr, e), e;
    }
    __destroy_into_raw() {
      const t = this.__wbg_ptr;
      return this.__wbg_ptr = 0, Wd.unregister(this), t;
    }
    free() {
      const t = this.__destroy_into_raw();
      f.__wbg_rawsdpmatrix3_free(t, 0);
    }
    elements() {
      const t = f.rawsdpmatrix3_elements(this.__wbg_ptr);
      return us(t);
    }
  }
  const jd = typeof FinalizationRegistry > "u" ? {
    register: () => {
    },
    unregister: () => {
    }
  } : new FinalizationRegistry((r) => f.__wbg_rawserializationpipeline_free(r >>> 0, 1));
  class jb {
    __destroy_into_raw() {
      const t = this.__wbg_ptr;
      return this.__wbg_ptr = 0, jd.unregister(this), t;
    }
    free() {
      const t = this.__destroy_into_raw();
      f.__wbg_rawserializationpipeline_free(t, 0);
    }
    constructor() {
      const t = f.rawccdsolver_new();
      return this.__wbg_ptr = t >>> 0, jd.register(this, this.__wbg_ptr, this), this;
    }
    serializeAll(t, e, n, i, s, a, o, c, l) {
      C(t, N), C(e, zi), C(n, ni), C(i, ti), C(s, De), C(a, pe), C(o, ve), C(c, ei), C(l, ii);
      const h = f.rawserializationpipeline_serializeAll(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr, n.__wbg_ptr, i.__wbg_ptr, s.__wbg_ptr, a.__wbg_ptr, o.__wbg_ptr, c.__wbg_ptr, l.__wbg_ptr);
      return us(h);
    }
    deserializeAll(t) {
      const e = f.rawserializationpipeline_deserializeAll(this.__wbg_ptr, he(t));
      return e === 0 ? void 0 : qc.__wrap(e);
    }
  }
  const Xd = typeof FinalizationRegistry > "u" ? {
    register: () => {
    },
    unregister: () => {
    }
  } : new FinalizationRegistry((r) => f.__wbg_rawshape_free(r >>> 0, 1));
  class xt {
    static __wrap(t) {
      t = t >>> 0;
      const e = Object.create(xt.prototype);
      return e.__wbg_ptr = t, Xd.register(e, e.__wbg_ptr, e), e;
    }
    __destroy_into_raw() {
      const t = this.__wbg_ptr;
      return this.__wbg_ptr = 0, Xd.unregister(this), t;
    }
    free() {
      const t = this.__destroy_into_raw();
      f.__wbg_rawshape_free(t, 0);
    }
    static cuboid(t, e, n) {
      const i = f.rawshape_cuboid(t, e, n);
      return xt.__wrap(i);
    }
    static roundCuboid(t, e, n, i) {
      const s = f.rawshape_roundCuboid(t, e, n, i);
      return xt.__wrap(s);
    }
    static ball(t) {
      const e = f.rawshape_ball(t);
      return xt.__wrap(e);
    }
    static halfspace(t) {
      C(t, N);
      const e = f.rawshape_halfspace(t.__wbg_ptr);
      return xt.__wrap(e);
    }
    static capsule(t, e) {
      const n = f.rawshape_capsule(t, e);
      return xt.__wrap(n);
    }
    static cylinder(t, e) {
      const n = f.rawshape_cylinder(t, e);
      return xt.__wrap(n);
    }
    static roundCylinder(t, e, n) {
      const i = f.rawshape_roundCylinder(t, e, n);
      return xt.__wrap(i);
    }
    static cone(t, e) {
      const n = f.rawshape_cone(t, e);
      return xt.__wrap(n);
    }
    static roundCone(t, e, n) {
      const i = f.rawshape_roundCone(t, e, n);
      return xt.__wrap(i);
    }
    static voxels(t, e) {
      C(t, N);
      const n = Jr(e, f.__wbindgen_export_2), i = Qe, s = f.rawshape_voxels(t.__wbg_ptr, n, i);
      return xt.__wrap(s);
    }
    static voxelsFromPoints(t, e) {
      C(t, N);
      const n = pi(e, f.__wbindgen_export_2), i = Qe, s = f.rawshape_voxelsFromPoints(t.__wbg_ptr, n, i);
      return xt.__wrap(s);
    }
    static polyline(t, e) {
      const n = pi(t, f.__wbindgen_export_2), i = Qe, s = Jr(e, f.__wbindgen_export_2), a = Qe, o = f.rawshape_polyline(n, i, s, a);
      return xt.__wrap(o);
    }
    static trimesh(t, e, n) {
      const i = pi(t, f.__wbindgen_export_2), s = Qe, a = Jr(e, f.__wbindgen_export_2), o = Qe, c = f.rawshape_trimesh(i, s, a, o, n);
      return c === 0 ? void 0 : xt.__wrap(c);
    }
    static heightfield(t, e, n, i, s) {
      const a = pi(n, f.__wbindgen_export_2), o = Qe;
      C(i, N);
      const c = f.rawshape_heightfield(t, e, a, o, i.__wbg_ptr, s);
      return xt.__wrap(c);
    }
    static segment(t, e) {
      C(t, N), C(e, N);
      const n = f.rawshape_segment(t.__wbg_ptr, e.__wbg_ptr);
      return xt.__wrap(n);
    }
    static triangle(t, e, n) {
      C(t, N), C(e, N), C(n, N);
      const i = f.rawshape_triangle(t.__wbg_ptr, e.__wbg_ptr, n.__wbg_ptr);
      return xt.__wrap(i);
    }
    static roundTriangle(t, e, n, i) {
      C(t, N), C(e, N), C(n, N);
      const s = f.rawshape_roundTriangle(t.__wbg_ptr, e.__wbg_ptr, n.__wbg_ptr, i);
      return xt.__wrap(s);
    }
    static convexHull(t) {
      const e = pi(t, f.__wbindgen_export_2), n = Qe, i = f.rawshape_convexHull(e, n);
      return i === 0 ? void 0 : xt.__wrap(i);
    }
    static roundConvexHull(t, e) {
      const n = pi(t, f.__wbindgen_export_2), i = Qe, s = f.rawshape_roundConvexHull(n, i, e);
      return s === 0 ? void 0 : xt.__wrap(s);
    }
    static convexMesh(t, e) {
      const n = pi(t, f.__wbindgen_export_2), i = Qe, s = Jr(e, f.__wbindgen_export_2), a = Qe, o = f.rawshape_convexMesh(n, i, s, a);
      return o === 0 ? void 0 : xt.__wrap(o);
    }
    static roundConvexMesh(t, e, n) {
      const i = pi(t, f.__wbindgen_export_2), s = Qe, a = Jr(e, f.__wbindgen_export_2), o = Qe, c = f.rawshape_roundConvexMesh(i, s, a, o, n);
      return c === 0 ? void 0 : xt.__wrap(c);
    }
    castShape(t, e, n, i, s, a, o, c, l, h) {
      C(t, N), C(e, Wt), C(n, N), C(i, xt), C(s, N), C(a, Wt), C(o, N);
      const d = f.rawshape_castShape(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr, n.__wbg_ptr, i.__wbg_ptr, s.__wbg_ptr, a.__wbg_ptr, o.__wbg_ptr, c, l, h);
      return d === 0 ? void 0 : Ya.__wrap(d);
    }
    intersectsShape(t, e, n, i, s) {
      return C(t, N), C(e, Wt), C(n, xt), C(i, N), C(s, Wt), f.rawshape_intersectsShape(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr, n.__wbg_ptr, i.__wbg_ptr, s.__wbg_ptr) !== 0;
    }
    contactShape(t, e, n, i, s, a) {
      C(t, N), C(e, Wt), C(n, xt), C(i, N), C(s, Wt);
      const o = f.rawshape_contactShape(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr, n.__wbg_ptr, i.__wbg_ptr, s.__wbg_ptr, a);
      return o === 0 ? void 0 : ps.__wrap(o);
    }
    containsPoint(t, e, n) {
      return C(t, N), C(e, Wt), C(n, N), f.rawshape_containsPoint(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr, n.__wbg_ptr) !== 0;
    }
    projectPoint(t, e, n, i) {
      C(t, N), C(e, Wt), C(n, N);
      const s = f.rawshape_projectPoint(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr, n.__wbg_ptr, i);
      return Xa.__wrap(s);
    }
    intersectsRay(t, e, n, i, s) {
      return C(t, N), C(e, Wt), C(n, N), C(i, N), f.rawshape_intersectsRay(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr, n.__wbg_ptr, i.__wbg_ptr, s) !== 0;
    }
    castRay(t, e, n, i, s, a) {
      return C(t, N), C(e, Wt), C(n, N), C(i, N), f.rawshape_castRay(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr, n.__wbg_ptr, i.__wbg_ptr, s, a);
    }
    castRayAndGetNormal(t, e, n, i, s, a) {
      C(t, N), C(e, Wt), C(n, N), C(i, N);
      const o = f.rawshape_castRayAndGetNormal(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr, n.__wbg_ptr, i.__wbg_ptr, s, a);
      return o === 0 ? void 0 : Ka.__wrap(o);
    }
  }
  const qd = typeof FinalizationRegistry > "u" ? {
    register: () => {
    },
    unregister: () => {
    }
  } : new FinalizationRegistry((r) => f.__wbg_rawshapecasthit_free(r >>> 0, 1));
  class Ya {
    static __wrap(t) {
      t = t >>> 0;
      const e = Object.create(Ya.prototype);
      return e.__wbg_ptr = t, qd.register(e, e.__wbg_ptr, e), e;
    }
    __destroy_into_raw() {
      const t = this.__wbg_ptr;
      return this.__wbg_ptr = 0, qd.unregister(this), t;
    }
    free() {
      const t = this.__destroy_into_raw();
      f.__wbg_rawshapecasthit_free(t, 0);
    }
    time_of_impact() {
      return f.rawintegrationparameters_dt(this.__wbg_ptr);
    }
    witness1() {
      const t = f.rawshapecasthit_witness1(this.__wbg_ptr);
      return N.__wrap(t);
    }
    witness2() {
      const t = f.rawcontactforceevent_total_force(this.__wbg_ptr);
      return N.__wrap(t);
    }
    normal1() {
      const t = f.rawshapecasthit_normal1(this.__wbg_ptr);
      return N.__wrap(t);
    }
    normal2() {
      const t = f.rawshapecasthit_normal2(this.__wbg_ptr);
      return N.__wrap(t);
    }
  }
  const Kd = typeof FinalizationRegistry > "u" ? {
    register: () => {
    },
    unregister: () => {
    }
  } : new FinalizationRegistry((r) => f.__wbg_rawshapecontact_free(r >>> 0, 1));
  class ps {
    static __wrap(t) {
      t = t >>> 0;
      const e = Object.create(ps.prototype);
      return e.__wbg_ptr = t, Kd.register(e, e.__wbg_ptr, e), e;
    }
    __destroy_into_raw() {
      const t = this.__wbg_ptr;
      return this.__wbg_ptr = 0, Kd.unregister(this), t;
    }
    free() {
      const t = this.__destroy_into_raw();
      f.__wbg_rawshapecontact_free(t, 0);
    }
    distance() {
      return f.rawkinematiccharactercontroller_maxSlopeClimbAngle(this.__wbg_ptr);
    }
    point1() {
      const t = f.rawpointprojection_point(this.__wbg_ptr);
      return N.__wrap(t);
    }
    point2() {
      const t = f.rawcollidershapecasthit_witness1(this.__wbg_ptr);
      return N.__wrap(t);
    }
    normal1() {
      const t = f.rawcollidershapecasthit_witness2(this.__wbg_ptr);
      return N.__wrap(t);
    }
    normal2() {
      const t = f.rawcharactercollision_translationDeltaApplied(this.__wbg_ptr);
      return N.__wrap(t);
    }
  }
  const uc = typeof FinalizationRegistry > "u" ? {
    register: () => {
    },
    unregister: () => {
    }
  } : new FinalizationRegistry((r) => f.__wbg_rawvector_free(r >>> 0, 1));
  class N {
    static __wrap(t) {
      t = t >>> 0;
      const e = Object.create(N.prototype);
      return e.__wbg_ptr = t, uc.register(e, e.__wbg_ptr, e), e;
    }
    __destroy_into_raw() {
      const t = this.__wbg_ptr;
      return this.__wbg_ptr = 0, uc.unregister(this), t;
    }
    free() {
      const t = this.__destroy_into_raw();
      f.__wbg_rawvector_free(t, 0);
    }
    static zero() {
      const t = f.rawvector_zero();
      return N.__wrap(t);
    }
    constructor(t, e, n) {
      const i = f.rawvector_new(t, e, n);
      return this.__wbg_ptr = i >>> 0, uc.register(this, this.__wbg_ptr, this), this;
    }
    get x() {
      return f.rawintegrationparameters_dt(this.__wbg_ptr);
    }
    set x(t) {
      f.rawintegrationparameters_set_dt(this.__wbg_ptr, t);
    }
    get y() {
      return f.rawkinematiccharactercontroller_offset(this.__wbg_ptr);
    }
    set y(t) {
      f.rawvector_set_y(this.__wbg_ptr, t);
    }
    get z() {
      return f.rawcollidershapecasthit_time_of_impact(this.__wbg_ptr);
    }
    set z(t) {
      f.rawvector_set_z(this.__wbg_ptr, t);
    }
    xyz() {
      const t = f.rawvector_xyz(this.__wbg_ptr);
      return N.__wrap(t);
    }
    yxz() {
      const t = f.rawvector_yxz(this.__wbg_ptr);
      return N.__wrap(t);
    }
    zxy() {
      const t = f.rawvector_zxy(this.__wbg_ptr);
      return N.__wrap(t);
    }
    xzy() {
      const t = f.rawvector_xzy(this.__wbg_ptr);
      return N.__wrap(t);
    }
    yzx() {
      const t = f.rawvector_yzx(this.__wbg_ptr);
      return N.__wrap(t);
    }
    zyx() {
      const t = f.rawvector_zyx(this.__wbg_ptr);
      return N.__wrap(t);
    }
  }
  function Xb(r, t, e, n) {
    const i = Jt(r).bind(Jt(t), Jt(e), Jt(n));
    return he(i);
  }
  function qb(r) {
    const t = Jt(r).buffer;
    return he(t);
  }
  function Kb() {
    return Va(function(r, t) {
      const e = Jt(r).call(Jt(t));
      return he(e);
    }, arguments);
  }
  function Yb() {
    return Va(function(r, t, e) {
      const n = Jt(r).call(Jt(t), Jt(e));
      return he(n);
    }, arguments);
  }
  function Zb() {
    return Va(function(r, t, e, n) {
      const i = Jt(r).call(Jt(t), Jt(e), Jt(n));
      return he(i);
    }, arguments);
  }
  function $b() {
    return Va(function(r, t, e, n, i) {
      const s = Jt(r).call(Jt(t), Jt(e), Jt(n), Jt(i));
      return he(s);
    }, arguments);
  }
  function Jb(r) {
    return Jt(r).length;
  }
  function Qb(r) {
    return Jt(r).length;
  }
  function ty(r) {
    const t = new Uint8Array(Jt(r));
    return he(t);
  }
  function ey(r, t) {
    const e = new Function(Vc(r, t));
    return he(e);
  }
  function ny(r, t, e) {
    const n = new Uint8Array(Jt(r), t >>> 0, e >>> 0);
    return he(n);
  }
  function iy(r, t, e) {
    const n = new Float32Array(Jt(r), t >>> 0, e >>> 0);
    return he(n);
  }
  function ry(r) {
    const t = new Float32Array(r >>> 0);
    return he(t);
  }
  function sy(r) {
    return Jt(r).now();
  }
  function ay(r) {
    const t = Jt(r).performance;
    return he(t);
  }
  function oy(r) {
    const t = Wc.__wrap(r);
    return he(t);
  }
  function cy(r) {
    const t = qa.__wrap(r);
    return he(t);
  }
  function ly(r, t, e) {
    Jt(r).set(Jt(t), e >>> 0);
  }
  function hy(r, t, e) {
    Jt(r).set(Jt(t), e >>> 0);
  }
  function dy() {
    const r = typeof global > "u" ? null : global;
    return Et(r) ? 0 : he(r);
  }
  function uy() {
    const r = typeof globalThis > "u" ? null : globalThis;
    return Et(r) ? 0 : he(r);
  }
  function py() {
    const r = typeof self > "u" ? null : self;
    return Et(r) ? 0 : he(r);
  }
  function fy() {
    const r = typeof window > "u" ? null : window;
    return Et(r) ? 0 : he(r);
  }
  function _y(r) {
    const t = Jt(r);
    return typeof t == "boolean" ? t ? 1 : 0 : 2;
  }
  function my(r) {
    return typeof Jt(r) == "function";
  }
  function gy(r) {
    return Jt(r) === void 0;
  }
  function wy() {
    const r = f.memory;
    return he(r);
  }
  function by(r, t) {
    const e = Jt(t), n = typeof e == "number" ? e : void 0;
    Le().setFloat64(r + 8, Et(n) ? 0 : n, true), Le().setInt32(r + 0, !Et(n), true);
  }
  function yy(r) {
    return he(r);
  }
  function vy(r) {
    const t = Jt(r);
    return he(t);
  }
  function xy(r) {
    us(r);
  }
  function Sy(r, t) {
    throw new Error(Vc(r, t));
  }
  URL = globalThis.URL;
  const g = await Pb({
    "./rapier_wasm3d_bg.js": {
      __wbindgen_number_new: yy,
      __wbindgen_boolean_get: _y,
      __wbindgen_object_drop_ref: xy,
      __wbindgen_number_get: by,
      __wbindgen_is_function: my,
      __wbg_rawraycolliderintersection_new: cy,
      __wbg_rawcontactforceevent_new: oy,
      __wbg_performance_7a3ffd0b17f663ad: ay,
      __wbindgen_is_undefined: gy,
      __wbg_now_2c95c9de01293173: sy,
      __wbindgen_object_clone_ref: vy,
      __wbg_newnoargs_105ed471475aaf50: ey,
      __wbg_call_672a4d21634d4a24: Kb,
      __wbg_call_7cccdd69e0791ae2: Yb,
      __wbg_call_833bed5770ea2041: Zb,
      __wbg_call_b8adc8b1d0a0d8eb: $b,
      __wbg_bind_c8359b1cba058168: Xb,
      __wbg_buffer_609cc3eee51ed158: qb,
      __wbg_static_accessor_GLOBAL_THIS_56578be7e9f832b0: uy,
      __wbg_static_accessor_SELF_37c5d418e4bf5819: py,
      __wbg_static_accessor_WINDOW_5de37043a91a9c40: fy,
      __wbg_static_accessor_GLOBAL_88a902d13a557d07: dy,
      __wbg_newwithbyteoffsetandlength_d97e637ebe145a9a: ny,
      __wbg_new_a12002a7f91c75be: ty,
      __wbg_set_65595bdd868b3009: hy,
      __wbg_length_a446193dc22c12f8: Qb,
      __wbg_newwithbyteoffsetandlength_e6b7e69acd4c7354: iy,
      __wbg_set_10bad9bee0e9c58b: ly,
      __wbg_length_3b4f022188ae8db6: Jb,
      __wbg_newwithlength_5a5efe313cfd59f1: ry,
      __wbindgen_throw: Sy,
      __wbindgen_memory: wy
    }
  }, Cb), My = g.memory, Ey = g.version, Ty = g.__wbg_rawkinematiccharactercontroller_free, Ay = g.rawkinematiccharactercontroller_new, Ry = g.rawkinematiccharactercontroller_setUp, Cy = g.rawkinematiccharactercontroller_normalNudgeFactor, Py = g.rawkinematiccharactercontroller_setNormalNudgeFactor, Iy = g.rawkinematiccharactercontroller_offset, Ly = g.rawkinematiccharactercontroller_setOffset, Dy = g.rawkinematiccharactercontroller_slideEnabled, Ny = g.rawkinematiccharactercontroller_setSlideEnabled, Uy = g.rawkinematiccharactercontroller_autostepMaxHeight, Fy = g.rawkinematiccharactercontroller_autostepMinWidth, Oy = g.rawkinematiccharactercontroller_autostepIncludesDynamicBodies, By = g.rawkinematiccharactercontroller_autostepEnabled, zy = g.rawkinematiccharactercontroller_enableAutostep, ky = g.rawkinematiccharactercontroller_disableAutostep, Hy = g.rawkinematiccharactercontroller_maxSlopeClimbAngle, Gy = g.rawkinematiccharactercontroller_setMaxSlopeClimbAngle, Vy = g.rawkinematiccharactercontroller_minSlopeSlideAngle, Wy = g.rawkinematiccharactercontroller_setMinSlopeSlideAngle, jy = g.rawkinematiccharactercontroller_snapToGroundDistance, Xy = g.rawkinematiccharactercontroller_enableSnapToGround, qy = g.rawkinematiccharactercontroller_disableSnapToGround, Ky = g.rawkinematiccharactercontroller_snapToGroundEnabled, Yy = g.rawkinematiccharactercontroller_computeColliderMovement, Zy = g.rawkinematiccharactercontroller_computedMovement, $y = g.rawkinematiccharactercontroller_computedGrounded, Jy = g.rawkinematiccharactercontroller_numComputedCollisions, Qy = g.rawkinematiccharactercontroller_computedCollision, tv = g.__wbg_rawcharactercollision_free, ev = g.rawcharactercollision_new, nv = g.rawcharactercollision_handle, iv = g.rawcharactercollision_translationDeltaApplied, rv = g.rawcharactercollision_translationDeltaRemaining, sv = g.rawcharactercollision_toi, av = g.rawcharactercollision_worldWitness1, ov = g.rawcharactercollision_worldWitness2, cv = g.rawcharactercollision_worldNormal1, lv = g.rawcharactercollision_worldNormal2, hv = g.__wbg_rawpidcontroller_free, dv = g.rawpidcontroller_new, uv = g.rawpidcontroller_set_kp, pv = g.rawpidcontroller_set_ki, fv = g.rawpidcontroller_set_kd, _v = g.rawpidcontroller_set_axes_mask, mv = g.rawpidcontroller_reset_integrals, gv = g.rawpidcontroller_apply_linear_correction, wv = g.rawpidcontroller_apply_angular_correction, bv = g.rawpidcontroller_linear_correction, yv = g.rawpidcontroller_angular_correction, vv = g.__wbg_rawdynamicraycastvehiclecontroller_free, xv = g.rawdynamicraycastvehiclecontroller_new, Sv = g.rawdynamicraycastvehiclecontroller_current_vehicle_speed, Mv = g.rawdynamicraycastvehiclecontroller_chassis, Ev = g.rawdynamicraycastvehiclecontroller_index_up_axis, Tv = g.rawdynamicraycastvehiclecontroller_set_index_up_axis, Av = g.rawdynamicraycastvehiclecontroller_index_forward_axis, Rv = g.rawdynamicraycastvehiclecontroller_set_index_forward_axis, Cv = g.rawdynamicraycastvehiclecontroller_add_wheel, Pv = g.rawdynamicraycastvehiclecontroller_num_wheels, Iv = g.rawdynamicraycastvehiclecontroller_update_vehicle, Lv = g.rawdynamicraycastvehiclecontroller_wheel_chassis_connection_point_cs, Dv = g.rawdynamicraycastvehiclecontroller_set_wheel_chassis_connection_point_cs, Nv = g.rawdynamicraycastvehiclecontroller_wheel_suspension_rest_length, Uv = g.rawdynamicraycastvehiclecontroller_set_wheel_suspension_rest_length, Fv = g.rawdynamicraycastvehiclecontroller_wheel_max_suspension_travel, Ov = g.rawdynamicraycastvehiclecontroller_set_wheel_max_suspension_travel, Bv = g.rawdynamicraycastvehiclecontroller_wheel_radius, zv = g.rawdynamicraycastvehiclecontroller_set_wheel_radius, kv = g.rawdynamicraycastvehiclecontroller_wheel_suspension_stiffness, Hv = g.rawdynamicraycastvehiclecontroller_set_wheel_suspension_stiffness, Gv = g.rawdynamicraycastvehiclecontroller_wheel_suspension_compression, Vv = g.rawdynamicraycastvehiclecontroller_set_wheel_suspension_compression, Wv = g.rawdynamicraycastvehiclecontroller_wheel_suspension_relaxation, jv = g.rawdynamicraycastvehiclecontroller_set_wheel_suspension_relaxation, Xv = g.rawdynamicraycastvehiclecontroller_wheel_max_suspension_force, qv = g.rawdynamicraycastvehiclecontroller_set_wheel_max_suspension_force, Kv = g.rawdynamicraycastvehiclecontroller_wheel_brake, Yv = g.rawdynamicraycastvehiclecontroller_set_wheel_brake, Zv = g.rawdynamicraycastvehiclecontroller_wheel_steering, $v = g.rawdynamicraycastvehiclecontroller_set_wheel_steering, Jv = g.rawdynamicraycastvehiclecontroller_wheel_engine_force, Qv = g.rawdynamicraycastvehiclecontroller_set_wheel_engine_force, tx = g.rawdynamicraycastvehiclecontroller_wheel_direction_cs, ex = g.rawdynamicraycastvehiclecontroller_set_wheel_direction_cs, nx = g.rawdynamicraycastvehiclecontroller_wheel_axle_cs, ix = g.rawdynamicraycastvehiclecontroller_set_wheel_axle_cs, rx = g.rawdynamicraycastvehiclecontroller_wheel_friction_slip, sx = g.rawdynamicraycastvehiclecontroller_set_wheel_friction_slip, ax = g.rawdynamicraycastvehiclecontroller_wheel_side_friction_stiffness, ox = g.rawdynamicraycastvehiclecontroller_set_wheel_side_friction_stiffness, cx = g.rawdynamicraycastvehiclecontroller_wheel_rotation, lx = g.rawdynamicraycastvehiclecontroller_wheel_forward_impulse, hx = g.rawdynamicraycastvehiclecontroller_wheel_side_impulse, dx = g.rawdynamicraycastvehiclecontroller_wheel_suspension_force, ux = g.rawdynamicraycastvehiclecontroller_wheel_contact_normal_ws, px = g.rawdynamicraycastvehiclecontroller_wheel_contact_point_ws, fx = g.rawdynamicraycastvehiclecontroller_wheel_suspension_length, _x = g.rawdynamicraycastvehiclecontroller_wheel_hard_point_ws, mx = g.rawdynamicraycastvehiclecontroller_wheel_is_in_contact, gx = g.rawdynamicraycastvehiclecontroller_wheel_ground_object, wx = g.__wbg_rawccdsolver_free, bx = g.rawimpulsejointset_jointType, yx = g.rawimpulsejointset_jointBodyHandle1, vx = g.rawimpulsejointset_jointBodyHandle2, xx = g.rawimpulsejointset_jointFrameX1, Sx = g.rawimpulsejointset_jointFrameX2, Mx = g.rawimpulsejointset_jointAnchor1, Ex = g.rawimpulsejointset_jointAnchor2, Tx = g.rawimpulsejointset_jointSetAnchor1, Ax = g.rawimpulsejointset_jointSetAnchor2, Rx = g.rawimpulsejointset_jointContactsEnabled, Cx = g.rawimpulsejointset_jointSetContactsEnabled, Px = g.rawimpulsejointset_jointLimitsEnabled, Ix = g.rawimpulsejointset_jointLimitsMin, Lx = g.rawimpulsejointset_jointLimitsMax, Dx = g.rawimpulsejointset_jointSetLimits, Nx = g.rawimpulsejointset_jointConfigureMotorModel, Ux = g.rawimpulsejointset_jointConfigureMotorVelocity, Fx = g.rawimpulsejointset_jointConfigureMotorPosition, Ox = g.rawimpulsejointset_jointConfigureMotor, Bx = g.__wbg_rawimpulsejointset_free, zx = g.rawimpulsejointset_new, kx = g.rawimpulsejointset_createJoint, Hx = g.rawimpulsejointset_remove, Gx = g.rawimpulsejointset_len, Vx = g.rawimpulsejointset_contains, Wx = g.rawimpulsejointset_forEachJointHandle, jx = g.rawimpulsejointset_forEachJointAttachedToRigidBody, Xx = g.__wbg_rawintegrationparameters_free, qx = g.rawintegrationparameters_new, Kx = g.rawintegrationparameters_dt, Yx = g.rawintegrationparameters_contact_erp, Zx = g.rawintegrationparameters_normalizedAllowedLinearError, $x = g.rawintegrationparameters_normalizedPredictionDistance, Jx = g.rawintegrationparameters_numSolverIterations, Qx = g.rawintegrationparameters_minIslandSize, tS = g.rawintegrationparameters_maxCcdSubsteps, eS = g.rawintegrationparameters_set_dt, nS = g.rawintegrationparameters_set_contact_natural_frequency, iS = g.rawintegrationparameters_set_normalizedAllowedLinearError, rS = g.rawintegrationparameters_set_normalizedPredictionDistance, sS = g.rawintegrationparameters_set_numSolverIterations, aS = g.rawintegrationparameters_set_minIslandSize, oS = g.rawintegrationparameters_set_maxCcdSubsteps, cS = g.rawintegrationparameters_set_lengthUnit, lS = g.__wbg_rawislandmanager_free, hS = g.rawislandmanager_new, dS = g.rawislandmanager_forEachActiveRigidBodyHandle, uS = g.__wbg_rawgenericjoint_free, pS = g.rawgenericjoint_generic, fS = g.rawgenericjoint_spring, _S = g.rawgenericjoint_rope, mS = g.rawgenericjoint_spherical, gS = g.rawgenericjoint_prismatic, wS = g.rawgenericjoint_fixed, bS = g.rawgenericjoint_revolute, yS = g.rawmultibodyjointset_jointType, vS = g.rawmultibodyjointset_jointFrameX1, xS = g.rawmultibodyjointset_jointFrameX2, SS = g.rawmultibodyjointset_jointAnchor1, MS = g.rawmultibodyjointset_jointAnchor2, ES = g.rawmultibodyjointset_jointContactsEnabled, TS = g.rawmultibodyjointset_jointSetContactsEnabled, AS = g.rawmultibodyjointset_jointLimitsEnabled, RS = g.rawmultibodyjointset_jointLimitsMin, CS = g.rawmultibodyjointset_jointLimitsMax, PS = g.__wbg_rawmultibodyjointset_free, IS = g.rawmultibodyjointset_new, LS = g.rawmultibodyjointset_createJoint, DS = g.rawmultibodyjointset_remove, NS = g.rawmultibodyjointset_contains, US = g.rawmultibodyjointset_forEachJointHandle, FS = g.rawmultibodyjointset_forEachJointAttachedToRigidBody, OS = g.rawrigidbodyset_rbTranslation, BS = g.rawrigidbodyset_rbRotation, zS = g.rawrigidbodyset_rbSleep, kS = g.rawrigidbodyset_rbIsSleeping, HS = g.rawrigidbodyset_rbIsMoving, GS = g.rawrigidbodyset_rbNextTranslation, VS = g.rawrigidbodyset_rbNextRotation, WS = g.rawrigidbodyset_rbSetTranslation, jS = g.rawrigidbodyset_rbSetRotation, XS = g.rawrigidbodyset_rbSetLinvel, qS = g.rawrigidbodyset_rbSetAngvel, KS = g.rawrigidbodyset_rbSetNextKinematicTranslation, YS = g.rawrigidbodyset_rbSetNextKinematicRotation, ZS = g.rawrigidbodyset_rbRecomputeMassPropertiesFromColliders, $S = g.rawrigidbodyset_rbSetAdditionalMass, JS = g.rawrigidbodyset_rbSetAdditionalMassProperties, QS = g.rawrigidbodyset_rbLinvel, tM = g.rawrigidbodyset_rbAngvel, eM = g.rawrigidbodyset_rbVelocityAtPoint, nM = g.rawrigidbodyset_rbLockTranslations, iM = g.rawrigidbodyset_rbSetEnabledTranslations, rM = g.rawrigidbodyset_rbLockRotations, sM = g.rawrigidbodyset_rbSetEnabledRotations, aM = g.rawrigidbodyset_rbDominanceGroup, oM = g.rawrigidbodyset_rbSetDominanceGroup, cM = g.rawrigidbodyset_rbEnableCcd, lM = g.rawrigidbodyset_rbSetSoftCcdPrediction, hM = g.rawrigidbodyset_rbMass, dM = g.rawrigidbodyset_rbInvMass, uM = g.rawrigidbodyset_rbEffectiveInvMass, pM = g.rawrigidbodyset_rbLocalCom, fM = g.rawrigidbodyset_rbWorldCom, _M = g.rawrigidbodyset_rbInvPrincipalInertia, mM = g.rawrigidbodyset_rbPrincipalInertiaLocalFrame, gM = g.rawrigidbodyset_rbPrincipalInertia, wM = g.rawrigidbodyset_rbEffectiveWorldInvInertia, bM = g.rawrigidbodyset_rbEffectiveAngularInertia, yM = g.rawrigidbodyset_rbWakeUp, vM = g.rawrigidbodyset_rbIsCcdEnabled, xM = g.rawrigidbodyset_rbSoftCcdPrediction, SM = g.rawrigidbodyset_rbNumColliders, MM = g.rawrigidbodyset_rbCollider, EM = g.rawrigidbodyset_rbBodyType, TM = g.rawrigidbodyset_rbSetBodyType, AM = g.rawrigidbodyset_rbIsFixed, RM = g.rawrigidbodyset_rbIsKinematic, CM = g.rawrigidbodyset_rbIsDynamic, PM = g.rawrigidbodyset_rbLinearDamping, IM = g.rawrigidbodyset_rbAngularDamping, LM = g.rawrigidbodyset_rbSetLinearDamping, DM = g.rawrigidbodyset_rbSetAngularDamping, NM = g.rawrigidbodyset_rbSetEnabled, UM = g.rawrigidbodyset_rbIsEnabled, FM = g.rawrigidbodyset_rbGravityScale, OM = g.rawrigidbodyset_rbSetGravityScale, BM = g.rawrigidbodyset_rbResetForces, zM = g.rawrigidbodyset_rbResetTorques, kM = g.rawrigidbodyset_rbAddForce, HM = g.rawrigidbodyset_rbApplyImpulse, GM = g.rawrigidbodyset_rbAddTorque, VM = g.rawrigidbodyset_rbApplyTorqueImpulse, WM = g.rawrigidbodyset_rbAddForceAtPoint, jM = g.rawrigidbodyset_rbApplyImpulseAtPoint, XM = g.rawrigidbodyset_rbAdditionalSolverIterations, qM = g.rawrigidbodyset_rbSetAdditionalSolverIterations, KM = g.rawrigidbodyset_rbUserData, YM = g.rawrigidbodyset_rbSetUserData, ZM = g.rawrigidbodyset_rbUserForce, $M = g.rawrigidbodyset_rbUserTorque, JM = g.__wbg_rawrigidbodyset_free, QM = g.rawrigidbodyset_new, tE = g.rawrigidbodyset_createRigidBody, eE = g.rawrigidbodyset_remove, nE = g.rawrigidbodyset_len, iE = g.rawrigidbodyset_contains, rE = g.rawrigidbodyset_forEachRigidBodyHandle, sE = g.rawrigidbodyset_propagateModifiedBodyPositionsToColliders, aE = g.__wbg_rawbroadphase_free, oE = g.rawbroadphase_new, cE = g.rawbroadphase_castRay, lE = g.rawbroadphase_castRayAndGetNormal, hE = g.rawbroadphase_intersectionsWithRay, dE = g.rawbroadphase_intersectionWithShape, uE = g.rawbroadphase_projectPoint, pE = g.rawbroadphase_projectPointAndGetFeature, fE = g.rawbroadphase_intersectionsWithPoint, _E = g.rawbroadphase_castShape, mE = g.rawbroadphase_intersectionsWithShape, gE = g.rawbroadphase_collidersWithAabbIntersectingAabb, wE = g.rawcolliderset_coTranslation, bE = g.rawcolliderset_coRotation, yE = g.rawcolliderset_coTranslationWrtParent, vE = g.rawcolliderset_coRotationWrtParent, xE = g.rawcolliderset_coSetTranslation, SE = g.rawcolliderset_coSetTranslationWrtParent, ME = g.rawcolliderset_coSetRotation, EE = g.rawcolliderset_coSetRotationWrtParent, TE = g.rawcolliderset_coIsSensor, AE = g.rawcolliderset_coShapeType, RE = g.rawcolliderset_coHalfspaceNormal, CE = g.rawcolliderset_coHalfExtents, PE = g.rawcolliderset_coSetHalfExtents, IE = g.rawcolliderset_coRadius, LE = g.rawcolliderset_coSetRadius, DE = g.rawcolliderset_coHalfHeight, NE = g.rawcolliderset_coSetHalfHeight, UE = g.rawcolliderset_coRoundRadius, FE = g.rawcolliderset_coSetRoundRadius, OE = g.rawcolliderset_coVoxelData, BE = g.rawcolliderset_coVoxelSize, zE = g.rawcolliderset_coSetVoxel, kE = g.rawcolliderset_coPropagateVoxelChange, HE = g.rawcolliderset_coCombineVoxelStates, GE = g.rawcolliderset_coVertices, VE = g.rawcolliderset_coIndices, WE = g.rawcolliderset_coTriMeshFlags, jE = g.rawcolliderset_coHeightFieldFlags, XE = g.rawcolliderset_coHeightfieldHeights, qE = g.rawcolliderset_coHeightfieldScale, KE = g.rawcolliderset_coHeightfieldNRows, YE = g.rawcolliderset_coHeightfieldNCols, ZE = g.rawcolliderset_coParent, $E = g.rawcolliderset_coSetEnabled, JE = g.rawcolliderset_coIsEnabled, QE = g.rawcolliderset_coSetContactSkin, tT = g.rawcolliderset_coContactSkin, eT = g.rawcolliderset_coFriction, nT = g.rawcolliderset_coRestitution, iT = g.rawcolliderset_coDensity, rT = g.rawcolliderset_coMass, sT = g.rawcolliderset_coVolume, aT = g.rawcolliderset_coCollisionGroups, oT = g.rawcolliderset_coSolverGroups, cT = g.rawcolliderset_coActiveHooks, lT = g.rawcolliderset_coActiveCollisionTypes, hT = g.rawcolliderset_coActiveEvents, dT = g.rawcolliderset_coContactForceEventThreshold, uT = g.rawcolliderset_coContainsPoint, pT = g.rawcolliderset_coCastShape, fT = g.rawcolliderset_coCastCollider, _T = g.rawcolliderset_coIntersectsShape, mT = g.rawcolliderset_coContactShape, gT = g.rawcolliderset_coContactCollider, wT = g.rawcolliderset_coProjectPoint, bT = g.rawcolliderset_coIntersectsRay, yT = g.rawcolliderset_coCastRay, vT = g.rawcolliderset_coCastRayAndGetNormal, xT = g.rawcolliderset_coSetSensor, ST = g.rawcolliderset_coSetRestitution, MT = g.rawcolliderset_coSetFriction, ET = g.rawcolliderset_coFrictionCombineRule, TT = g.rawcolliderset_coSetFrictionCombineRule, AT = g.rawcolliderset_coRestitutionCombineRule, RT = g.rawcolliderset_coSetRestitutionCombineRule, CT = g.rawcolliderset_coSetCollisionGroups, PT = g.rawcolliderset_coSetSolverGroups, IT = g.rawcolliderset_coSetActiveHooks, LT = g.rawcolliderset_coSetActiveEvents, DT = g.rawcolliderset_coSetActiveCollisionTypes, NT = g.rawcolliderset_coSetShape, UT = g.rawcolliderset_coSetContactForceEventThreshold, FT = g.rawcolliderset_coSetDensity, OT = g.rawcolliderset_coSetMass, BT = g.rawcolliderset_coSetMassProperties, zT = g.__wbg_rawcolliderset_free, kT = g.rawcolliderset_new, HT = g.rawcolliderset_len, GT = g.rawcolliderset_contains, VT = g.rawcolliderset_createCollider, WT = g.rawcolliderset_remove, jT = g.rawcolliderset_forEachColliderHandle, XT = g.__wbg_rawshapecontact_free, qT = g.__wbg_rawnarrowphase_free, KT = g.rawnarrowphase_new, YT = g.rawnarrowphase_contact_pairs_with, ZT = g.rawnarrowphase_contact_pair, $T = g.rawnarrowphase_intersection_pairs_with, JT = g.rawnarrowphase_intersection_pair, QT = g.__wbg_rawcontactmanifold_free, tA = g.rawcontactpair_collider1, eA = g.rawcontactpair_collider2, nA = g.rawcontactpair_numContactManifolds, iA = g.rawcontactpair_contactManifold, rA = g.rawcontactmanifold_normal, sA = g.rawcontactmanifold_local_n1, aA = g.rawcontactmanifold_local_n2, oA = g.rawcontactmanifold_subshape1, cA = g.rawcontactmanifold_subshape2, lA = g.rawcontactmanifold_num_contacts, hA = g.rawcontactmanifold_contact_local_p1, dA = g.rawcontactmanifold_contact_local_p2, uA = g.rawcontactmanifold_contact_dist, pA = g.rawcontactmanifold_contact_fid1, fA = g.rawcontactmanifold_contact_fid2, _A = g.rawcontactmanifold_contact_impulse, mA = g.rawcontactmanifold_contact_tangent_impulse_x, gA = g.rawcontactmanifold_contact_tangent_impulse_y, wA = g.rawcontactmanifold_num_solver_contacts, bA = g.rawcontactmanifold_solver_contact_point, yA = g.rawcontactmanifold_solver_contact_dist, vA = g.rawcontactmanifold_solver_contact_friction, xA = g.rawcontactmanifold_solver_contact_restitution, SA = g.rawcontactmanifold_solver_contact_tangent_velocity, MA = g.__wbg_rawpointprojection_free, EA = g.rawpointprojection_point, TA = g.rawpointprojection_isInside, AA = g.__wbg_rawpointcolliderprojection_free, RA = g.rawpointcolliderprojection_colliderHandle, CA = g.rawpointcolliderprojection_point, PA = g.rawpointcolliderprojection_isInside, IA = g.rawpointcolliderprojection_featureType, LA = g.rawpointcolliderprojection_featureId, DA = g.__wbg_rawrayintersection_free, NA = g.__wbg_rawraycolliderhit_free, UA = g.__wbg_rawshape_free, FA = g.rawshape_cuboid, OA = g.rawshape_roundCuboid, BA = g.rawshape_ball, zA = g.rawshape_halfspace, kA = g.rawshape_capsule, HA = g.rawshape_cylinder, GA = g.rawshape_roundCylinder, VA = g.rawshape_cone, WA = g.rawshape_roundCone, jA = g.rawshape_voxels, XA = g.rawshape_voxelsFromPoints, qA = g.rawshape_polyline, KA = g.rawshape_trimesh, YA = g.rawshape_heightfield, ZA = g.rawshape_segment, $A = g.rawshape_triangle, JA = g.rawshape_roundTriangle, QA = g.rawshape_convexHull, tR = g.rawshape_roundConvexHull, eR = g.rawshape_convexMesh, nR = g.rawshape_roundConvexMesh, iR = g.rawshape_castShape, rR = g.rawshape_intersectsShape, sR = g.rawshape_contactShape, aR = g.rawshape_containsPoint, oR = g.rawshape_projectPoint, cR = g.rawshape_intersectsRay, lR = g.rawshape_castRay, hR = g.rawshape_castRayAndGetNormal, dR = g.__wbg_rawshapecasthit_free, uR = g.rawshapecasthit_witness1, pR = g.rawshapecasthit_normal1, fR = g.rawshapecasthit_normal2, _R = g.__wbg_rawcollidershapecasthit_free, mR = g.rawcollidershapecasthit_time_of_impact, gR = g.rawcollidershapecasthit_witness1, wR = g.rawcollidershapecasthit_witness2, bR = g.rawrotation_new, yR = g.rawrotation_identity, vR = g.rawrotation_w, xR = g.rawvector_zero, SR = g.rawvector_new, MR = g.rawvector_set_y, ER = g.rawvector_set_z, TR = g.rawvector_xyz, AR = g.rawvector_yxz, RR = g.rawvector_zxy, CR = g.rawvector_xzy, PR = g.rawvector_yzx, IR = g.rawvector_zyx, LR = g.rawsdpmatrix3_elements, DR = g.__wbg_rawdebugrenderpipeline_free, NR = g.rawdebugrenderpipeline_new, UR = g.rawdebugrenderpipeline_vertices, FR = g.rawdebugrenderpipeline_colors, OR = g.rawdebugrenderpipeline_render, BR = g.__wbg_raweventqueue_free, zR = g.__wbg_rawcontactforceevent_free, kR = g.rawcontactforceevent_collider2, HR = g.rawcontactforceevent_total_force, GR = g.rawcontactforceevent_total_force_magnitude, VR = g.rawcontactforceevent_max_force_direction, WR = g.rawcontactforceevent_max_force_magnitude, jR = g.raweventqueue_new, XR = g.raweventqueue_drainCollisionEvents, qR = g.raweventqueue_drainContactForceEvents, KR = g.raweventqueue_clear, YR = g.__wbg_rawphysicspipeline_free, ZR = g.rawphysicspipeline_new, $R = g.rawphysicspipeline_set_profiler_enabled, JR = g.rawphysicspipeline_is_profiler_enabled, QR = g.rawphysicspipeline_timing_step, tC = g.rawphysicspipeline_timing_collision_detection, eC = g.rawphysicspipeline_timing_broad_phase, nC = g.rawphysicspipeline_timing_narrow_phase, iC = g.rawphysicspipeline_timing_solver, rC = g.rawphysicspipeline_timing_velocity_assembly, sC = g.rawphysicspipeline_timing_velocity_resolution, aC = g.rawphysicspipeline_timing_velocity_update, oC = g.rawphysicspipeline_timing_velocity_writeback, cC = g.rawphysicspipeline_timing_ccd, lC = g.rawphysicspipeline_timing_ccd_toi_computation, hC = g.rawphysicspipeline_timing_ccd_broad_phase, dC = g.rawphysicspipeline_timing_ccd_narrow_phase, uC = g.rawphysicspipeline_timing_ccd_solver, pC = g.rawphysicspipeline_timing_island_construction, fC = g.rawphysicspipeline_timing_user_changes, _C = g.rawphysicspipeline_step, mC = g.rawphysicspipeline_stepWithEvents, gC = g.__wbg_rawdeserializedworld_free, wC = g.rawdeserializedworld_takeGravity, bC = g.rawdeserializedworld_takeIntegrationParameters, yC = g.rawdeserializedworld_takeIslandManager, vC = g.rawdeserializedworld_takeBroadPhase, xC = g.rawdeserializedworld_takeNarrowPhase, SC = g.rawdeserializedworld_takeBodies, MC = g.rawdeserializedworld_takeColliders, EC = g.rawdeserializedworld_takeImpulseJoints, TC = g.rawdeserializedworld_takeMultibodyJoints, AC = g.rawserializationpipeline_serializeAll, RC = g.rawserializationpipeline_deserializeAll, CC = g.rawcolliderset_isHandleValid, PC = g.rawrayintersection_featureId, IC = g.rawraycolliderintersection_featureId, LC = g.rawintegrationparameters_set_numInternalPgsIterations, DC = g.rawvector_set_x, NC = g.reserve_memory, UC = g.rawkinematiccharactercontroller_up, FC = g.rawshapecontact_normal2, OC = g.rawshapecontact_point1, BC = g.rawshapecontact_point2, zC = g.rawrayintersection_normal, kC = g.rawraycolliderintersection_normal, HC = g.rawshapecontact_normal1, GC = g.rawcollidershapecasthit_normal1, VC = g.rawcollidershapecasthit_normal2, WC = g.rawshapecasthit_witness2, jC = g.rawintegrationparameters_numInternalPgsIterations, XC = g.rawshapecontact_distance, qC = g.rawrayintersection_featureType, KC = g.rawraycolliderintersection_colliderHandle, YC = g.rawrayintersection_time_of_impact, ZC = g.rawraycolliderintersection_featureType, $C = g.rawraycolliderhit_colliderHandle, JC = g.rawraycolliderintersection_time_of_impact, QC = g.rawshapecasthit_time_of_impact, t1 = g.rawcollidershapecasthit_colliderHandle, e1 = g.rawraycolliderhit_timeOfImpact, n1 = g.rawrotation_x, i1 = g.rawrotation_y, r1 = g.rawrotation_z, s1 = g.rawvector_x, a1 = g.rawvector_y, o1 = g.rawvector_z, c1 = g.rawcontactforceevent_collider1, l1 = g.rawintegrationparameters_lengthUnit, h1 = g.__wbg_rawcontactpair_free, d1 = g.__wbg_rawraycolliderintersection_free, u1 = g.__wbg_rawrotation_free, p1 = g.__wbg_rawvector_free, f1 = g.__wbg_rawsdpmatrix3_free, _1 = g.__wbg_rawserializationpipeline_free, m1 = g.rawccdsolver_new, g1 = g.rawserializationpipeline_new, w1 = g.__wbindgen_export_0, b1 = g.__wbindgen_add_to_stack_pointer, y1 = g.__wbindgen_export_1, v1 = g.__wbindgen_export_2, x1 = Object.freeze(Object.defineProperty({
    __proto__: null,
    __wbg_rawbroadphase_free: aE,
    __wbg_rawccdsolver_free: wx,
    __wbg_rawcharactercollision_free: tv,
    __wbg_rawcolliderset_free: zT,
    __wbg_rawcollidershapecasthit_free: _R,
    __wbg_rawcontactforceevent_free: zR,
    __wbg_rawcontactmanifold_free: QT,
    __wbg_rawcontactpair_free: h1,
    __wbg_rawdebugrenderpipeline_free: DR,
    __wbg_rawdeserializedworld_free: gC,
    __wbg_rawdynamicraycastvehiclecontroller_free: vv,
    __wbg_raweventqueue_free: BR,
    __wbg_rawgenericjoint_free: uS,
    __wbg_rawimpulsejointset_free: Bx,
    __wbg_rawintegrationparameters_free: Xx,
    __wbg_rawislandmanager_free: lS,
    __wbg_rawkinematiccharactercontroller_free: Ty,
    __wbg_rawmultibodyjointset_free: PS,
    __wbg_rawnarrowphase_free: qT,
    __wbg_rawphysicspipeline_free: YR,
    __wbg_rawpidcontroller_free: hv,
    __wbg_rawpointcolliderprojection_free: AA,
    __wbg_rawpointprojection_free: MA,
    __wbg_rawraycolliderhit_free: NA,
    __wbg_rawraycolliderintersection_free: d1,
    __wbg_rawrayintersection_free: DA,
    __wbg_rawrigidbodyset_free: JM,
    __wbg_rawrotation_free: u1,
    __wbg_rawsdpmatrix3_free: f1,
    __wbg_rawserializationpipeline_free: _1,
    __wbg_rawshape_free: UA,
    __wbg_rawshapecasthit_free: dR,
    __wbg_rawshapecontact_free: XT,
    __wbg_rawvector_free: p1,
    __wbindgen_add_to_stack_pointer: b1,
    __wbindgen_export_0: w1,
    __wbindgen_export_1: y1,
    __wbindgen_export_2: v1,
    memory: My,
    rawbroadphase_castRay: cE,
    rawbroadphase_castRayAndGetNormal: lE,
    rawbroadphase_castShape: _E,
    rawbroadphase_collidersWithAabbIntersectingAabb: gE,
    rawbroadphase_intersectionWithShape: dE,
    rawbroadphase_intersectionsWithPoint: fE,
    rawbroadphase_intersectionsWithRay: hE,
    rawbroadphase_intersectionsWithShape: mE,
    rawbroadphase_new: oE,
    rawbroadphase_projectPoint: uE,
    rawbroadphase_projectPointAndGetFeature: pE,
    rawccdsolver_new: m1,
    rawcharactercollision_handle: nv,
    rawcharactercollision_new: ev,
    rawcharactercollision_toi: sv,
    rawcharactercollision_translationDeltaApplied: iv,
    rawcharactercollision_translationDeltaRemaining: rv,
    rawcharactercollision_worldNormal1: cv,
    rawcharactercollision_worldNormal2: lv,
    rawcharactercollision_worldWitness1: av,
    rawcharactercollision_worldWitness2: ov,
    rawcolliderset_coActiveCollisionTypes: lT,
    rawcolliderset_coActiveEvents: hT,
    rawcolliderset_coActiveHooks: cT,
    rawcolliderset_coCastCollider: fT,
    rawcolliderset_coCastRay: yT,
    rawcolliderset_coCastRayAndGetNormal: vT,
    rawcolliderset_coCastShape: pT,
    rawcolliderset_coCollisionGroups: aT,
    rawcolliderset_coCombineVoxelStates: HE,
    rawcolliderset_coContactCollider: gT,
    rawcolliderset_coContactForceEventThreshold: dT,
    rawcolliderset_coContactShape: mT,
    rawcolliderset_coContactSkin: tT,
    rawcolliderset_coContainsPoint: uT,
    rawcolliderset_coDensity: iT,
    rawcolliderset_coFriction: eT,
    rawcolliderset_coFrictionCombineRule: ET,
    rawcolliderset_coHalfExtents: CE,
    rawcolliderset_coHalfHeight: DE,
    rawcolliderset_coHalfspaceNormal: RE,
    rawcolliderset_coHeightFieldFlags: jE,
    rawcolliderset_coHeightfieldHeights: XE,
    rawcolliderset_coHeightfieldNCols: YE,
    rawcolliderset_coHeightfieldNRows: KE,
    rawcolliderset_coHeightfieldScale: qE,
    rawcolliderset_coIndices: VE,
    rawcolliderset_coIntersectsRay: bT,
    rawcolliderset_coIntersectsShape: _T,
    rawcolliderset_coIsEnabled: JE,
    rawcolliderset_coIsSensor: TE,
    rawcolliderset_coMass: rT,
    rawcolliderset_coParent: ZE,
    rawcolliderset_coProjectPoint: wT,
    rawcolliderset_coPropagateVoxelChange: kE,
    rawcolliderset_coRadius: IE,
    rawcolliderset_coRestitution: nT,
    rawcolliderset_coRestitutionCombineRule: AT,
    rawcolliderset_coRotation: bE,
    rawcolliderset_coRotationWrtParent: vE,
    rawcolliderset_coRoundRadius: UE,
    rawcolliderset_coSetActiveCollisionTypes: DT,
    rawcolliderset_coSetActiveEvents: LT,
    rawcolliderset_coSetActiveHooks: IT,
    rawcolliderset_coSetCollisionGroups: CT,
    rawcolliderset_coSetContactForceEventThreshold: UT,
    rawcolliderset_coSetContactSkin: QE,
    rawcolliderset_coSetDensity: FT,
    rawcolliderset_coSetEnabled: $E,
    rawcolliderset_coSetFriction: MT,
    rawcolliderset_coSetFrictionCombineRule: TT,
    rawcolliderset_coSetHalfExtents: PE,
    rawcolliderset_coSetHalfHeight: NE,
    rawcolliderset_coSetMass: OT,
    rawcolliderset_coSetMassProperties: BT,
    rawcolliderset_coSetRadius: LE,
    rawcolliderset_coSetRestitution: ST,
    rawcolliderset_coSetRestitutionCombineRule: RT,
    rawcolliderset_coSetRotation: ME,
    rawcolliderset_coSetRotationWrtParent: EE,
    rawcolliderset_coSetRoundRadius: FE,
    rawcolliderset_coSetSensor: xT,
    rawcolliderset_coSetShape: NT,
    rawcolliderset_coSetSolverGroups: PT,
    rawcolliderset_coSetTranslation: xE,
    rawcolliderset_coSetTranslationWrtParent: SE,
    rawcolliderset_coSetVoxel: zE,
    rawcolliderset_coShapeType: AE,
    rawcolliderset_coSolverGroups: oT,
    rawcolliderset_coTranslation: wE,
    rawcolliderset_coTranslationWrtParent: yE,
    rawcolliderset_coTriMeshFlags: WE,
    rawcolliderset_coVertices: GE,
    rawcolliderset_coVolume: sT,
    rawcolliderset_coVoxelData: OE,
    rawcolliderset_coVoxelSize: BE,
    rawcolliderset_contains: GT,
    rawcolliderset_createCollider: VT,
    rawcolliderset_forEachColliderHandle: jT,
    rawcolliderset_isHandleValid: CC,
    rawcolliderset_len: HT,
    rawcolliderset_new: kT,
    rawcolliderset_remove: WT,
    rawcollidershapecasthit_colliderHandle: t1,
    rawcollidershapecasthit_normal1: GC,
    rawcollidershapecasthit_normal2: VC,
    rawcollidershapecasthit_time_of_impact: mR,
    rawcollidershapecasthit_witness1: gR,
    rawcollidershapecasthit_witness2: wR,
    rawcontactforceevent_collider1: c1,
    rawcontactforceevent_collider2: kR,
    rawcontactforceevent_max_force_direction: VR,
    rawcontactforceevent_max_force_magnitude: WR,
    rawcontactforceevent_total_force: HR,
    rawcontactforceevent_total_force_magnitude: GR,
    rawcontactmanifold_contact_dist: uA,
    rawcontactmanifold_contact_fid1: pA,
    rawcontactmanifold_contact_fid2: fA,
    rawcontactmanifold_contact_impulse: _A,
    rawcontactmanifold_contact_local_p1: hA,
    rawcontactmanifold_contact_local_p2: dA,
    rawcontactmanifold_contact_tangent_impulse_x: mA,
    rawcontactmanifold_contact_tangent_impulse_y: gA,
    rawcontactmanifold_local_n1: sA,
    rawcontactmanifold_local_n2: aA,
    rawcontactmanifold_normal: rA,
    rawcontactmanifold_num_contacts: lA,
    rawcontactmanifold_num_solver_contacts: wA,
    rawcontactmanifold_solver_contact_dist: yA,
    rawcontactmanifold_solver_contact_friction: vA,
    rawcontactmanifold_solver_contact_point: bA,
    rawcontactmanifold_solver_contact_restitution: xA,
    rawcontactmanifold_solver_contact_tangent_velocity: SA,
    rawcontactmanifold_subshape1: oA,
    rawcontactmanifold_subshape2: cA,
    rawcontactpair_collider1: tA,
    rawcontactpair_collider2: eA,
    rawcontactpair_contactManifold: iA,
    rawcontactpair_numContactManifolds: nA,
    rawdebugrenderpipeline_colors: FR,
    rawdebugrenderpipeline_new: NR,
    rawdebugrenderpipeline_render: OR,
    rawdebugrenderpipeline_vertices: UR,
    rawdeserializedworld_takeBodies: SC,
    rawdeserializedworld_takeBroadPhase: vC,
    rawdeserializedworld_takeColliders: MC,
    rawdeserializedworld_takeGravity: wC,
    rawdeserializedworld_takeImpulseJoints: EC,
    rawdeserializedworld_takeIntegrationParameters: bC,
    rawdeserializedworld_takeIslandManager: yC,
    rawdeserializedworld_takeMultibodyJoints: TC,
    rawdeserializedworld_takeNarrowPhase: xC,
    rawdynamicraycastvehiclecontroller_add_wheel: Cv,
    rawdynamicraycastvehiclecontroller_chassis: Mv,
    rawdynamicraycastvehiclecontroller_current_vehicle_speed: Sv,
    rawdynamicraycastvehiclecontroller_index_forward_axis: Av,
    rawdynamicraycastvehiclecontroller_index_up_axis: Ev,
    rawdynamicraycastvehiclecontroller_new: xv,
    rawdynamicraycastvehiclecontroller_num_wheels: Pv,
    rawdynamicraycastvehiclecontroller_set_index_forward_axis: Rv,
    rawdynamicraycastvehiclecontroller_set_index_up_axis: Tv,
    rawdynamicraycastvehiclecontroller_set_wheel_axle_cs: ix,
    rawdynamicraycastvehiclecontroller_set_wheel_brake: Yv,
    rawdynamicraycastvehiclecontroller_set_wheel_chassis_connection_point_cs: Dv,
    rawdynamicraycastvehiclecontroller_set_wheel_direction_cs: ex,
    rawdynamicraycastvehiclecontroller_set_wheel_engine_force: Qv,
    rawdynamicraycastvehiclecontroller_set_wheel_friction_slip: sx,
    rawdynamicraycastvehiclecontroller_set_wheel_max_suspension_force: qv,
    rawdynamicraycastvehiclecontroller_set_wheel_max_suspension_travel: Ov,
    rawdynamicraycastvehiclecontroller_set_wheel_radius: zv,
    rawdynamicraycastvehiclecontroller_set_wheel_side_friction_stiffness: ox,
    rawdynamicraycastvehiclecontroller_set_wheel_steering: $v,
    rawdynamicraycastvehiclecontroller_set_wheel_suspension_compression: Vv,
    rawdynamicraycastvehiclecontroller_set_wheel_suspension_relaxation: jv,
    rawdynamicraycastvehiclecontroller_set_wheel_suspension_rest_length: Uv,
    rawdynamicraycastvehiclecontroller_set_wheel_suspension_stiffness: Hv,
    rawdynamicraycastvehiclecontroller_update_vehicle: Iv,
    rawdynamicraycastvehiclecontroller_wheel_axle_cs: nx,
    rawdynamicraycastvehiclecontroller_wheel_brake: Kv,
    rawdynamicraycastvehiclecontroller_wheel_chassis_connection_point_cs: Lv,
    rawdynamicraycastvehiclecontroller_wheel_contact_normal_ws: ux,
    rawdynamicraycastvehiclecontroller_wheel_contact_point_ws: px,
    rawdynamicraycastvehiclecontroller_wheel_direction_cs: tx,
    rawdynamicraycastvehiclecontroller_wheel_engine_force: Jv,
    rawdynamicraycastvehiclecontroller_wheel_forward_impulse: lx,
    rawdynamicraycastvehiclecontroller_wheel_friction_slip: rx,
    rawdynamicraycastvehiclecontroller_wheel_ground_object: gx,
    rawdynamicraycastvehiclecontroller_wheel_hard_point_ws: _x,
    rawdynamicraycastvehiclecontroller_wheel_is_in_contact: mx,
    rawdynamicraycastvehiclecontroller_wheel_max_suspension_force: Xv,
    rawdynamicraycastvehiclecontroller_wheel_max_suspension_travel: Fv,
    rawdynamicraycastvehiclecontroller_wheel_radius: Bv,
    rawdynamicraycastvehiclecontroller_wheel_rotation: cx,
    rawdynamicraycastvehiclecontroller_wheel_side_friction_stiffness: ax,
    rawdynamicraycastvehiclecontroller_wheel_side_impulse: hx,
    rawdynamicraycastvehiclecontroller_wheel_steering: Zv,
    rawdynamicraycastvehiclecontroller_wheel_suspension_compression: Gv,
    rawdynamicraycastvehiclecontroller_wheel_suspension_force: dx,
    rawdynamicraycastvehiclecontroller_wheel_suspension_length: fx,
    rawdynamicraycastvehiclecontroller_wheel_suspension_relaxation: Wv,
    rawdynamicraycastvehiclecontroller_wheel_suspension_rest_length: Nv,
    rawdynamicraycastvehiclecontroller_wheel_suspension_stiffness: kv,
    raweventqueue_clear: KR,
    raweventqueue_drainCollisionEvents: XR,
    raweventqueue_drainContactForceEvents: qR,
    raweventqueue_new: jR,
    rawgenericjoint_fixed: wS,
    rawgenericjoint_generic: pS,
    rawgenericjoint_prismatic: gS,
    rawgenericjoint_revolute: bS,
    rawgenericjoint_rope: _S,
    rawgenericjoint_spherical: mS,
    rawgenericjoint_spring: fS,
    rawimpulsejointset_contains: Vx,
    rawimpulsejointset_createJoint: kx,
    rawimpulsejointset_forEachJointAttachedToRigidBody: jx,
    rawimpulsejointset_forEachJointHandle: Wx,
    rawimpulsejointset_jointAnchor1: Mx,
    rawimpulsejointset_jointAnchor2: Ex,
    rawimpulsejointset_jointBodyHandle1: yx,
    rawimpulsejointset_jointBodyHandle2: vx,
    rawimpulsejointset_jointConfigureMotor: Ox,
    rawimpulsejointset_jointConfigureMotorModel: Nx,
    rawimpulsejointset_jointConfigureMotorPosition: Fx,
    rawimpulsejointset_jointConfigureMotorVelocity: Ux,
    rawimpulsejointset_jointContactsEnabled: Rx,
    rawimpulsejointset_jointFrameX1: xx,
    rawimpulsejointset_jointFrameX2: Sx,
    rawimpulsejointset_jointLimitsEnabled: Px,
    rawimpulsejointset_jointLimitsMax: Lx,
    rawimpulsejointset_jointLimitsMin: Ix,
    rawimpulsejointset_jointSetAnchor1: Tx,
    rawimpulsejointset_jointSetAnchor2: Ax,
    rawimpulsejointset_jointSetContactsEnabled: Cx,
    rawimpulsejointset_jointSetLimits: Dx,
    rawimpulsejointset_jointType: bx,
    rawimpulsejointset_len: Gx,
    rawimpulsejointset_new: zx,
    rawimpulsejointset_remove: Hx,
    rawintegrationparameters_contact_erp: Yx,
    rawintegrationparameters_dt: Kx,
    rawintegrationparameters_lengthUnit: l1,
    rawintegrationparameters_maxCcdSubsteps: tS,
    rawintegrationparameters_minIslandSize: Qx,
    rawintegrationparameters_new: qx,
    rawintegrationparameters_normalizedAllowedLinearError: Zx,
    rawintegrationparameters_normalizedPredictionDistance: $x,
    rawintegrationparameters_numInternalPgsIterations: jC,
    rawintegrationparameters_numSolverIterations: Jx,
    rawintegrationparameters_set_contact_natural_frequency: nS,
    rawintegrationparameters_set_dt: eS,
    rawintegrationparameters_set_lengthUnit: cS,
    rawintegrationparameters_set_maxCcdSubsteps: oS,
    rawintegrationparameters_set_minIslandSize: aS,
    rawintegrationparameters_set_normalizedAllowedLinearError: iS,
    rawintegrationparameters_set_normalizedPredictionDistance: rS,
    rawintegrationparameters_set_numInternalPgsIterations: LC,
    rawintegrationparameters_set_numSolverIterations: sS,
    rawislandmanager_forEachActiveRigidBodyHandle: dS,
    rawislandmanager_new: hS,
    rawkinematiccharactercontroller_autostepEnabled: By,
    rawkinematiccharactercontroller_autostepIncludesDynamicBodies: Oy,
    rawkinematiccharactercontroller_autostepMaxHeight: Uy,
    rawkinematiccharactercontroller_autostepMinWidth: Fy,
    rawkinematiccharactercontroller_computeColliderMovement: Yy,
    rawkinematiccharactercontroller_computedCollision: Qy,
    rawkinematiccharactercontroller_computedGrounded: $y,
    rawkinematiccharactercontroller_computedMovement: Zy,
    rawkinematiccharactercontroller_disableAutostep: ky,
    rawkinematiccharactercontroller_disableSnapToGround: qy,
    rawkinematiccharactercontroller_enableAutostep: zy,
    rawkinematiccharactercontroller_enableSnapToGround: Xy,
    rawkinematiccharactercontroller_maxSlopeClimbAngle: Hy,
    rawkinematiccharactercontroller_minSlopeSlideAngle: Vy,
    rawkinematiccharactercontroller_new: Ay,
    rawkinematiccharactercontroller_normalNudgeFactor: Cy,
    rawkinematiccharactercontroller_numComputedCollisions: Jy,
    rawkinematiccharactercontroller_offset: Iy,
    rawkinematiccharactercontroller_setMaxSlopeClimbAngle: Gy,
    rawkinematiccharactercontroller_setMinSlopeSlideAngle: Wy,
    rawkinematiccharactercontroller_setNormalNudgeFactor: Py,
    rawkinematiccharactercontroller_setOffset: Ly,
    rawkinematiccharactercontroller_setSlideEnabled: Ny,
    rawkinematiccharactercontroller_setUp: Ry,
    rawkinematiccharactercontroller_slideEnabled: Dy,
    rawkinematiccharactercontroller_snapToGroundDistance: jy,
    rawkinematiccharactercontroller_snapToGroundEnabled: Ky,
    rawkinematiccharactercontroller_up: UC,
    rawmultibodyjointset_contains: NS,
    rawmultibodyjointset_createJoint: LS,
    rawmultibodyjointset_forEachJointAttachedToRigidBody: FS,
    rawmultibodyjointset_forEachJointHandle: US,
    rawmultibodyjointset_jointAnchor1: SS,
    rawmultibodyjointset_jointAnchor2: MS,
    rawmultibodyjointset_jointContactsEnabled: ES,
    rawmultibodyjointset_jointFrameX1: vS,
    rawmultibodyjointset_jointFrameX2: xS,
    rawmultibodyjointset_jointLimitsEnabled: AS,
    rawmultibodyjointset_jointLimitsMax: CS,
    rawmultibodyjointset_jointLimitsMin: RS,
    rawmultibodyjointset_jointSetContactsEnabled: TS,
    rawmultibodyjointset_jointType: yS,
    rawmultibodyjointset_new: IS,
    rawmultibodyjointset_remove: DS,
    rawnarrowphase_contact_pair: ZT,
    rawnarrowphase_contact_pairs_with: YT,
    rawnarrowphase_intersection_pair: JT,
    rawnarrowphase_intersection_pairs_with: $T,
    rawnarrowphase_new: KT,
    rawphysicspipeline_is_profiler_enabled: JR,
    rawphysicspipeline_new: ZR,
    rawphysicspipeline_set_profiler_enabled: $R,
    rawphysicspipeline_step: _C,
    rawphysicspipeline_stepWithEvents: mC,
    rawphysicspipeline_timing_broad_phase: eC,
    rawphysicspipeline_timing_ccd: cC,
    rawphysicspipeline_timing_ccd_broad_phase: hC,
    rawphysicspipeline_timing_ccd_narrow_phase: dC,
    rawphysicspipeline_timing_ccd_solver: uC,
    rawphysicspipeline_timing_ccd_toi_computation: lC,
    rawphysicspipeline_timing_collision_detection: tC,
    rawphysicspipeline_timing_island_construction: pC,
    rawphysicspipeline_timing_narrow_phase: nC,
    rawphysicspipeline_timing_solver: iC,
    rawphysicspipeline_timing_step: QR,
    rawphysicspipeline_timing_user_changes: fC,
    rawphysicspipeline_timing_velocity_assembly: rC,
    rawphysicspipeline_timing_velocity_resolution: sC,
    rawphysicspipeline_timing_velocity_update: aC,
    rawphysicspipeline_timing_velocity_writeback: oC,
    rawpidcontroller_angular_correction: yv,
    rawpidcontroller_apply_angular_correction: wv,
    rawpidcontroller_apply_linear_correction: gv,
    rawpidcontroller_linear_correction: bv,
    rawpidcontroller_new: dv,
    rawpidcontroller_reset_integrals: mv,
    rawpidcontroller_set_axes_mask: _v,
    rawpidcontroller_set_kd: fv,
    rawpidcontroller_set_ki: pv,
    rawpidcontroller_set_kp: uv,
    rawpointcolliderprojection_colliderHandle: RA,
    rawpointcolliderprojection_featureId: LA,
    rawpointcolliderprojection_featureType: IA,
    rawpointcolliderprojection_isInside: PA,
    rawpointcolliderprojection_point: CA,
    rawpointprojection_isInside: TA,
    rawpointprojection_point: EA,
    rawraycolliderhit_colliderHandle: $C,
    rawraycolliderhit_timeOfImpact: e1,
    rawraycolliderintersection_colliderHandle: KC,
    rawraycolliderintersection_featureId: IC,
    rawraycolliderintersection_featureType: ZC,
    rawraycolliderintersection_normal: kC,
    rawraycolliderintersection_time_of_impact: JC,
    rawrayintersection_featureId: PC,
    rawrayintersection_featureType: qC,
    rawrayintersection_normal: zC,
    rawrayintersection_time_of_impact: YC,
    rawrigidbodyset_contains: iE,
    rawrigidbodyset_createRigidBody: tE,
    rawrigidbodyset_forEachRigidBodyHandle: rE,
    rawrigidbodyset_len: nE,
    rawrigidbodyset_new: QM,
    rawrigidbodyset_propagateModifiedBodyPositionsToColliders: sE,
    rawrigidbodyset_rbAddForce: kM,
    rawrigidbodyset_rbAddForceAtPoint: WM,
    rawrigidbodyset_rbAddTorque: GM,
    rawrigidbodyset_rbAdditionalSolverIterations: XM,
    rawrigidbodyset_rbAngularDamping: IM,
    rawrigidbodyset_rbAngvel: tM,
    rawrigidbodyset_rbApplyImpulse: HM,
    rawrigidbodyset_rbApplyImpulseAtPoint: jM,
    rawrigidbodyset_rbApplyTorqueImpulse: VM,
    rawrigidbodyset_rbBodyType: EM,
    rawrigidbodyset_rbCollider: MM,
    rawrigidbodyset_rbDominanceGroup: aM,
    rawrigidbodyset_rbEffectiveAngularInertia: bM,
    rawrigidbodyset_rbEffectiveInvMass: uM,
    rawrigidbodyset_rbEffectiveWorldInvInertia: wM,
    rawrigidbodyset_rbEnableCcd: cM,
    rawrigidbodyset_rbGravityScale: FM,
    rawrigidbodyset_rbInvMass: dM,
    rawrigidbodyset_rbInvPrincipalInertia: _M,
    rawrigidbodyset_rbIsCcdEnabled: vM,
    rawrigidbodyset_rbIsDynamic: CM,
    rawrigidbodyset_rbIsEnabled: UM,
    rawrigidbodyset_rbIsFixed: AM,
    rawrigidbodyset_rbIsKinematic: RM,
    rawrigidbodyset_rbIsMoving: HS,
    rawrigidbodyset_rbIsSleeping: kS,
    rawrigidbodyset_rbLinearDamping: PM,
    rawrigidbodyset_rbLinvel: QS,
    rawrigidbodyset_rbLocalCom: pM,
    rawrigidbodyset_rbLockRotations: rM,
    rawrigidbodyset_rbLockTranslations: nM,
    rawrigidbodyset_rbMass: hM,
    rawrigidbodyset_rbNextRotation: VS,
    rawrigidbodyset_rbNextTranslation: GS,
    rawrigidbodyset_rbNumColliders: SM,
    rawrigidbodyset_rbPrincipalInertia: gM,
    rawrigidbodyset_rbPrincipalInertiaLocalFrame: mM,
    rawrigidbodyset_rbRecomputeMassPropertiesFromColliders: ZS,
    rawrigidbodyset_rbResetForces: BM,
    rawrigidbodyset_rbResetTorques: zM,
    rawrigidbodyset_rbRotation: BS,
    rawrigidbodyset_rbSetAdditionalMass: $S,
    rawrigidbodyset_rbSetAdditionalMassProperties: JS,
    rawrigidbodyset_rbSetAdditionalSolverIterations: qM,
    rawrigidbodyset_rbSetAngularDamping: DM,
    rawrigidbodyset_rbSetAngvel: qS,
    rawrigidbodyset_rbSetBodyType: TM,
    rawrigidbodyset_rbSetDominanceGroup: oM,
    rawrigidbodyset_rbSetEnabled: NM,
    rawrigidbodyset_rbSetEnabledRotations: sM,
    rawrigidbodyset_rbSetEnabledTranslations: iM,
    rawrigidbodyset_rbSetGravityScale: OM,
    rawrigidbodyset_rbSetLinearDamping: LM,
    rawrigidbodyset_rbSetLinvel: XS,
    rawrigidbodyset_rbSetNextKinematicRotation: YS,
    rawrigidbodyset_rbSetNextKinematicTranslation: KS,
    rawrigidbodyset_rbSetRotation: jS,
    rawrigidbodyset_rbSetSoftCcdPrediction: lM,
    rawrigidbodyset_rbSetTranslation: WS,
    rawrigidbodyset_rbSetUserData: YM,
    rawrigidbodyset_rbSleep: zS,
    rawrigidbodyset_rbSoftCcdPrediction: xM,
    rawrigidbodyset_rbTranslation: OS,
    rawrigidbodyset_rbUserData: KM,
    rawrigidbodyset_rbUserForce: ZM,
    rawrigidbodyset_rbUserTorque: $M,
    rawrigidbodyset_rbVelocityAtPoint: eM,
    rawrigidbodyset_rbWakeUp: yM,
    rawrigidbodyset_rbWorldCom: fM,
    rawrigidbodyset_remove: eE,
    rawrotation_identity: yR,
    rawrotation_new: bR,
    rawrotation_w: vR,
    rawrotation_x: n1,
    rawrotation_y: i1,
    rawrotation_z: r1,
    rawsdpmatrix3_elements: LR,
    rawserializationpipeline_deserializeAll: RC,
    rawserializationpipeline_new: g1,
    rawserializationpipeline_serializeAll: AC,
    rawshape_ball: BA,
    rawshape_capsule: kA,
    rawshape_castRay: lR,
    rawshape_castRayAndGetNormal: hR,
    rawshape_castShape: iR,
    rawshape_cone: VA,
    rawshape_contactShape: sR,
    rawshape_containsPoint: aR,
    rawshape_convexHull: QA,
    rawshape_convexMesh: eR,
    rawshape_cuboid: FA,
    rawshape_cylinder: HA,
    rawshape_halfspace: zA,
    rawshape_heightfield: YA,
    rawshape_intersectsRay: cR,
    rawshape_intersectsShape: rR,
    rawshape_polyline: qA,
    rawshape_projectPoint: oR,
    rawshape_roundCone: WA,
    rawshape_roundConvexHull: tR,
    rawshape_roundConvexMesh: nR,
    rawshape_roundCuboid: OA,
    rawshape_roundCylinder: GA,
    rawshape_roundTriangle: JA,
    rawshape_segment: ZA,
    rawshape_triangle: $A,
    rawshape_trimesh: KA,
    rawshape_voxels: jA,
    rawshape_voxelsFromPoints: XA,
    rawshapecasthit_normal1: pR,
    rawshapecasthit_normal2: fR,
    rawshapecasthit_time_of_impact: QC,
    rawshapecasthit_witness1: uR,
    rawshapecasthit_witness2: WC,
    rawshapecontact_distance: XC,
    rawshapecontact_normal1: HC,
    rawshapecontact_normal2: FC,
    rawshapecontact_point1: OC,
    rawshapecontact_point2: BC,
    rawvector_new: SR,
    rawvector_set_x: DC,
    rawvector_set_y: MR,
    rawvector_set_z: ER,
    rawvector_x: s1,
    rawvector_xyz: TR,
    rawvector_xzy: CR,
    rawvector_y: a1,
    rawvector_yxz: AR,
    rawvector_yzx: PR,
    rawvector_z: o1,
    rawvector_zero: xR,
    rawvector_zxy: RR,
    rawvector_zyx: IR,
    reserve_memory: NC,
    version: Ey
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  Ib(x1);
  class gn {
    constructor(t, e, n) {
      this.x = t, this.y = e, this.z = n;
    }
  }
  class U {
    static new(t, e, n) {
      return new gn(t, e, n);
    }
    static intoRaw(t) {
      return new N(t.x, t.y, t.z);
    }
    static zeros() {
      return U.new(0, 0, 0);
    }
    static fromRaw(t) {
      if (!t) return null;
      let e = U.new(t.x, t.y, t.z);
      return t.free(), e;
    }
    static copy(t, e) {
      t.x = e.x, t.y = e.y, t.z = e.z;
    }
  }
  class Ma {
    constructor(t, e, n, i) {
      this.x = t, this.y = e, this.z = n, this.w = i;
    }
  }
  class Ut {
    static identity() {
      return new Ma(0, 0, 0, 1);
    }
    static fromRaw(t) {
      if (!t) return null;
      let e = new Ma(t.x, t.y, t.z, t.w);
      return t.free(), e;
    }
    static intoRaw(t) {
      return new Wt(t.x, t.y, t.z, t.w);
    }
    static copy(t, e) {
      t.x = e.x, t.y = e.y, t.z = e.z, t.w = e.w;
    }
  }
  class Yc {
    get m11() {
      return this.elements[0];
    }
    get m12() {
      return this.elements[1];
    }
    get m21() {
      return this.m12;
    }
    get m13() {
      return this.elements[2];
    }
    get m31() {
      return this.m13;
    }
    get m22() {
      return this.elements[3];
    }
    get m23() {
      return this.elements[4];
    }
    get m32() {
      return this.m23;
    }
    get m33() {
      return this.elements[5];
    }
    constructor(t) {
      this.elements = t;
    }
  }
  class Ea {
    static fromRaw(t) {
      const e = new Yc(t.elements());
      return t.free(), e;
    }
  }
  var _n;
  (function(r) {
    r[r.Dynamic = 0] = "Dynamic", r[r.Fixed = 1] = "Fixed", r[r.KinematicPositionBased = 2] = "KinematicPositionBased", r[r.KinematicVelocityBased = 3] = "KinematicVelocityBased";
  })(_n || (_n = {}));
  class Ta {
    constructor(t, e, n) {
      this.rawSet = t, this.colliderSet = e, this.handle = n;
    }
    finalizeDeserialization(t) {
      this.colliderSet = t;
    }
    isValid() {
      return this.rawSet.contains(this.handle);
    }
    lockTranslations(t, e) {
      return this.rawSet.rbLockTranslations(this.handle, t, e);
    }
    lockRotations(t, e) {
      return this.rawSet.rbLockRotations(this.handle, t, e);
    }
    setEnabledTranslations(t, e, n, i) {
      return this.rawSet.rbSetEnabledTranslations(this.handle, t, e, n, i);
    }
    restrictTranslations(t, e, n, i) {
      this.setEnabledTranslations(t, e, n, i);
    }
    setEnabledRotations(t, e, n, i) {
      return this.rawSet.rbSetEnabledRotations(this.handle, t, e, n, i);
    }
    restrictRotations(t, e, n, i) {
      this.setEnabledRotations(t, e, n, i);
    }
    dominanceGroup() {
      return this.rawSet.rbDominanceGroup(this.handle);
    }
    setDominanceGroup(t) {
      this.rawSet.rbSetDominanceGroup(this.handle, t);
    }
    additionalSolverIterations() {
      return this.rawSet.rbAdditionalSolverIterations(this.handle);
    }
    setAdditionalSolverIterations(t) {
      this.rawSet.rbSetAdditionalSolverIterations(this.handle, t);
    }
    enableCcd(t) {
      this.rawSet.rbEnableCcd(this.handle, t);
    }
    setSoftCcdPrediction(t) {
      this.rawSet.rbSetSoftCcdPrediction(this.handle, t);
    }
    softCcdPrediction() {
      return this.rawSet.rbSoftCcdPrediction(this.handle);
    }
    translation() {
      let t = this.rawSet.rbTranslation(this.handle);
      return U.fromRaw(t);
    }
    rotation() {
      let t = this.rawSet.rbRotation(this.handle);
      return Ut.fromRaw(t);
    }
    nextTranslation() {
      let t = this.rawSet.rbNextTranslation(this.handle);
      return U.fromRaw(t);
    }
    nextRotation() {
      let t = this.rawSet.rbNextRotation(this.handle);
      return Ut.fromRaw(t);
    }
    setTranslation(t, e) {
      this.rawSet.rbSetTranslation(this.handle, t.x, t.y, t.z, e);
    }
    setLinvel(t, e) {
      let n = U.intoRaw(t);
      this.rawSet.rbSetLinvel(this.handle, n, e), n.free();
    }
    gravityScale() {
      return this.rawSet.rbGravityScale(this.handle);
    }
    setGravityScale(t, e) {
      this.rawSet.rbSetGravityScale(this.handle, t, e);
    }
    setRotation(t, e) {
      this.rawSet.rbSetRotation(this.handle, t.x, t.y, t.z, t.w, e);
    }
    setAngvel(t, e) {
      let n = U.intoRaw(t);
      this.rawSet.rbSetAngvel(this.handle, n, e), n.free();
    }
    setNextKinematicTranslation(t) {
      this.rawSet.rbSetNextKinematicTranslation(this.handle, t.x, t.y, t.z);
    }
    setNextKinematicRotation(t) {
      this.rawSet.rbSetNextKinematicRotation(this.handle, t.x, t.y, t.z, t.w);
    }
    linvel() {
      return U.fromRaw(this.rawSet.rbLinvel(this.handle));
    }
    velocityAtPoint(t) {
      const e = U.intoRaw(t);
      let n = U.fromRaw(this.rawSet.rbVelocityAtPoint(this.handle, e));
      return e.free(), n;
    }
    angvel() {
      return U.fromRaw(this.rawSet.rbAngvel(this.handle));
    }
    mass() {
      return this.rawSet.rbMass(this.handle);
    }
    effectiveInvMass() {
      return U.fromRaw(this.rawSet.rbEffectiveInvMass(this.handle));
    }
    invMass() {
      return this.rawSet.rbInvMass(this.handle);
    }
    localCom() {
      return U.fromRaw(this.rawSet.rbLocalCom(this.handle));
    }
    worldCom() {
      return U.fromRaw(this.rawSet.rbWorldCom(this.handle));
    }
    invPrincipalInertia() {
      return U.fromRaw(this.rawSet.rbInvPrincipalInertia(this.handle));
    }
    principalInertia() {
      return U.fromRaw(this.rawSet.rbPrincipalInertia(this.handle));
    }
    principalInertiaLocalFrame() {
      return Ut.fromRaw(this.rawSet.rbPrincipalInertiaLocalFrame(this.handle));
    }
    effectiveWorldInvInertia() {
      return Ea.fromRaw(this.rawSet.rbEffectiveWorldInvInertia(this.handle));
    }
    effectiveAngularInertia() {
      return Ea.fromRaw(this.rawSet.rbEffectiveAngularInertia(this.handle));
    }
    sleep() {
      this.rawSet.rbSleep(this.handle);
    }
    wakeUp() {
      this.rawSet.rbWakeUp(this.handle);
    }
    isCcdEnabled() {
      return this.rawSet.rbIsCcdEnabled(this.handle);
    }
    numColliders() {
      return this.rawSet.rbNumColliders(this.handle);
    }
    collider(t) {
      return this.colliderSet.get(this.rawSet.rbCollider(this.handle, t));
    }
    setEnabled(t) {
      this.rawSet.rbSetEnabled(this.handle, t);
    }
    isEnabled() {
      return this.rawSet.rbIsEnabled(this.handle);
    }
    bodyType() {
      return this.rawSet.rbBodyType(this.handle);
    }
    setBodyType(t, e) {
      return this.rawSet.rbSetBodyType(this.handle, t, e);
    }
    isSleeping() {
      return this.rawSet.rbIsSleeping(this.handle);
    }
    isMoving() {
      return this.rawSet.rbIsMoving(this.handle);
    }
    isFixed() {
      return this.rawSet.rbIsFixed(this.handle);
    }
    isKinematic() {
      return this.rawSet.rbIsKinematic(this.handle);
    }
    isDynamic() {
      return this.rawSet.rbIsDynamic(this.handle);
    }
    linearDamping() {
      return this.rawSet.rbLinearDamping(this.handle);
    }
    angularDamping() {
      return this.rawSet.rbAngularDamping(this.handle);
    }
    setLinearDamping(t) {
      this.rawSet.rbSetLinearDamping(this.handle, t);
    }
    recomputeMassPropertiesFromColliders() {
      this.rawSet.rbRecomputeMassPropertiesFromColliders(this.handle, this.colliderSet.raw);
    }
    setAdditionalMass(t, e) {
      this.rawSet.rbSetAdditionalMass(this.handle, t, e);
    }
    setAdditionalMassProperties(t, e, n, i, s) {
      let a = U.intoRaw(e), o = U.intoRaw(n), c = Ut.intoRaw(i);
      this.rawSet.rbSetAdditionalMassProperties(this.handle, t, a, o, c, s), a.free(), o.free(), c.free();
    }
    setAngularDamping(t) {
      this.rawSet.rbSetAngularDamping(this.handle, t);
    }
    resetForces(t) {
      this.rawSet.rbResetForces(this.handle, t);
    }
    resetTorques(t) {
      this.rawSet.rbResetTorques(this.handle, t);
    }
    addForce(t, e) {
      const n = U.intoRaw(t);
      this.rawSet.rbAddForce(this.handle, n, e), n.free();
    }
    applyImpulse(t, e) {
      const n = U.intoRaw(t);
      this.rawSet.rbApplyImpulse(this.handle, n, e), n.free();
    }
    addTorque(t, e) {
      const n = U.intoRaw(t);
      this.rawSet.rbAddTorque(this.handle, n, e), n.free();
    }
    applyTorqueImpulse(t, e) {
      const n = U.intoRaw(t);
      this.rawSet.rbApplyTorqueImpulse(this.handle, n, e), n.free();
    }
    addForceAtPoint(t, e, n) {
      const i = U.intoRaw(t), s = U.intoRaw(e);
      this.rawSet.rbAddForceAtPoint(this.handle, i, s, n), i.free(), s.free();
    }
    applyImpulseAtPoint(t, e, n) {
      const i = U.intoRaw(t), s = U.intoRaw(e);
      this.rawSet.rbApplyImpulseAtPoint(this.handle, i, s, n), i.free(), s.free();
    }
    userForce() {
      return U.fromRaw(this.rawSet.rbUserForce(this.handle));
    }
    userTorque() {
      return U.fromRaw(this.rawSet.rbUserTorque(this.handle));
    }
  }
  class mn {
    constructor(t) {
      this.enabled = true, this.status = t, this.translation = U.zeros(), this.rotation = Ut.identity(), this.gravityScale = 1, this.linvel = U.zeros(), this.mass = 0, this.massOnly = false, this.centerOfMass = U.zeros(), this.translationsEnabledX = true, this.translationsEnabledY = true, this.angvel = U.zeros(), this.principalAngularInertia = U.zeros(), this.angularInertiaLocalFrame = Ut.identity(), this.translationsEnabledZ = true, this.rotationsEnabledX = true, this.rotationsEnabledY = true, this.rotationsEnabledZ = true, this.linearDamping = 0, this.angularDamping = 0, this.canSleep = true, this.sleeping = false, this.ccdEnabled = false, this.softCcdPrediction = 0, this.dominanceGroup = 0, this.additionalSolverIterations = 0;
    }
    static dynamic() {
      return new mn(_n.Dynamic);
    }
    static kinematicPositionBased() {
      return new mn(_n.KinematicPositionBased);
    }
    static kinematicVelocityBased() {
      return new mn(_n.KinematicVelocityBased);
    }
    static fixed() {
      return new mn(_n.Fixed);
    }
    static newDynamic() {
      return new mn(_n.Dynamic);
    }
    static newKinematicPositionBased() {
      return new mn(_n.KinematicPositionBased);
    }
    static newKinematicVelocityBased() {
      return new mn(_n.KinematicVelocityBased);
    }
    static newStatic() {
      return new mn(_n.Fixed);
    }
    setDominanceGroup(t) {
      return this.dominanceGroup = t, this;
    }
    setAdditionalSolverIterations(t) {
      return this.additionalSolverIterations = t, this;
    }
    setEnabled(t) {
      return this.enabled = t, this;
    }
    setTranslation(t, e, n) {
      if (typeof t != "number" || typeof e != "number" || typeof n != "number") throw TypeError("The translation components must be numbers.");
      return this.translation = {
        x: t,
        y: e,
        z: n
      }, this;
    }
    setRotation(t) {
      return Ut.copy(this.rotation, t), this;
    }
    setGravityScale(t) {
      return this.gravityScale = t, this;
    }
    setAdditionalMass(t) {
      return this.mass = t, this.massOnly = true, this;
    }
    setLinvel(t, e, n) {
      if (typeof t != "number" || typeof e != "number" || typeof n != "number") throw TypeError("The linvel components must be numbers.");
      return this.linvel = {
        x: t,
        y: e,
        z: n
      }, this;
    }
    setAngvel(t) {
      return U.copy(this.angvel, t), this;
    }
    setAdditionalMassProperties(t, e, n, i) {
      return this.mass = t, U.copy(this.centerOfMass, e), U.copy(this.principalAngularInertia, n), Ut.copy(this.angularInertiaLocalFrame, i), this.massOnly = false, this;
    }
    enabledTranslations(t, e, n) {
      return this.translationsEnabledX = t, this.translationsEnabledY = e, this.translationsEnabledZ = n, this;
    }
    restrictTranslations(t, e, n) {
      return this.enabledTranslations(t, e, n);
    }
    lockTranslations() {
      return this.enabledTranslations(false, false, false);
    }
    enabledRotations(t, e, n) {
      return this.rotationsEnabledX = t, this.rotationsEnabledY = e, this.rotationsEnabledZ = n, this;
    }
    restrictRotations(t, e, n) {
      return this.enabledRotations(t, e, n);
    }
    lockRotations() {
      return this.restrictRotations(false, false, false);
    }
    setLinearDamping(t) {
      return this.linearDamping = t, this;
    }
    setAngularDamping(t) {
      return this.angularDamping = t, this;
    }
    setCanSleep(t) {
      return this.canSleep = t, this;
    }
    setSleeping(t) {
      return this.sleeping = t, this;
    }
    setCcdEnabled(t) {
      return this.ccdEnabled = t, this;
    }
    setSoftCcdPrediction(t) {
      return this.softCcdPrediction = t, this;
    }
    setUserData(t) {
      return this.userData = t, this;
    }
  }
  class Za {
    constructor() {
      this.fconv = new Float64Array(1), this.uconv = new Uint32Array(this.fconv.buffer), this.data = new Array(), this.size = 0;
    }
    set(t, e) {
      let n = this.index(t);
      for (; this.data.length <= n; ) this.data.push(null);
      this.data[n] == null && (this.size += 1), this.data[n] = e;
    }
    len() {
      return this.size;
    }
    delete(t) {
      let e = this.index(t);
      e < this.data.length && (this.data[e] != null && (this.size -= 1), this.data[e] = null);
    }
    clear() {
      this.data = new Array();
    }
    get(t) {
      let e = this.index(t);
      return e < this.data.length ? this.data[e] : null;
    }
    forEach(t) {
      for (const e of this.data) e != null && t(e);
    }
    getAll() {
      return this.data.filter((t) => t != null);
    }
    index(t) {
      return this.fconv[0] = t, this.uconv[0];
    }
  }
  class Zc {
    free() {
      this.raw && this.raw.free(), this.raw = void 0, this.map && this.map.clear(), this.map = void 0;
    }
    constructor(t) {
      this.raw = t || new pe(), this.map = new Za(), t && t.forEachRigidBodyHandle((e) => {
        this.map.set(e, new Ta(t, null, e));
      });
    }
    finalizeDeserialization(t) {
      this.map.forEach((e) => e.finalizeDeserialization(t));
    }
    createRigidBody(t, e) {
      let n = U.intoRaw(e.translation), i = Ut.intoRaw(e.rotation), s = U.intoRaw(e.linvel), a = U.intoRaw(e.centerOfMass), o = U.intoRaw(e.angvel), c = U.intoRaw(e.principalAngularInertia), l = Ut.intoRaw(e.angularInertiaLocalFrame), h = this.raw.createRigidBody(e.enabled, n, i, e.gravityScale, e.mass, e.massOnly, a, s, o, c, l, e.translationsEnabledX, e.translationsEnabledY, e.translationsEnabledZ, e.rotationsEnabledX, e.rotationsEnabledY, e.rotationsEnabledZ, e.linearDamping, e.angularDamping, e.status, e.canSleep, e.sleeping, e.softCcdPrediction, e.ccdEnabled, e.dominanceGroup, e.additionalSolverIterations);
      n.free(), i.free(), s.free(), a.free(), o.free(), c.free(), l.free();
      const d = new Ta(this.raw, t, h);
      return d.userData = e.userData, this.map.set(h, d), d;
    }
    remove(t, e, n, i, s) {
      for (let a = 0; a < this.raw.rbNumColliders(t); a += 1) n.unmap(this.raw.rbCollider(t, a));
      i.forEachJointHandleAttachedToRigidBody(t, (a) => i.unmap(a)), s.forEachJointHandleAttachedToRigidBody(t, (a) => s.unmap(a)), this.raw.remove(t, e.raw, n.raw, i.raw, s.raw), this.map.delete(t);
    }
    len() {
      return this.map.len();
    }
    contains(t) {
      return this.get(t) != null;
    }
    get(t) {
      return this.map.get(t);
    }
    forEach(t) {
      this.map.forEach(t);
    }
    forEachActiveRigidBody(t, e) {
      t.forEachActiveRigidBodyHandle((n) => {
        e(this.get(n));
      });
    }
    getAll() {
      return this.map.getAll();
    }
  }
  class $c {
    constructor(t) {
      this.raw = t || new zi();
    }
    free() {
      this.raw && this.raw.free(), this.raw = void 0;
    }
    get dt() {
      return this.raw.dt;
    }
    get contact_erp() {
      return this.raw.contact_erp;
    }
    get lengthUnit() {
      return this.raw.lengthUnit;
    }
    get normalizedAllowedLinearError() {
      return this.raw.normalizedAllowedLinearError;
    }
    get normalizedPredictionDistance() {
      return this.raw.normalizedPredictionDistance;
    }
    get numSolverIterations() {
      return this.raw.numSolverIterations;
    }
    get numInternalPgsIterations() {
      return this.raw.numInternalPgsIterations;
    }
    get minIslandSize() {
      return this.raw.minIslandSize;
    }
    get maxCcdSubsteps() {
      return this.raw.maxCcdSubsteps;
    }
    set dt(t) {
      this.raw.dt = t;
    }
    set contact_natural_frequency(t) {
      this.raw.contact_natural_frequency = t;
    }
    set lengthUnit(t) {
      this.raw.lengthUnit = t;
    }
    set normalizedAllowedLinearError(t) {
      this.raw.normalizedAllowedLinearError = t;
    }
    set normalizedPredictionDistance(t) {
      this.raw.normalizedPredictionDistance = t;
    }
    set numSolverIterations(t) {
      this.raw.numSolverIterations = t;
    }
    set numInternalPgsIterations(t) {
      this.raw.numInternalPgsIterations = t;
    }
    set minIslandSize(t) {
      this.raw.minIslandSize = t;
    }
    set maxCcdSubsteps(t) {
      this.raw.maxCcdSubsteps = t;
    }
  }
  var ke;
  (function(r) {
    r[r.Revolute = 0] = "Revolute", r[r.Fixed = 1] = "Fixed", r[r.Prismatic = 2] = "Prismatic", r[r.Rope = 3] = "Rope", r[r.Spring = 4] = "Spring", r[r.Spherical = 5] = "Spherical", r[r.Generic = 6] = "Generic";
  })(ke || (ke = {}));
  var Aa;
  (function(r) {
    r[r.AccelerationBased = 0] = "AccelerationBased", r[r.ForceBased = 1] = "ForceBased";
  })(Aa || (Aa = {}));
  var Ra;
  (function(r) {
    r[r.LinX = 1] = "LinX", r[r.LinY = 2] = "LinY", r[r.LinZ = 4] = "LinZ", r[r.AngX = 8] = "AngX", r[r.AngY = 16] = "AngY", r[r.AngZ = 32] = "AngZ";
  })(Ra || (Ra = {}));
  class wn {
    constructor(t, e, n) {
      this.rawSet = t, this.bodySet = e, this.handle = n;
    }
    static newTyped(t, e, n) {
      switch (t.jointType(n)) {
        case Sn.Revolute:
          return new nl(t, e, n);
        case Sn.Prismatic:
          return new el(t, e, n);
        case Sn.Fixed:
          return new Jc(t, e, n);
        case Sn.Spring:
          return new tl(t, e, n);
        case Sn.Rope:
          return new Qc(t, e, n);
        case Sn.Spherical:
          return new rl(t, e, n);
        case Sn.Generic:
          return new il(t, e, n);
        default:
          return new wn(t, e, n);
      }
    }
    finalizeDeserialization(t) {
      this.bodySet = t;
    }
    isValid() {
      return this.rawSet.contains(this.handle);
    }
    body1() {
      return this.bodySet.get(this.rawSet.jointBodyHandle1(this.handle));
    }
    body2() {
      return this.bodySet.get(this.rawSet.jointBodyHandle2(this.handle));
    }
    type() {
      return this.rawSet.jointType(this.handle);
    }
    frameX1() {
      return Ut.fromRaw(this.rawSet.jointFrameX1(this.handle));
    }
    frameX2() {
      return Ut.fromRaw(this.rawSet.jointFrameX2(this.handle));
    }
    anchor1() {
      return U.fromRaw(this.rawSet.jointAnchor1(this.handle));
    }
    anchor2() {
      return U.fromRaw(this.rawSet.jointAnchor2(this.handle));
    }
    setAnchor1(t) {
      const e = U.intoRaw(t);
      this.rawSet.jointSetAnchor1(this.handle, e), e.free();
    }
    setAnchor2(t) {
      const e = U.intoRaw(t);
      this.rawSet.jointSetAnchor2(this.handle, e), e.free();
    }
    setContactsEnabled(t) {
      this.rawSet.jointSetContactsEnabled(this.handle, t);
    }
    contactsEnabled() {
      return this.rawSet.jointContactsEnabled(this.handle);
    }
  }
  class $a extends wn {
    limitsEnabled() {
      return this.rawSet.jointLimitsEnabled(this.handle, this.rawAxis());
    }
    limitsMin() {
      return this.rawSet.jointLimitsMin(this.handle, this.rawAxis());
    }
    limitsMax() {
      return this.rawSet.jointLimitsMax(this.handle, this.rawAxis());
    }
    setLimits(t, e) {
      this.rawSet.jointSetLimits(this.handle, this.rawAxis(), t, e);
    }
    configureMotorModel(t) {
      this.rawSet.jointConfigureMotorModel(this.handle, this.rawAxis(), t);
    }
    configureMotorVelocity(t, e) {
      this.rawSet.jointConfigureMotorVelocity(this.handle, this.rawAxis(), t, e);
    }
    configureMotorPosition(t, e, n) {
      this.rawSet.jointConfigureMotorPosition(this.handle, this.rawAxis(), t, e, n);
    }
    configureMotor(t, e, n, i) {
      this.rawSet.jointConfigureMotor(this.handle, this.rawAxis(), t, e, n, i);
    }
  }
  class Jc extends wn {
  }
  class Qc extends wn {
  }
  class tl extends wn {
  }
  class el extends $a {
    rawAxis() {
      return Wa.LinX;
    }
  }
  class nl extends $a {
    rawAxis() {
      return Wa.AngX;
    }
  }
  class il extends wn {
  }
  class rl extends wn {
  }
  class In {
    constructor() {
    }
    static fixed(t, e, n, i) {
      let s = new In();
      return s.anchor1 = t, s.anchor2 = n, s.frame1 = e, s.frame2 = i, s.jointType = ke.Fixed, s;
    }
    static spring(t, e, n, i, s) {
      let a = new In();
      return a.anchor1 = i, a.anchor2 = s, a.length = t, a.stiffness = e, a.damping = n, a.jointType = ke.Spring, a;
    }
    static rope(t, e, n) {
      let i = new In();
      return i.anchor1 = e, i.anchor2 = n, i.length = t, i.jointType = ke.Rope, i;
    }
    static generic(t, e, n, i) {
      let s = new In();
      return s.anchor1 = t, s.anchor2 = e, s.axis = n, s.axesMask = i, s.jointType = ke.Generic, s;
    }
    static spherical(t, e) {
      let n = new In();
      return n.anchor1 = t, n.anchor2 = e, n.jointType = ke.Spherical, n;
    }
    static prismatic(t, e, n) {
      let i = new In();
      return i.anchor1 = t, i.anchor2 = e, i.axis = n, i.jointType = ke.Prismatic, i;
    }
    static revolute(t, e, n) {
      let i = new In();
      return i.anchor1 = t, i.anchor2 = e, i.axis = n, i.jointType = ke.Revolute, i;
    }
    intoRaw() {
      let t = U.intoRaw(this.anchor1), e = U.intoRaw(this.anchor2), n, i, s = false, a = 0, o = 0;
      switch (this.jointType) {
        case ke.Fixed:
          let c = Ut.intoRaw(this.frame1), l = Ut.intoRaw(this.frame2);
          i = He.fixed(t, c, e, l), c.free(), l.free();
          break;
        case ke.Spring:
          i = He.spring(this.length, this.stiffness, this.damping, t, e);
          break;
        case ke.Rope:
          i = He.rope(this.length, t, e);
          break;
        case ke.Prismatic:
          n = U.intoRaw(this.axis), this.limitsEnabled && (s = true, a = this.limits[0], o = this.limits[1]), i = He.prismatic(t, e, n, s, a, o), n.free();
          break;
        case ke.Generic:
          n = U.intoRaw(this.axis);
          let h = this.axesMask;
          i = He.generic(t, e, n, h);
          break;
        case ke.Spherical:
          i = He.spherical(t, e);
          break;
        case ke.Revolute:
          n = U.intoRaw(this.axis), i = He.revolute(t, e, n), n.free();
          break;
      }
      return t.free(), e.free(), i;
    }
  }
  class sl {
    free() {
      this.raw && this.raw.free(), this.raw = void 0, this.map && this.map.clear(), this.map = void 0;
    }
    constructor(t) {
      this.raw = t || new ei(), this.map = new Za(), t && t.forEachJointHandle((e) => {
        this.map.set(e, wn.newTyped(t, null, e));
      });
    }
    finalizeDeserialization(t) {
      this.map.forEach((e) => e.finalizeDeserialization(t));
    }
    createJoint(t, e, n, i, s) {
      const a = e.intoRaw(), o = this.raw.createJoint(a, n, i, s);
      a.free();
      let c = wn.newTyped(this.raw, t, o);
      return this.map.set(o, c), c;
    }
    remove(t, e) {
      this.raw.remove(t, e), this.unmap(t);
    }
    forEachJointHandleAttachedToRigidBody(t, e) {
      this.raw.forEachJointAttachedToRigidBody(t, e);
    }
    unmap(t) {
      this.map.delete(t);
    }
    len() {
      return this.map.len();
    }
    contains(t) {
      return this.get(t) != null;
    }
    get(t) {
      return this.map.get(t);
    }
    forEach(t) {
      this.map.forEach(t);
    }
    getAll() {
      return this.map.getAll();
    }
  }
  class ri {
    constructor(t, e) {
      this.rawSet = t, this.handle = e;
    }
    static newTyped(t, e) {
      switch (t.jointType(e)) {
        case Sn.Revolute:
          return new cl(t, e);
        case Sn.Prismatic:
          return new ol(t, e);
        case Sn.Fixed:
          return new al(t, e);
        case Sn.Spherical:
          return new ll(t, e);
        default:
          return new ri(t, e);
      }
    }
    isValid() {
      return this.rawSet.contains(this.handle);
    }
    setContactsEnabled(t) {
      this.rawSet.jointSetContactsEnabled(this.handle, t);
    }
    contactsEnabled() {
      return this.rawSet.jointContactsEnabled(this.handle);
    }
  }
  class Ja extends ri {
  }
  class al extends ri {
  }
  class ol extends Ja {
    rawAxis() {
      return Wa.LinX;
    }
  }
  class cl extends Ja {
    rawAxis() {
      return Wa.AngX;
    }
  }
  class ll extends ri {
  }
  class hl {
    free() {
      this.raw && this.raw.free(), this.raw = void 0, this.map && this.map.clear(), this.map = void 0;
    }
    constructor(t) {
      this.raw = t || new ii(), this.map = new Za(), t && t.forEachJointHandle((e) => {
        this.map.set(e, ri.newTyped(this.raw, e));
      });
    }
    createJoint(t, e, n, i) {
      const s = t.intoRaw(), a = this.raw.createJoint(s, e, n, i);
      s.free();
      let o = ri.newTyped(this.raw, a);
      return this.map.set(a, o), o;
    }
    remove(t, e) {
      this.raw.remove(t, e), this.map.delete(t);
    }
    unmap(t) {
      this.map.delete(t);
    }
    len() {
      return this.map.len();
    }
    contains(t) {
      return this.get(t) != null;
    }
    get(t) {
      return this.map.get(t);
    }
    forEach(t) {
      this.map.forEach(t);
    }
    forEachJointHandleAttachedToRigidBody(t, e) {
      this.raw.forEachJointAttachedToRigidBody(t, e);
    }
    getAll() {
      return this.map.getAll();
    }
  }
  var Ir;
  (function(r) {
    r[r.Average = 0] = "Average", r[r.Min = 1] = "Min", r[r.Multiply = 2] = "Multiply", r[r.Max = 3] = "Max";
  })(Ir || (Ir = {}));
  class dl {
    free() {
      this.raw && this.raw.free(), this.raw = void 0;
    }
    constructor(t) {
      this.raw = t || new Rc();
    }
  }
  class ul {
    free() {
      this.raw && this.raw.free(), this.raw = void 0;
    }
    constructor(t) {
      this.raw = t || new ni();
    }
    forEachActiveRigidBodyHandle(t) {
      this.raw.forEachActiveRigidBodyHandle(t);
    }
  }
  var ki;
  (function(r) {
    r[r.Vertex = 0] = "Vertex", r[r.Edge = 1] = "Edge", r[r.Face = 2] = "Face", r[r.Unknown = 3] = "Unknown";
  })(ki || (ki = {}));
  class pl {
    constructor(t, e) {
      this.origin = t, this.dir = e;
    }
    pointAt(t) {
      return {
        x: this.origin.x + this.dir.x * t,
        y: this.origin.y + this.dir.y * t,
        z: this.origin.z + this.dir.z * t
      };
    }
  }
  class Br {
    constructor(t, e, n, i) {
      this.featureType = ki.Unknown, this.featureId = void 0, this.timeOfImpact = t, this.normal = e, i !== void 0 && (this.featureId = i), n !== void 0 && (this.featureType = n);
    }
    static fromRaw(t) {
      if (!t) return null;
      const e = new Br(t.time_of_impact(), U.fromRaw(t.normal()), t.featureType(), t.featureId());
      return t.free(), e;
    }
  }
  class Lr {
    constructor(t, e, n, i, s) {
      this.featureType = ki.Unknown, this.featureId = void 0, this.collider = t, this.timeOfImpact = e, this.normal = n, s !== void 0 && (this.featureId = s), i !== void 0 && (this.featureType = i);
    }
    static fromRaw(t, e) {
      if (!e) return null;
      const n = new Lr(t.get(e.colliderHandle()), e.time_of_impact(), U.fromRaw(e.normal()), e.featureType(), e.featureId());
      return e.free(), n;
    }
  }
  class Ss {
    constructor(t, e) {
      this.collider = t, this.timeOfImpact = e;
    }
    static fromRaw(t, e) {
      if (!e) return null;
      const n = new Ss(t.get(e.colliderHandle()), e.timeOfImpact());
      return e.free(), n;
    }
  }
  class zr {
    constructor(t, e) {
      this.point = t, this.isInside = e;
    }
    static fromRaw(t) {
      if (!t) return null;
      const e = new zr(U.fromRaw(t.point()), t.isInside());
      return t.free(), e;
    }
  }
  class Dr {
    constructor(t, e, n, i, s) {
      this.featureType = ki.Unknown, this.featureId = void 0, this.collider = t, this.point = e, this.isInside = n, s !== void 0 && (this.featureId = s), i !== void 0 && (this.featureType = i);
    }
    static fromRaw(t, e) {
      if (!e) return null;
      const n = new Dr(t.get(e.colliderHandle()), U.fromRaw(e.point()), e.isInside(), e.featureType(), e.featureId());
      return e.free(), n;
    }
  }
  class Vi {
    constructor(t, e, n, i, s) {
      this.time_of_impact = t, this.witness1 = e, this.witness2 = n, this.normal1 = i, this.normal2 = s;
    }
    static fromRaw(t, e) {
      if (!e) return null;
      const n = new Vi(e.time_of_impact(), U.fromRaw(e.witness1()), U.fromRaw(e.witness2()), U.fromRaw(e.normal1()), U.fromRaw(e.normal2()));
      return e.free(), n;
    }
  }
  class kr extends Vi {
    constructor(t, e, n, i, s, a) {
      super(e, n, i, s, a), this.collider = t;
    }
    static fromRaw(t, e) {
      if (!e) return null;
      const n = new kr(t.get(e.colliderHandle()), e.time_of_impact(), U.fromRaw(e.witness1()), U.fromRaw(e.witness2()), U.fromRaw(e.normal1()), U.fromRaw(e.normal2()));
      return e.free(), n;
    }
  }
  class fl {
    free() {
      this.raw && this.raw.free(), this.raw = void 0;
    }
    constructor(t) {
      this.raw = t || new ti();
    }
    castRay(t, e, n, i, s, a, o, c, l, h, d) {
      let u = U.intoRaw(i.origin), p = U.intoRaw(i.dir), w = Ss.fromRaw(n, this.raw.castRay(t.raw, e.raw, n.raw, u, p, s, a, o, c, l, h, d));
      return u.free(), p.free(), w;
    }
    castRayAndGetNormal(t, e, n, i, s, a, o, c, l, h, d) {
      let u = U.intoRaw(i.origin), p = U.intoRaw(i.dir), w = Lr.fromRaw(n, this.raw.castRayAndGetNormal(t.raw, e.raw, n.raw, u, p, s, a, o, c, l, h, d));
      return u.free(), p.free(), w;
    }
    intersectionsWithRay(t, e, n, i, s, a, o, c, l, h, d, u) {
      let p = U.intoRaw(i.origin), w = U.intoRaw(i.dir), b = (m) => o(Lr.fromRaw(n, m));
      this.raw.intersectionsWithRay(t.raw, e.raw, n.raw, p, w, s, a, b, c, l, h, d, u), p.free(), w.free();
    }
    intersectionWithShape(t, e, n, i, s, a, o, c, l, h, d) {
      let u = U.intoRaw(i), p = Ut.intoRaw(s), w = a.intoRaw(), b = this.raw.intersectionWithShape(t.raw, e.raw, n.raw, u, p, w, o, c, l, h, d);
      return u.free(), p.free(), w.free(), b;
    }
    projectPoint(t, e, n, i, s, a, o, c, l, h) {
      let d = U.intoRaw(i), u = Dr.fromRaw(n, this.raw.projectPoint(t.raw, e.raw, n.raw, d, s, a, o, c, l, h));
      return d.free(), u;
    }
    projectPointAndGetFeature(t, e, n, i, s, a, o, c, l) {
      let h = U.intoRaw(i), d = Dr.fromRaw(n, this.raw.projectPointAndGetFeature(t.raw, e.raw, n.raw, h, s, a, o, c, l));
      return h.free(), d;
    }
    intersectionsWithPoint(t, e, n, i, s, a, o, c, l, h) {
      let d = U.intoRaw(i);
      this.raw.intersectionsWithPoint(t.raw, e.raw, n.raw, d, s, a, o, c, l, h), d.free();
    }
    castShape(t, e, n, i, s, a, o, c, l, h, d, u, p, w, b) {
      let m = U.intoRaw(i), _ = Ut.intoRaw(s), E = U.intoRaw(a), v = o.intoRaw(), T = kr.fromRaw(n, this.raw.castShape(t.raw, e.raw, n.raw, m, _, E, v, c, l, h, d, u, p, w, b));
      return m.free(), _.free(), E.free(), v.free(), T;
    }
    intersectionsWithShape(t, e, n, i, s, a, o, c, l, h, d, u) {
      let p = U.intoRaw(i), w = Ut.intoRaw(s), b = a.intoRaw();
      this.raw.intersectionsWithShape(t.raw, e.raw, n.raw, p, w, b, o, c, l, h, d, u), p.free(), w.free(), b.free();
    }
    collidersWithAabbIntersectingAabb(t, e, n, i, s, a) {
      let o = U.intoRaw(i), c = U.intoRaw(s);
      this.raw.collidersWithAabbIntersectingAabb(t.raw, e.raw, n.raw, o, c, a), o.free(), c.free();
    }
  }
  class _l {
    free() {
      this.raw && this.raw.free(), this.raw = void 0;
    }
    constructor(t) {
      this.raw = t || new De(), this.tempManifold = new ml(null);
    }
    contactPairsWith(t, e) {
      this.raw.contact_pairs_with(t, e);
    }
    intersectionPairsWith(t, e) {
      this.raw.intersection_pairs_with(t, e);
    }
    contactPair(t, e, n) {
      const i = this.raw.contact_pair(t, e);
      if (i) {
        const s = i.collider1() != t;
        let a;
        for (a = 0; a < i.numContactManifolds(); ++a) this.tempManifold.raw = i.contactManifold(a), this.tempManifold.raw && n(this.tempManifold, s), this.tempManifold.free();
        i.free();
      }
    }
    intersectionPair(t, e) {
      return this.raw.intersection_pair(t, e);
    }
  }
  class ml {
    free() {
      this.raw && this.raw.free(), this.raw = void 0;
    }
    constructor(t) {
      this.raw = t;
    }
    normal() {
      return U.fromRaw(this.raw.normal());
    }
    localNormal1() {
      return U.fromRaw(this.raw.local_n1());
    }
    localNormal2() {
      return U.fromRaw(this.raw.local_n2());
    }
    subshape1() {
      return this.raw.subshape1();
    }
    subshape2() {
      return this.raw.subshape2();
    }
    numContacts() {
      return this.raw.num_contacts();
    }
    localContactPoint1(t) {
      return U.fromRaw(this.raw.contact_local_p1(t));
    }
    localContactPoint2(t) {
      return U.fromRaw(this.raw.contact_local_p2(t));
    }
    contactDist(t) {
      return this.raw.contact_dist(t);
    }
    contactFid1(t) {
      return this.raw.contact_fid1(t);
    }
    contactFid2(t) {
      return this.raw.contact_fid2(t);
    }
    contactImpulse(t) {
      return this.raw.contact_impulse(t);
    }
    contactTangentImpulseX(t) {
      return this.raw.contact_tangent_impulse_x(t);
    }
    contactTangentImpulseY(t) {
      return this.raw.contact_tangent_impulse_y(t);
    }
    numSolverContacts() {
      return this.raw.num_solver_contacts();
    }
    solverContactPoint(t) {
      return U.fromRaw(this.raw.solver_contact_point(t));
    }
    solverContactDist(t) {
      return this.raw.solver_contact_dist(t);
    }
    solverContactFriction(t) {
      return this.raw.solver_contact_friction(t);
    }
    solverContactRestitution(t) {
      return this.raw.solver_contact_restitution(t);
    }
    solverContactTangentVelocity(t) {
      return U.fromRaw(this.raw.solver_contact_tangent_velocity(t));
    }
  }
  class Hi {
    constructor(t, e, n, i, s) {
      this.distance = t, this.point1 = e, this.point2 = n, this.normal1 = i, this.normal2 = s;
    }
    static fromRaw(t) {
      if (!t) return null;
      const e = new Hi(t.distance(), U.fromRaw(t.point1()), U.fromRaw(t.point2()), U.fromRaw(t.normal1()), U.fromRaw(t.normal2()));
      return t.free(), e;
    }
  }
  class Ae {
    static fromRaw(t, e) {
      const n = t.coShapeType(e);
      let i, s, a, o, c, l, h;
      switch (n) {
        case ze.Ball:
          return new Qa(t.coRadius(e));
        case ze.Cuboid:
          return i = t.coHalfExtents(e), new to(i.x, i.y, i.z);
        case ze.RoundCuboid:
          return i = t.coHalfExtents(e), s = t.coRoundRadius(e), new eo(i.x, i.y, i.z, s);
        case ze.Capsule:
          return c = t.coHalfHeight(e), l = t.coRadius(e), new no(c, l);
        case ze.Segment:
          return a = t.coVertices(e), new io(U.new(a[0], a[1], a[2]), U.new(a[3], a[4], a[5]));
        case ze.Polyline:
          return a = t.coVertices(e), o = t.coIndices(e), new ao(a, o);
        case ze.Triangle:
          return a = t.coVertices(e), new ro(U.new(a[0], a[1], a[2]), U.new(a[3], a[4], a[5]), U.new(a[6], a[7], a[8]));
        case ze.RoundTriangle:
          return a = t.coVertices(e), s = t.coRoundRadius(e), new so(U.new(a[0], a[1], a[2]), U.new(a[3], a[4], a[5]), U.new(a[6], a[7], a[8]), s);
        case ze.HalfSpace:
          return h = U.fromRaw(t.coHalfspaceNormal(e)), new gl(h);
        case ze.Voxels:
          const d = t.coVoxelData(e), u = t.coVoxelSize(e);
          return new oo(d, u);
        case ze.TriMesh:
          a = t.coVertices(e), o = t.coIndices(e);
          const p = t.coTriMeshFlags(e);
          return new co(a, o, p);
        case ze.HeightField:
          const w = t.coHeightfieldScale(e), b = t.coHeightfieldHeights(e), m = t.coHeightfieldNRows(e), _ = t.coHeightfieldNCols(e), E = t.coHeightFieldFlags(e);
          return new lo(m, _, b, w, E);
        case ze.ConvexPolyhedron:
          return a = t.coVertices(e), o = t.coIndices(e), new fs(a, o);
        case ze.RoundConvexPolyhedron:
          return a = t.coVertices(e), o = t.coIndices(e), s = t.coRoundRadius(e), new _s(a, o, s);
        case ze.Cylinder:
          return c = t.coHalfHeight(e), l = t.coRadius(e), new ho(c, l);
        case ze.RoundCylinder:
          return c = t.coHalfHeight(e), l = t.coRadius(e), s = t.coRoundRadius(e), new uo(c, l, s);
        case ze.Cone:
          return c = t.coHalfHeight(e), l = t.coRadius(e), new po(c, l);
        case ze.RoundCone:
          return c = t.coHalfHeight(e), l = t.coRadius(e), s = t.coRoundRadius(e), new fo(c, l, s);
        default:
          throw new Error("unknown shape type: " + n);
      }
    }
    castShape(t, e, n, i, s, a, o, c, l, h) {
      let d = U.intoRaw(t), u = Ut.intoRaw(e), p = U.intoRaw(n), w = U.intoRaw(s), b = Ut.intoRaw(a), m = U.intoRaw(o), _ = this.intoRaw(), E = i.intoRaw(), v = Vi.fromRaw(null, _.castShape(d, u, p, E, w, b, m, c, l, h));
      return d.free(), u.free(), p.free(), w.free(), b.free(), m.free(), _.free(), E.free(), v;
    }
    intersectsShape(t, e, n, i, s) {
      let a = U.intoRaw(t), o = Ut.intoRaw(e), c = U.intoRaw(i), l = Ut.intoRaw(s), h = this.intoRaw(), d = n.intoRaw(), u = h.intersectsShape(a, o, d, c, l);
      return a.free(), o.free(), c.free(), l.free(), h.free(), d.free(), u;
    }
    contactShape(t, e, n, i, s, a) {
      let o = U.intoRaw(t), c = Ut.intoRaw(e), l = U.intoRaw(i), h = Ut.intoRaw(s), d = this.intoRaw(), u = n.intoRaw(), p = Hi.fromRaw(d.contactShape(o, c, u, l, h, a));
      return o.free(), c.free(), l.free(), h.free(), d.free(), u.free(), p;
    }
    containsPoint(t, e, n) {
      let i = U.intoRaw(t), s = Ut.intoRaw(e), a = U.intoRaw(n), o = this.intoRaw(), c = o.containsPoint(i, s, a);
      return i.free(), s.free(), a.free(), o.free(), c;
    }
    projectPoint(t, e, n, i) {
      let s = U.intoRaw(t), a = Ut.intoRaw(e), o = U.intoRaw(n), c = this.intoRaw(), l = zr.fromRaw(c.projectPoint(s, a, o, i));
      return s.free(), a.free(), o.free(), c.free(), l;
    }
    intersectsRay(t, e, n, i) {
      let s = U.intoRaw(e), a = Ut.intoRaw(n), o = U.intoRaw(t.origin), c = U.intoRaw(t.dir), l = this.intoRaw(), h = l.intersectsRay(s, a, o, c, i);
      return s.free(), a.free(), o.free(), c.free(), l.free(), h;
    }
    castRay(t, e, n, i, s) {
      let a = U.intoRaw(e), o = Ut.intoRaw(n), c = U.intoRaw(t.origin), l = U.intoRaw(t.dir), h = this.intoRaw(), d = h.castRay(a, o, c, l, i, s);
      return a.free(), o.free(), c.free(), l.free(), h.free(), d;
    }
    castRayAndGetNormal(t, e, n, i, s) {
      let a = U.intoRaw(e), o = Ut.intoRaw(n), c = U.intoRaw(t.origin), l = U.intoRaw(t.dir), h = this.intoRaw(), d = Br.fromRaw(h.castRayAndGetNormal(a, o, c, l, i, s));
      return a.free(), o.free(), c.free(), l.free(), h.free(), d;
    }
  }
  var Te;
  (function(r) {
    r[r.Ball = 0] = "Ball", r[r.Cuboid = 1] = "Cuboid", r[r.Capsule = 2] = "Capsule", r[r.Segment = 3] = "Segment", r[r.Polyline = 4] = "Polyline", r[r.Triangle = 5] = "Triangle", r[r.TriMesh = 6] = "TriMesh", r[r.HeightField = 7] = "HeightField", r[r.ConvexPolyhedron = 9] = "ConvexPolyhedron", r[r.Cylinder = 10] = "Cylinder", r[r.Cone = 11] = "Cone", r[r.RoundCuboid = 12] = "RoundCuboid", r[r.RoundTriangle = 13] = "RoundTriangle", r[r.RoundCylinder = 14] = "RoundCylinder", r[r.RoundCone = 15] = "RoundCone", r[r.RoundConvexPolyhedron = 16] = "RoundConvexPolyhedron", r[r.HalfSpace = 17] = "HalfSpace", r[r.Voxels = 18] = "Voxels";
  })(Te || (Te = {}));
  var Ca;
  (function(r) {
    r[r.FIX_INTERNAL_EDGES = 1] = "FIX_INTERNAL_EDGES";
  })(Ca || (Ca = {}));
  var Pa;
  (function(r) {
    r[r.DELETE_BAD_TOPOLOGY_TRIANGLES = 4] = "DELETE_BAD_TOPOLOGY_TRIANGLES", r[r.ORIENTED = 8] = "ORIENTED", r[r.MERGE_DUPLICATE_VERTICES = 16] = "MERGE_DUPLICATE_VERTICES", r[r.DELETE_DEGENERATE_TRIANGLES = 32] = "DELETE_DEGENERATE_TRIANGLES", r[r.DELETE_DUPLICATE_TRIANGLES = 64] = "DELETE_DUPLICATE_TRIANGLES", r[r.FIX_INTERNAL_EDGES = 144] = "FIX_INTERNAL_EDGES";
  })(Pa || (Pa = {}));
  class Qa extends Ae {
    constructor(t) {
      super(), this.type = Te.Ball, this.radius = t;
    }
    intoRaw() {
      return xt.ball(this.radius);
    }
  }
  class gl extends Ae {
    constructor(t) {
      super(), this.type = Te.HalfSpace, this.normal = t;
    }
    intoRaw() {
      let t = U.intoRaw(this.normal), e = xt.halfspace(t);
      return t.free(), e;
    }
  }
  class to extends Ae {
    constructor(t, e, n) {
      super(), this.type = Te.Cuboid, this.halfExtents = U.new(t, e, n);
    }
    intoRaw() {
      return xt.cuboid(this.halfExtents.x, this.halfExtents.y, this.halfExtents.z);
    }
  }
  class eo extends Ae {
    constructor(t, e, n, i) {
      super(), this.type = Te.RoundCuboid, this.halfExtents = U.new(t, e, n), this.borderRadius = i;
    }
    intoRaw() {
      return xt.roundCuboid(this.halfExtents.x, this.halfExtents.y, this.halfExtents.z, this.borderRadius);
    }
  }
  class no extends Ae {
    constructor(t, e) {
      super(), this.type = Te.Capsule, this.halfHeight = t, this.radius = e;
    }
    intoRaw() {
      return xt.capsule(this.halfHeight, this.radius);
    }
  }
  class io extends Ae {
    constructor(t, e) {
      super(), this.type = Te.Segment, this.a = t, this.b = e;
    }
    intoRaw() {
      let t = U.intoRaw(this.a), e = U.intoRaw(this.b), n = xt.segment(t, e);
      return t.free(), e.free(), n;
    }
  }
  class ro extends Ae {
    constructor(t, e, n) {
      super(), this.type = Te.Triangle, this.a = t, this.b = e, this.c = n;
    }
    intoRaw() {
      let t = U.intoRaw(this.a), e = U.intoRaw(this.b), n = U.intoRaw(this.c), i = xt.triangle(t, e, n);
      return t.free(), e.free(), n.free(), i;
    }
  }
  class so extends Ae {
    constructor(t, e, n, i) {
      super(), this.type = Te.RoundTriangle, this.a = t, this.b = e, this.c = n, this.borderRadius = i;
    }
    intoRaw() {
      let t = U.intoRaw(this.a), e = U.intoRaw(this.b), n = U.intoRaw(this.c), i = xt.roundTriangle(t, e, n, this.borderRadius);
      return t.free(), e.free(), n.free(), i;
    }
  }
  class ao extends Ae {
    constructor(t, e) {
      super(), this.type = Te.Polyline, this.vertices = t, this.indices = e ?? new Uint32Array(0);
    }
    intoRaw() {
      return xt.polyline(this.vertices, this.indices);
    }
  }
  class oo extends Ae {
    constructor(t, e) {
      super(), this.type = Te.Voxels, this.data = t, this.voxelSize = e;
    }
    intoRaw() {
      let t = U.intoRaw(this.voxelSize), e;
      return this.data instanceof Int32Array ? e = xt.voxels(t, this.data) : e = xt.voxelsFromPoints(t, this.data), t.free(), e;
    }
  }
  class co extends Ae {
    constructor(t, e, n) {
      super(), this.type = Te.TriMesh, this.vertices = t, this.indices = e, this.flags = n;
    }
    intoRaw() {
      return xt.trimesh(this.vertices, this.indices, this.flags);
    }
  }
  class fs extends Ae {
    constructor(t, e) {
      super(), this.type = Te.ConvexPolyhedron, this.vertices = t, this.indices = e;
    }
    intoRaw() {
      return this.indices ? xt.convexMesh(this.vertices, this.indices) : xt.convexHull(this.vertices);
    }
  }
  class _s extends Ae {
    constructor(t, e, n) {
      super(), this.type = Te.RoundConvexPolyhedron, this.vertices = t, this.indices = e, this.borderRadius = n;
    }
    intoRaw() {
      return this.indices ? xt.roundConvexMesh(this.vertices, this.indices, this.borderRadius) : xt.roundConvexHull(this.vertices, this.borderRadius);
    }
  }
  class lo extends Ae {
    constructor(t, e, n, i, s) {
      super(), this.type = Te.HeightField, this.nrows = t, this.ncols = e, this.heights = n, this.scale = i, this.flags = s;
    }
    intoRaw() {
      let t = U.intoRaw(this.scale), e = xt.heightfield(this.nrows, this.ncols, this.heights, t, this.flags);
      return t.free(), e;
    }
  }
  class ho extends Ae {
    constructor(t, e) {
      super(), this.type = Te.Cylinder, this.halfHeight = t, this.radius = e;
    }
    intoRaw() {
      return xt.cylinder(this.halfHeight, this.radius);
    }
  }
  class uo extends Ae {
    constructor(t, e, n) {
      super(), this.type = Te.RoundCylinder, this.borderRadius = n, this.halfHeight = t, this.radius = e;
    }
    intoRaw() {
      return xt.roundCylinder(this.halfHeight, this.radius, this.borderRadius);
    }
  }
  class po extends Ae {
    constructor(t, e) {
      super(), this.type = Te.Cone, this.halfHeight = t, this.radius = e;
    }
    intoRaw() {
      return xt.cone(this.halfHeight, this.radius);
    }
  }
  class fo extends Ae {
    constructor(t, e, n) {
      super(), this.type = Te.RoundCone, this.halfHeight = t, this.radius = e, this.borderRadius = n;
    }
    intoRaw() {
      return xt.roundCone(this.halfHeight, this.radius, this.borderRadius);
    }
  }
  class wl {
    free() {
      this.raw && this.raw.free(), this.raw = void 0;
    }
    constructor(t) {
      this.raw = t || new Vb();
    }
    step(t, e, n, i, s, a, o, c, l, h, d, u) {
      let p = U.intoRaw(t);
      d ? this.raw.stepWithEvents(p, e.raw, n.raw, i.raw, s.raw, a.raw, o.raw, c.raw, l.raw, h.raw, d.raw, u, u ? u.filterContactPair : null, u ? u.filterIntersectionPair : null) : this.raw.step(p, e.raw, n.raw, i.raw, s.raw, a.raw, o.raw, c.raw, l.raw, h.raw), p.free();
    }
  }
  class Ia {
    free() {
      this.raw && this.raw.free(), this.raw = void 0;
    }
    constructor(t) {
      this.raw = t || new jb();
    }
    serializeAll(t, e, n, i, s, a, o, c, l) {
      let h = U.intoRaw(t);
      const d = this.raw.serializeAll(h, e.raw, n.raw, i.raw, s.raw, a.raw, o.raw, c.raw, l.raw);
      return h.free(), d;
    }
    deserializeAll(t) {
      return _o.fromRaw(this.raw.deserializeAll(t));
    }
  }
  class bl {
    constructor(t, e) {
      this.vertices = t, this.colors = e;
    }
  }
  class yl {
    free() {
      this.raw && this.raw.free(), this.raw = void 0, this.vertices = void 0, this.colors = void 0;
    }
    constructor(t) {
      this.raw = t || new kb();
    }
    render(t, e, n, i, s, a, o) {
      this.raw.render(t.raw, e.raw, n.raw, i.raw, s.raw, a, e.castClosure(o)), this.vertices = this.raw.vertices(), this.colors = this.raw.colors();
    }
  }
  class vl {
  }
  class xl {
    constructor(t, e, n, i, s, a) {
      this.params = e, this.bodies = s, this.colliders = a, this.broadPhase = n, this.narrowPhase = i, this.raw = new Gb(t), this.rawCharacterCollision = new ip(), this._applyImpulsesToDynamicBodies = false, this._characterMass = null;
    }
    free() {
      this.raw && (this.raw.free(), this.rawCharacterCollision.free()), this.raw = void 0, this.rawCharacterCollision = void 0;
    }
    up() {
      return this.raw.up();
    }
    setUp(t) {
      let e = U.intoRaw(t);
      return this.raw.setUp(e);
    }
    applyImpulsesToDynamicBodies() {
      return this._applyImpulsesToDynamicBodies;
    }
    setApplyImpulsesToDynamicBodies(t) {
      this._applyImpulsesToDynamicBodies = t;
    }
    characterMass() {
      return this._characterMass;
    }
    setCharacterMass(t) {
      this._characterMass = t;
    }
    offset() {
      return this.raw.offset();
    }
    setOffset(t) {
      this.raw.setOffset(t);
    }
    normalNudgeFactor() {
      return this.raw.normalNudgeFactor();
    }
    setNormalNudgeFactor(t) {
      this.raw.setNormalNudgeFactor(t);
    }
    slideEnabled() {
      return this.raw.slideEnabled();
    }
    setSlideEnabled(t) {
      this.raw.setSlideEnabled(t);
    }
    autostepMaxHeight() {
      return this.raw.autostepMaxHeight();
    }
    autostepMinWidth() {
      return this.raw.autostepMinWidth();
    }
    autostepIncludesDynamicBodies() {
      return this.raw.autostepIncludesDynamicBodies();
    }
    autostepEnabled() {
      return this.raw.autostepEnabled();
    }
    enableAutostep(t, e, n) {
      this.raw.enableAutostep(t, e, n);
    }
    disableAutostep() {
      return this.raw.disableAutostep();
    }
    maxSlopeClimbAngle() {
      return this.raw.maxSlopeClimbAngle();
    }
    setMaxSlopeClimbAngle(t) {
      this.raw.setMaxSlopeClimbAngle(t);
    }
    minSlopeSlideAngle() {
      return this.raw.minSlopeSlideAngle();
    }
    setMinSlopeSlideAngle(t) {
      this.raw.setMinSlopeSlideAngle(t);
    }
    snapToGroundDistance() {
      return this.raw.snapToGroundDistance();
    }
    enableSnapToGround(t) {
      this.raw.enableSnapToGround(t);
    }
    disableSnapToGround() {
      this.raw.disableSnapToGround();
    }
    snapToGroundEnabled() {
      return this.raw.snapToGroundEnabled();
    }
    computeColliderMovement(t, e, n, i, s) {
      let a = U.intoRaw(e);
      this.raw.computeColliderMovement(this.params.dt, this.broadPhase.raw, this.narrowPhase.raw, this.bodies.raw, this.colliders.raw, t.handle, a, this._applyImpulsesToDynamicBodies, this._characterMass, n, i, this.colliders.castClosure(s)), a.free();
    }
    computedMovement() {
      return U.fromRaw(this.raw.computedMovement());
    }
    computedGrounded() {
      return this.raw.computedGrounded();
    }
    numComputedCollisions() {
      return this.raw.numComputedCollisions();
    }
    computedCollision(t, e) {
      if (this.raw.computedCollision(t, this.rawCharacterCollision)) {
        let n = this.rawCharacterCollision;
        return e = e ?? new vl(), e.translationDeltaApplied = U.fromRaw(n.translationDeltaApplied()), e.translationDeltaRemaining = U.fromRaw(n.translationDeltaRemaining()), e.toi = n.toi(), e.witness1 = U.fromRaw(n.worldWitness1()), e.witness2 = U.fromRaw(n.worldWitness2()), e.normal1 = U.fromRaw(n.worldNormal1()), e.normal2 = U.fromRaw(n.worldNormal2()), e.collider = this.colliders.get(n.handle()), e;
      } else return null;
    }
  }
  var La;
  (function(r) {
    r[r.None = 0] = "None", r[r.LinX = 1] = "LinX", r[r.LinY = 2] = "LinY", r[r.LinZ = 4] = "LinZ", r[r.AngX = 8] = "AngX", r[r.AngY = 16] = "AngY", r[r.AngZ = 32] = "AngZ", r[r.AllLin = 7] = "AllLin", r[r.AllAng = 56] = "AllAng", r[r.All = 63] = "All";
  })(La || (La = {}));
  class Sl {
    constructor(t, e, n, i, s, a) {
      this.params = t, this.bodies = e, this.raw = new Wb(n, i, s, a);
    }
    free() {
      this.raw && this.raw.free(), this.raw = void 0;
    }
    setKp(t, e) {
      this.raw.set_kp(t, e);
    }
    setKi(t, e) {
      this.raw.set_kp(t, e);
    }
    setKd(t, e) {
      this.raw.set_kp(t, e);
    }
    setAxes(t) {
      this.raw.set_axes_mask(t);
    }
    resetIntegrals() {
      this.raw.reset_integrals();
    }
    applyLinearCorrection(t, e, n) {
      let i = U.intoRaw(e), s = U.intoRaw(n);
      this.raw.apply_linear_correction(this.params.dt, this.bodies.raw, t.handle, i, s), i.free(), s.free();
    }
    applyAngularCorrection(t, e, n) {
      let i = Ut.intoRaw(e), s = U.intoRaw(n);
      this.raw.apply_angular_correction(this.params.dt, this.bodies.raw, t.handle, i, s), i.free(), s.free();
    }
    linearCorrection(t, e, n) {
      let i = U.intoRaw(e), s = U.intoRaw(n), a = this.raw.linear_correction(this.params.dt, this.bodies.raw, t.handle, i, s);
      return i.free(), s.free(), U.fromRaw(a);
    }
    angularCorrection(t, e, n) {
      let i = Ut.intoRaw(e), s = U.intoRaw(n), a = this.raw.angular_correction(this.params.dt, this.bodies.raw, t.handle, i, s);
      return i.free(), s.free(), U.fromRaw(a);
    }
  }
  class Ml {
    constructor(t, e, n, i, s) {
      this.raw = new Hb(t.handle), this.broadPhase = e, this.narrowPhase = n, this.bodies = i, this.colliders = s, this._chassis = t;
    }
    free() {
      this.raw && this.raw.free(), this.raw = void 0;
    }
    updateVehicle(t, e, n, i) {
      this.raw.update_vehicle(t, this.broadPhase.raw, this.narrowPhase.raw, this.bodies.raw, this.colliders.raw, e, n, this.colliders.castClosure(i));
    }
    currentVehicleSpeed() {
      return this.raw.current_vehicle_speed();
    }
    chassis() {
      return this._chassis;
    }
    get indexUpAxis() {
      return this.raw.index_up_axis();
    }
    set indexUpAxis(t) {
      this.raw.set_index_up_axis(t);
    }
    get indexForwardAxis() {
      return this.raw.index_forward_axis();
    }
    set setIndexForwardAxis(t) {
      this.raw.set_index_forward_axis(t);
    }
    addWheel(t, e, n, i, s) {
      let a = U.intoRaw(t), o = U.intoRaw(e), c = U.intoRaw(n);
      this.raw.add_wheel(a, o, c, i, s), a.free(), o.free(), c.free();
    }
    numWheels() {
      return this.raw.num_wheels();
    }
    wheelChassisConnectionPointCs(t) {
      return U.fromRaw(this.raw.wheel_chassis_connection_point_cs(t));
    }
    setWheelChassisConnectionPointCs(t, e) {
      let n = U.intoRaw(e);
      this.raw.set_wheel_chassis_connection_point_cs(t, n), n.free();
    }
    wheelSuspensionRestLength(t) {
      return this.raw.wheel_suspension_rest_length(t);
    }
    setWheelSuspensionRestLength(t, e) {
      this.raw.set_wheel_suspension_rest_length(t, e);
    }
    wheelMaxSuspensionTravel(t) {
      return this.raw.wheel_max_suspension_travel(t);
    }
    setWheelMaxSuspensionTravel(t, e) {
      this.raw.set_wheel_max_suspension_travel(t, e);
    }
    wheelRadius(t) {
      return this.raw.wheel_radius(t);
    }
    setWheelRadius(t, e) {
      this.raw.set_wheel_radius(t, e);
    }
    wheelSuspensionStiffness(t) {
      return this.raw.wheel_suspension_stiffness(t);
    }
    setWheelSuspensionStiffness(t, e) {
      this.raw.set_wheel_suspension_stiffness(t, e);
    }
    wheelSuspensionCompression(t) {
      return this.raw.wheel_suspension_compression(t);
    }
    setWheelSuspensionCompression(t, e) {
      this.raw.set_wheel_suspension_compression(t, e);
    }
    wheelSuspensionRelaxation(t) {
      return this.raw.wheel_suspension_relaxation(t);
    }
    setWheelSuspensionRelaxation(t, e) {
      this.raw.set_wheel_suspension_relaxation(t, e);
    }
    wheelMaxSuspensionForce(t) {
      return this.raw.wheel_max_suspension_force(t);
    }
    setWheelMaxSuspensionForce(t, e) {
      this.raw.set_wheel_max_suspension_force(t, e);
    }
    wheelBrake(t) {
      return this.raw.wheel_brake(t);
    }
    setWheelBrake(t, e) {
      this.raw.set_wheel_brake(t, e);
    }
    wheelSteering(t) {
      return this.raw.wheel_steering(t);
    }
    setWheelSteering(t, e) {
      this.raw.set_wheel_steering(t, e);
    }
    wheelEngineForce(t) {
      return this.raw.wheel_engine_force(t);
    }
    setWheelEngineForce(t, e) {
      this.raw.set_wheel_engine_force(t, e);
    }
    wheelDirectionCs(t) {
      return U.fromRaw(this.raw.wheel_direction_cs(t));
    }
    setWheelDirectionCs(t, e) {
      let n = U.intoRaw(e);
      this.raw.set_wheel_direction_cs(t, n), n.free();
    }
    wheelAxleCs(t) {
      return U.fromRaw(this.raw.wheel_axle_cs(t));
    }
    setWheelAxleCs(t, e) {
      let n = U.intoRaw(e);
      this.raw.set_wheel_axle_cs(t, n), n.free();
    }
    wheelFrictionSlip(t) {
      return this.raw.wheel_friction_slip(t);
    }
    setWheelFrictionSlip(t, e) {
      this.raw.set_wheel_friction_slip(t, e);
    }
    wheelSideFrictionStiffness(t) {
      return this.raw.wheel_side_friction_stiffness(t);
    }
    setWheelSideFrictionStiffness(t, e) {
      this.raw.set_wheel_side_friction_stiffness(t, e);
    }
    wheelRotation(t) {
      return this.raw.wheel_rotation(t);
    }
    wheelForwardImpulse(t) {
      return this.raw.wheel_forward_impulse(t);
    }
    wheelSideImpulse(t) {
      return this.raw.wheel_side_impulse(t);
    }
    wheelSuspensionForce(t) {
      return this.raw.wheel_suspension_force(t);
    }
    wheelContactNormal(t) {
      return U.fromRaw(this.raw.wheel_contact_normal_ws(t));
    }
    wheelContactPoint(t) {
      return U.fromRaw(this.raw.wheel_contact_point_ws(t));
    }
    wheelSuspensionLength(t) {
      return this.raw.wheel_suspension_length(t);
    }
    wheelHardPoint(t) {
      return U.fromRaw(this.raw.wheel_hard_point_ws(t));
    }
    wheelIsInContact(t) {
      return this.raw.wheel_is_in_contact(t);
    }
    wheelGroundObject(t) {
      return this.colliders.get(this.raw.wheel_ground_object(t));
    }
  }
  let _o = class sp {
    free() {
      this.integrationParameters.free(), this.islands.free(), this.broadPhase.free(), this.narrowPhase.free(), this.bodies.free(), this.colliders.free(), this.impulseJoints.free(), this.multibodyJoints.free(), this.ccdSolver.free(), this.physicsPipeline.free(), this.serializationPipeline.free(), this.debugRenderPipeline.free(), this.characterControllers.forEach((t) => t.free()), this.pidControllers.forEach((t) => t.free()), this.vehicleControllers.forEach((t) => t.free()), this.integrationParameters = void 0, this.islands = void 0, this.broadPhase = void 0, this.narrowPhase = void 0, this.bodies = void 0, this.colliders = void 0, this.ccdSolver = void 0, this.impulseJoints = void 0, this.multibodyJoints = void 0, this.physicsPipeline = void 0, this.serializationPipeline = void 0, this.debugRenderPipeline = void 0, this.characterControllers = void 0, this.pidControllers = void 0, this.vehicleControllers = void 0;
    }
    constructor(t, e, n, i, s, a, o, c, l, h, d, u, p) {
      this.gravity = t, this.integrationParameters = new $c(e), this.islands = new ul(n), this.broadPhase = new fl(i), this.narrowPhase = new _l(s), this.bodies = new Zc(a), this.colliders = new Tl(o), this.impulseJoints = new sl(c), this.multibodyJoints = new hl(l), this.ccdSolver = new dl(h), this.physicsPipeline = new wl(d), this.serializationPipeline = new Ia(u), this.debugRenderPipeline = new yl(p), this.characterControllers = /* @__PURE__ */ new Set(), this.pidControllers = /* @__PURE__ */ new Set(), this.vehicleControllers = /* @__PURE__ */ new Set(), this.impulseJoints.finalizeDeserialization(this.bodies), this.bodies.finalizeDeserialization(this.colliders), this.colliders.finalizeDeserialization(this.bodies);
    }
    static fromRaw(t) {
      return t ? new sp(U.fromRaw(t.takeGravity()), t.takeIntegrationParameters(), t.takeIslandManager(), t.takeBroadPhase(), t.takeNarrowPhase(), t.takeBodies(), t.takeColliders(), t.takeImpulseJoints(), t.takeMultibodyJoints()) : null;
    }
    takeSnapshot() {
      return this.serializationPipeline.serializeAll(this.gravity, this.integrationParameters, this.islands, this.broadPhase, this.narrowPhase, this.bodies, this.colliders, this.impulseJoints, this.multibodyJoints);
    }
    static restoreSnapshot(t) {
      return new Ia().deserializeAll(t);
    }
    debugRender(t, e) {
      return this.debugRenderPipeline.render(this.bodies, this.colliders, this.impulseJoints, this.multibodyJoints, this.narrowPhase, t, e), new bl(this.debugRenderPipeline.vertices, this.debugRenderPipeline.colors);
    }
    step(t, e) {
      this.physicsPipeline.step(this.gravity, this.integrationParameters, this.islands, this.broadPhase, this.narrowPhase, this.bodies, this.colliders, this.impulseJoints, this.multibodyJoints, this.ccdSolver, t, e);
    }
    propagateModifiedBodyPositionsToColliders() {
      this.bodies.raw.propagateModifiedBodyPositionsToColliders(this.colliders.raw);
    }
    get timestep() {
      return this.integrationParameters.dt;
    }
    set timestep(t) {
      this.integrationParameters.dt = t;
    }
    get lengthUnit() {
      return this.integrationParameters.lengthUnit;
    }
    set lengthUnit(t) {
      this.integrationParameters.lengthUnit = t;
    }
    get numSolverIterations() {
      return this.integrationParameters.numSolverIterations;
    }
    set numSolverIterations(t) {
      this.integrationParameters.numSolverIterations = t;
    }
    get numInternalPgsIterations() {
      return this.integrationParameters.numInternalPgsIterations;
    }
    set numInternalPgsIterations(t) {
      this.integrationParameters.numInternalPgsIterations = t;
    }
    get maxCcdSubsteps() {
      return this.integrationParameters.maxCcdSubsteps;
    }
    set maxCcdSubsteps(t) {
      this.integrationParameters.maxCcdSubsteps = t;
    }
    createRigidBody(t) {
      return this.bodies.createRigidBody(this.colliders, t);
    }
    createCharacterController(t) {
      let e = new xl(t, this.integrationParameters, this.broadPhase, this.narrowPhase, this.bodies, this.colliders);
      return this.characterControllers.add(e), e;
    }
    removeCharacterController(t) {
      this.characterControllers.delete(t), t.free();
    }
    createPidController(t, e, n, i) {
      let s = new Sl(this.integrationParameters, this.bodies, t, e, n, i);
      return this.pidControllers.add(s), s;
    }
    removePidController(t) {
      this.pidControllers.delete(t), t.free();
    }
    createVehicleController(t) {
      let e = new Ml(t, this.broadPhase, this.narrowPhase, this.bodies, this.colliders);
      return this.vehicleControllers.add(e), e;
    }
    removeVehicleController(t) {
      this.vehicleControllers.delete(t), t.free();
    }
    createCollider(t, e) {
      let n = e ? e.handle : void 0;
      return this.colliders.createCollider(this.bodies, t, n);
    }
    createImpulseJoint(t, e, n, i) {
      return this.impulseJoints.createJoint(this.bodies, t, e.handle, n.handle, i);
    }
    createMultibodyJoint(t, e, n, i) {
      return this.multibodyJoints.createJoint(t, e.handle, n.handle, i);
    }
    getRigidBody(t) {
      return this.bodies.get(t);
    }
    getCollider(t) {
      return this.colliders.get(t);
    }
    getImpulseJoint(t) {
      return this.impulseJoints.get(t);
    }
    getMultibodyJoint(t) {
      return this.multibodyJoints.get(t);
    }
    removeRigidBody(t) {
      this.bodies && this.bodies.remove(t.handle, this.islands, this.colliders, this.impulseJoints, this.multibodyJoints);
    }
    removeCollider(t, e) {
      this.colliders && this.colliders.remove(t.handle, this.islands, this.bodies, e);
    }
    removeImpulseJoint(t, e) {
      this.impulseJoints && this.impulseJoints.remove(t.handle, e);
    }
    removeMultibodyJoint(t, e) {
      this.impulseJoints && this.multibodyJoints.remove(t.handle, e);
    }
    forEachCollider(t) {
      this.colliders.forEach(t);
    }
    forEachRigidBody(t) {
      this.bodies.forEach(t);
    }
    forEachActiveRigidBody(t) {
      this.bodies.forEachActiveRigidBody(this.islands, t);
    }
    castRay(t, e, n, i, s, a, o, c) {
      return this.broadPhase.castRay(this.narrowPhase, this.bodies, this.colliders, t, e, n, i, s, a ? a.handle : null, o ? o.handle : null, this.colliders.castClosure(c));
    }
    castRayAndGetNormal(t, e, n, i, s, a, o, c) {
      return this.broadPhase.castRayAndGetNormal(this.narrowPhase, this.bodies, this.colliders, t, e, n, i, s, a ? a.handle : null, o ? o.handle : null, this.colliders.castClosure(c));
    }
    intersectionsWithRay(t, e, n, i, s, a, o, c, l) {
      this.broadPhase.intersectionsWithRay(this.narrowPhase, this.bodies, this.colliders, t, e, n, i, s, a, o ? o.handle : null, c ? c.handle : null, this.colliders.castClosure(l));
    }
    intersectionWithShape(t, e, n, i, s, a, o, c) {
      let l = this.broadPhase.intersectionWithShape(this.narrowPhase, this.bodies, this.colliders, t, e, n, i, s, a ? a.handle : null, o ? o.handle : null, this.colliders.castClosure(c));
      return l != null ? this.colliders.get(l) : null;
    }
    projectPoint(t, e, n, i, s, a, o) {
      return this.broadPhase.projectPoint(this.narrowPhase, this.bodies, this.colliders, t, e, n, i, s ? s.handle : null, a ? a.handle : null, this.colliders.castClosure(o));
    }
    projectPointAndGetFeature(t, e, n, i, s, a) {
      return this.broadPhase.projectPointAndGetFeature(this.narrowPhase, this.bodies, this.colliders, t, e, n, i ? i.handle : null, s ? s.handle : null, this.colliders.castClosure(a));
    }
    intersectionsWithPoint(t, e, n, i, s, a, o) {
      this.broadPhase.intersectionsWithPoint(this.narrowPhase, this.bodies, this.colliders, t, this.colliders.castClosure(e), n, i, s ? s.handle : null, a ? a.handle : null, this.colliders.castClosure(o));
    }
    castShape(t, e, n, i, s, a, o, c, l, h, d, u) {
      return this.broadPhase.castShape(this.narrowPhase, this.bodies, this.colliders, t, e, n, i, s, a, o, c, l, h ? h.handle : null, d ? d.handle : null, this.colliders.castClosure(u));
    }
    intersectionsWithShape(t, e, n, i, s, a, o, c, l) {
      this.broadPhase.intersectionsWithShape(this.narrowPhase, this.bodies, this.colliders, t, e, n, this.colliders.castClosure(i), s, a, o ? o.handle : null, c ? c.handle : null, this.colliders.castClosure(l));
    }
    collidersWithAabbIntersectingAabb(t, e, n) {
      this.broadPhase.collidersWithAabbIntersectingAabb(this.narrowPhase, this.bodies, this.colliders, t, e, this.colliders.castClosure(n));
    }
    contactPairsWith(t, e) {
      this.narrowPhase.contactPairsWith(t.handle, this.colliders.castClosure(e));
    }
    intersectionPairsWith(t, e) {
      this.narrowPhase.intersectionPairsWith(t.handle, this.colliders.castClosure(e));
    }
    contactPair(t, e, n) {
      this.narrowPhase.contactPair(t.handle, e.handle, n);
    }
    intersectionPair(t, e) {
      return this.narrowPhase.intersectionPair(t.handle, e.handle);
    }
    set profilerEnabled(t) {
      this.physicsPipeline.raw.set_profiler_enabled(t);
    }
    get profilerEnabled() {
      return this.physicsPipeline.raw.is_profiler_enabled();
    }
    timingStep() {
      return this.physicsPipeline.raw.timing_step();
    }
    timingCollisionDetection() {
      return this.physicsPipeline.raw.timing_collision_detection();
    }
    timingBroadPhase() {
      return this.physicsPipeline.raw.timing_broad_phase();
    }
    timingNarrowPhase() {
      return this.physicsPipeline.raw.timing_narrow_phase();
    }
    timingSolver() {
      return this.physicsPipeline.raw.timing_solver();
    }
    timingVelocityAssembly() {
      return this.physicsPipeline.raw.timing_velocity_assembly();
    }
    timingVelocityResolution() {
      return this.physicsPipeline.raw.timing_velocity_resolution();
    }
    timingVelocityUpdate() {
      return this.physicsPipeline.raw.timing_velocity_update();
    }
    timingVelocityWriteback() {
      return this.physicsPipeline.raw.timing_velocity_writeback();
    }
    timingCcd() {
      return this.physicsPipeline.raw.timing_ccd();
    }
    timingCcdToiComputation() {
      return this.physicsPipeline.raw.timing_ccd_toi_computation();
    }
    timingCcdBroadPhase() {
      return this.physicsPipeline.raw.timing_ccd_broad_phase();
    }
    timingCcdNarrowPhase() {
      return this.physicsPipeline.raw.timing_ccd_narrow_phase();
    }
    timingCcdSolver() {
      return this.physicsPipeline.raw.timing_ccd_solver();
    }
    timingIslandConstruction() {
      return this.physicsPipeline.raw.timing_island_construction();
    }
    timingUserChanges() {
      return this.physicsPipeline.raw.timing_user_changes();
    }
  };
  var ms;
  (function(r) {
    r[r.NONE = 0] = "NONE", r[r.COLLISION_EVENTS = 1] = "COLLISION_EVENTS", r[r.CONTACT_FORCE_EVENTS = 2] = "CONTACT_FORCE_EVENTS";
  })(ms || (ms = {}));
  class El {
    free() {
      this.raw && this.raw.free(), this.raw = void 0;
    }
    collider1() {
      return this.raw.collider1();
    }
    collider2() {
      return this.raw.collider2();
    }
    totalForce() {
      return U.fromRaw(this.raw.total_force());
    }
    totalForceMagnitude() {
      return this.raw.total_force_magnitude();
    }
    maxForceDirection() {
      return U.fromRaw(this.raw.max_force_direction());
    }
    maxForceMagnitude() {
      return this.raw.max_force_magnitude();
    }
  }
  class ap {
    constructor(t, e) {
      this.raw = e || new rp(t);
    }
    free() {
      this.raw && this.raw.free(), this.raw = void 0;
    }
    drainCollisionEvents(t) {
      this.raw.drainCollisionEvents(t);
    }
    drainContactForceEvents(t) {
      let e = new El();
      this.raw.drainContactForceEvents((n) => {
        e.raw = n, t(e), e.free();
      });
    }
    clear() {
      this.raw.clear();
    }
  }
  var gs;
  (function(r) {
    r[r.NONE = 0] = "NONE", r[r.FILTER_CONTACT_PAIRS = 1] = "FILTER_CONTACT_PAIRS", r[r.FILTER_INTERSECTION_PAIRS = 2] = "FILTER_INTERSECTION_PAIRS";
  })(gs || (gs = {}));
  var Da;
  (function(r) {
    r[r.EMPTY = 0] = "EMPTY", r[r.COMPUTE_IMPULSE = 1] = "COMPUTE_IMPULSE";
  })(Da || (Da = {}));
  var Na;
  (function(r) {
    r[r.EXCLUDE_FIXED = 1] = "EXCLUDE_FIXED", r[r.EXCLUDE_KINEMATIC = 2] = "EXCLUDE_KINEMATIC", r[r.EXCLUDE_DYNAMIC = 4] = "EXCLUDE_DYNAMIC", r[r.EXCLUDE_SENSORS = 8] = "EXCLUDE_SENSORS", r[r.EXCLUDE_SOLIDS = 16] = "EXCLUDE_SOLIDS", r[r.ONLY_DYNAMIC = 3] = "ONLY_DYNAMIC", r[r.ONLY_KINEMATIC = 5] = "ONLY_KINEMATIC", r[r.ONLY_FIXED = 6] = "ONLY_FIXED";
  })(Na || (Na = {}));
  var ws;
  (function(r) {
    r[r.DYNAMIC_DYNAMIC = 1] = "DYNAMIC_DYNAMIC", r[r.DYNAMIC_KINEMATIC = 12] = "DYNAMIC_KINEMATIC", r[r.DYNAMIC_FIXED = 2] = "DYNAMIC_FIXED", r[r.KINEMATIC_KINEMATIC = 52224] = "KINEMATIC_KINEMATIC", r[r.KINEMATIC_FIXED = 8704] = "KINEMATIC_FIXED", r[r.FIXED_FIXED = 32] = "FIXED_FIXED", r[r.DEFAULT = 15] = "DEFAULT", r[r.ALL = 60943] = "ALL";
  })(ws || (ws = {}));
  class Ua {
    constructor(t, e, n, i) {
      this.colliderSet = t, this.handle = e, this._parent = n, this._shape = i;
    }
    finalizeDeserialization(t) {
      this.handle != null && (this._parent = t.get(this.colliderSet.raw.coParent(this.handle)));
    }
    ensureShapeIsCached() {
      this._shape || (this._shape = Ae.fromRaw(this.colliderSet.raw, this.handle));
    }
    get shape() {
      return this.ensureShapeIsCached(), this._shape;
    }
    clearShapeCache() {
      this._shape = null;
    }
    isValid() {
      return this.colliderSet.raw.contains(this.handle);
    }
    translation() {
      return U.fromRaw(this.colliderSet.raw.coTranslation(this.handle));
    }
    translationWrtParent() {
      return U.fromRaw(this.colliderSet.raw.coTranslationWrtParent(this.handle));
    }
    rotation() {
      return Ut.fromRaw(this.colliderSet.raw.coRotation(this.handle));
    }
    rotationWrtParent() {
      return Ut.fromRaw(this.colliderSet.raw.coRotationWrtParent(this.handle));
    }
    isSensor() {
      return this.colliderSet.raw.coIsSensor(this.handle);
    }
    setSensor(t) {
      this.colliderSet.raw.coSetSensor(this.handle, t);
    }
    setShape(t) {
      let e = t.intoRaw();
      this.colliderSet.raw.coSetShape(this.handle, e), e.free(), this._shape = t;
    }
    setEnabled(t) {
      this.colliderSet.raw.coSetEnabled(this.handle, t);
    }
    isEnabled() {
      return this.colliderSet.raw.coIsEnabled(this.handle);
    }
    setRestitution(t) {
      this.colliderSet.raw.coSetRestitution(this.handle, t);
    }
    setFriction(t) {
      this.colliderSet.raw.coSetFriction(this.handle, t);
    }
    frictionCombineRule() {
      return this.colliderSet.raw.coFrictionCombineRule(this.handle);
    }
    setFrictionCombineRule(t) {
      this.colliderSet.raw.coSetFrictionCombineRule(this.handle, t);
    }
    restitutionCombineRule() {
      return this.colliderSet.raw.coRestitutionCombineRule(this.handle);
    }
    setRestitutionCombineRule(t) {
      this.colliderSet.raw.coSetRestitutionCombineRule(this.handle, t);
    }
    setCollisionGroups(t) {
      this.colliderSet.raw.coSetCollisionGroups(this.handle, t);
    }
    setSolverGroups(t) {
      this.colliderSet.raw.coSetSolverGroups(this.handle, t);
    }
    contactSkin() {
      return this.colliderSet.raw.coContactSkin(this.handle);
    }
    setContactSkin(t) {
      return this.colliderSet.raw.coSetContactSkin(this.handle, t);
    }
    activeHooks() {
      return this.colliderSet.raw.coActiveHooks(this.handle);
    }
    setActiveHooks(t) {
      this.colliderSet.raw.coSetActiveHooks(this.handle, t);
    }
    activeEvents() {
      return this.colliderSet.raw.coActiveEvents(this.handle);
    }
    setActiveEvents(t) {
      this.colliderSet.raw.coSetActiveEvents(this.handle, t);
    }
    activeCollisionTypes() {
      return this.colliderSet.raw.coActiveCollisionTypes(this.handle);
    }
    setContactForceEventThreshold(t) {
      return this.colliderSet.raw.coSetContactForceEventThreshold(this.handle, t);
    }
    contactForceEventThreshold() {
      return this.colliderSet.raw.coContactForceEventThreshold(this.handle);
    }
    setActiveCollisionTypes(t) {
      this.colliderSet.raw.coSetActiveCollisionTypes(this.handle, t);
    }
    setDensity(t) {
      this.colliderSet.raw.coSetDensity(this.handle, t);
    }
    setMass(t) {
      this.colliderSet.raw.coSetMass(this.handle, t);
    }
    setMassProperties(t, e, n, i) {
      let s = U.intoRaw(e), a = U.intoRaw(n), o = Ut.intoRaw(i);
      this.colliderSet.raw.coSetMassProperties(this.handle, t, s, a, o), s.free(), a.free(), o.free();
    }
    setTranslation(t) {
      this.colliderSet.raw.coSetTranslation(this.handle, t.x, t.y, t.z);
    }
    setTranslationWrtParent(t) {
      this.colliderSet.raw.coSetTranslationWrtParent(this.handle, t.x, t.y, t.z);
    }
    setRotation(t) {
      this.colliderSet.raw.coSetRotation(this.handle, t.x, t.y, t.z, t.w);
    }
    setRotationWrtParent(t) {
      this.colliderSet.raw.coSetRotationWrtParent(this.handle, t.x, t.y, t.z, t.w);
    }
    shapeType() {
      return this.colliderSet.raw.coShapeType(this.handle);
    }
    halfExtents() {
      return U.fromRaw(this.colliderSet.raw.coHalfExtents(this.handle));
    }
    setHalfExtents(t) {
      const e = U.intoRaw(t);
      this.colliderSet.raw.coSetHalfExtents(this.handle, e);
    }
    radius() {
      return this.colliderSet.raw.coRadius(this.handle);
    }
    setRadius(t) {
      this.colliderSet.raw.coSetRadius(this.handle, t);
    }
    roundRadius() {
      return this.colliderSet.raw.coRoundRadius(this.handle);
    }
    setRoundRadius(t) {
      this.colliderSet.raw.coSetRoundRadius(this.handle, t);
    }
    halfHeight() {
      return this.colliderSet.raw.coHalfHeight(this.handle);
    }
    setHalfHeight(t) {
      this.colliderSet.raw.coSetHalfHeight(this.handle, t);
    }
    setVoxel(t, e, n, i) {
      this.colliderSet.raw.coSetVoxel(this.handle, t, e, n, i), this._shape = null;
    }
    propagateVoxelChange(t, e, n, i, s, a, o) {
      this.colliderSet.raw.coPropagateVoxelChange(this.handle, t.handle, e, n, i, s, a, o), this._shape = null;
    }
    combineVoxelStates(t, e, n, i) {
      this.colliderSet.raw.coCombineVoxelStates(this.handle, t.handle, e, n, i), this._shape = null;
    }
    vertices() {
      return this.colliderSet.raw.coVertices(this.handle);
    }
    indices() {
      return this.colliderSet.raw.coIndices(this.handle);
    }
    heightfieldHeights() {
      return this.colliderSet.raw.coHeightfieldHeights(this.handle);
    }
    heightfieldScale() {
      let t = this.colliderSet.raw.coHeightfieldScale(this.handle);
      return U.fromRaw(t);
    }
    heightfieldNRows() {
      return this.colliderSet.raw.coHeightfieldNRows(this.handle);
    }
    heightfieldNCols() {
      return this.colliderSet.raw.coHeightfieldNCols(this.handle);
    }
    parent() {
      return this._parent;
    }
    friction() {
      return this.colliderSet.raw.coFriction(this.handle);
    }
    restitution() {
      return this.colliderSet.raw.coRestitution(this.handle);
    }
    density() {
      return this.colliderSet.raw.coDensity(this.handle);
    }
    mass() {
      return this.colliderSet.raw.coMass(this.handle);
    }
    volume() {
      return this.colliderSet.raw.coVolume(this.handle);
    }
    collisionGroups() {
      return this.colliderSet.raw.coCollisionGroups(this.handle);
    }
    solverGroups() {
      return this.colliderSet.raw.coSolverGroups(this.handle);
    }
    containsPoint(t) {
      let e = U.intoRaw(t), n = this.colliderSet.raw.coContainsPoint(this.handle, e);
      return e.free(), n;
    }
    projectPoint(t, e) {
      let n = U.intoRaw(t), i = zr.fromRaw(this.colliderSet.raw.coProjectPoint(this.handle, n, e));
      return n.free(), i;
    }
    intersectsRay(t, e) {
      let n = U.intoRaw(t.origin), i = U.intoRaw(t.dir), s = this.colliderSet.raw.coIntersectsRay(this.handle, n, i, e);
      return n.free(), i.free(), s;
    }
    castShape(t, e, n, i, s, a, o, c) {
      let l = U.intoRaw(t), h = U.intoRaw(n), d = Ut.intoRaw(i), u = U.intoRaw(s), p = e.intoRaw(), w = Vi.fromRaw(this.colliderSet, this.colliderSet.raw.coCastShape(this.handle, l, p, h, d, u, a, o, c));
      return l.free(), h.free(), d.free(), u.free(), p.free(), w;
    }
    castCollider(t, e, n, i, s, a) {
      let o = U.intoRaw(t), c = U.intoRaw(n), l = kr.fromRaw(this.colliderSet, this.colliderSet.raw.coCastCollider(this.handle, o, e.handle, c, i, s, a));
      return o.free(), c.free(), l;
    }
    intersectsShape(t, e, n) {
      let i = U.intoRaw(e), s = Ut.intoRaw(n), a = t.intoRaw(), o = this.colliderSet.raw.coIntersectsShape(this.handle, a, i, s);
      return i.free(), s.free(), a.free(), o;
    }
    contactShape(t, e, n, i) {
      let s = U.intoRaw(e), a = Ut.intoRaw(n), o = t.intoRaw(), c = Hi.fromRaw(this.colliderSet.raw.coContactShape(this.handle, o, s, a, i));
      return s.free(), a.free(), o.free(), c;
    }
    contactCollider(t, e) {
      return Hi.fromRaw(this.colliderSet.raw.coContactCollider(this.handle, t.handle, e));
    }
    castRay(t, e, n) {
      let i = U.intoRaw(t.origin), s = U.intoRaw(t.dir), a = this.colliderSet.raw.coCastRay(this.handle, i, s, e, n);
      return i.free(), s.free(), a;
    }
    castRayAndGetNormal(t, e, n) {
      let i = U.intoRaw(t.origin), s = U.intoRaw(t.dir), a = Br.fromRaw(this.colliderSet.raw.coCastRayAndGetNormal(this.handle, i, s, e, n));
      return i.free(), s.free(), a;
    }
  }
  var yi;
  (function(r) {
    r[r.Density = 0] = "Density", r[r.Mass = 1] = "Mass", r[r.MassProps = 2] = "MassProps";
  })(yi || (yi = {}));
  class be {
    constructor(t) {
      this.enabled = true, this.shape = t, this.massPropsMode = yi.Density, this.density = 1, this.friction = 0.5, this.restitution = 0, this.rotation = Ut.identity(), this.translation = U.zeros(), this.isSensor = false, this.collisionGroups = 4294967295, this.solverGroups = 4294967295, this.frictionCombineRule = Ir.Average, this.restitutionCombineRule = Ir.Average, this.activeCollisionTypes = ws.DEFAULT, this.activeEvents = ms.NONE, this.activeHooks = gs.NONE, this.mass = 0, this.centerOfMass = U.zeros(), this.contactForceEventThreshold = 0, this.contactSkin = 0, this.principalAngularInertia = U.zeros(), this.angularInertiaLocalFrame = Ut.identity();
    }
    static ball(t) {
      const e = new Qa(t);
      return new be(e);
    }
    static capsule(t, e) {
      const n = new no(t, e);
      return new be(n);
    }
    static segment(t, e) {
      const n = new io(t, e);
      return new be(n);
    }
    static triangle(t, e, n) {
      const i = new ro(t, e, n);
      return new be(i);
    }
    static roundTriangle(t, e, n, i) {
      const s = new so(t, e, n, i);
      return new be(s);
    }
    static polyline(t, e) {
      const n = new ao(t, e);
      return new be(n);
    }
    static voxels(t, e) {
      const n = new oo(t, e);
      return new be(n);
    }
    static trimesh(t, e, n) {
      const i = new co(t, e, n);
      return new be(i);
    }
    static cuboid(t, e, n) {
      const i = new to(t, e, n);
      return new be(i);
    }
    static roundCuboid(t, e, n, i) {
      const s = new eo(t, e, n, i);
      return new be(s);
    }
    static heightfield(t, e, n, i, s) {
      const a = new lo(t, e, n, i, s);
      return new be(a);
    }
    static cylinder(t, e) {
      const n = new ho(t, e);
      return new be(n);
    }
    static roundCylinder(t, e, n) {
      const i = new uo(t, e, n);
      return new be(i);
    }
    static cone(t, e) {
      const n = new po(t, e);
      return new be(n);
    }
    static roundCone(t, e, n) {
      const i = new fo(t, e, n);
      return new be(i);
    }
    static convexHull(t) {
      const e = new fs(t, null);
      return new be(e);
    }
    static convexMesh(t, e) {
      const n = new fs(t, e);
      return new be(n);
    }
    static roundConvexHull(t, e) {
      const n = new _s(t, null, e);
      return new be(n);
    }
    static roundConvexMesh(t, e, n) {
      const i = new _s(t, e, n);
      return new be(i);
    }
    setTranslation(t, e, n) {
      if (typeof t != "number" || typeof e != "number" || typeof n != "number") throw TypeError("The translation components must be numbers.");
      return this.translation = {
        x: t,
        y: e,
        z: n
      }, this;
    }
    setRotation(t) {
      return Ut.copy(this.rotation, t), this;
    }
    setSensor(t) {
      return this.isSensor = t, this;
    }
    setEnabled(t) {
      return this.enabled = t, this;
    }
    setContactSkin(t) {
      return this.contactSkin = t, this;
    }
    setDensity(t) {
      return this.massPropsMode = yi.Density, this.density = t, this;
    }
    setMass(t) {
      return this.massPropsMode = yi.Mass, this.mass = t, this;
    }
    setMassProperties(t, e, n, i) {
      return this.massPropsMode = yi.MassProps, this.mass = t, U.copy(this.centerOfMass, e), U.copy(this.principalAngularInertia, n), Ut.copy(this.angularInertiaLocalFrame, i), this;
    }
    setRestitution(t) {
      return this.restitution = t, this;
    }
    setFriction(t) {
      return this.friction = t, this;
    }
    setFrictionCombineRule(t) {
      return this.frictionCombineRule = t, this;
    }
    setRestitutionCombineRule(t) {
      return this.restitutionCombineRule = t, this;
    }
    setCollisionGroups(t) {
      return this.collisionGroups = t, this;
    }
    setSolverGroups(t) {
      return this.solverGroups = t, this;
    }
    setActiveHooks(t) {
      return this.activeHooks = t, this;
    }
    setActiveEvents(t) {
      return this.activeEvents = t, this;
    }
    setActiveCollisionTypes(t) {
      return this.activeCollisionTypes = t, this;
    }
    setContactForceEventThreshold(t) {
      return this.contactForceEventThreshold = t, this;
    }
  }
  class Tl {
    free() {
      this.raw && this.raw.free(), this.raw = void 0, this.map && this.map.clear(), this.map = void 0;
    }
    constructor(t) {
      this.raw = t || new ve(), this.map = new Za(), t && t.forEachColliderHandle((e) => {
        this.map.set(e, new Ua(this, e, null));
      });
    }
    castClosure(t) {
      return (e) => {
        if (t) return t(this.get(e));
      };
    }
    finalizeDeserialization(t) {
      this.map.forEach((e) => e.finalizeDeserialization(t));
    }
    createCollider(t, e, n) {
      let i = n != null && n != null;
      if (i && isNaN(n)) throw Error("Cannot create a collider with a parent rigid-body handle that is not a number.");
      let s = e.shape.intoRaw(), a = U.intoRaw(e.translation), o = Ut.intoRaw(e.rotation), c = U.intoRaw(e.centerOfMass), l = U.intoRaw(e.principalAngularInertia), h = Ut.intoRaw(e.angularInertiaLocalFrame), d = this.raw.createCollider(e.enabled, s, a, o, e.massPropsMode, e.mass, c, l, h, e.density, e.friction, e.restitution, e.frictionCombineRule, e.restitutionCombineRule, e.isSensor, e.collisionGroups, e.solverGroups, e.activeCollisionTypes, e.activeHooks, e.activeEvents, e.contactForceEventThreshold, e.contactSkin, i, i ? n : 0, t.raw);
      s.free(), a.free(), o.free(), c.free(), l.free(), h.free();
      let u = i ? t.get(n) : null, p = new Ua(this, d, u, e.shape);
      return this.map.set(d, p), p;
    }
    remove(t, e, n, i) {
      this.raw.remove(t, e.raw, n.raw, i), this.unmap(t);
    }
    unmap(t) {
      this.map.delete(t);
    }
    get(t) {
      return this.map.get(t);
    }
    len() {
      return this.map.len();
    }
    contains(t) {
      return this.get(t) != null;
    }
    forEach(t) {
      this.map.forEach(t);
    }
    getAll() {
      return this.map.getAll();
    }
  }
  function op() {
    return Ub();
  }
  function cp(r) {
    Fb(r);
  }
  const S1 = Object.freeze(Object.defineProperty({
    __proto__: null,
    get ActiveCollisionTypes() {
      return ws;
    },
    get ActiveEvents() {
      return ms;
    },
    get ActiveHooks() {
      return gs;
    },
    Ball: Qa,
    BroadPhase: fl,
    CCDSolver: dl,
    Capsule: no,
    CharacterCollision: vl,
    get CoefficientCombineRule() {
      return Ir;
    },
    Collider: Ua,
    ColliderDesc: be,
    ColliderSet: Tl,
    ColliderShapeCastHit: kr,
    Cone: po,
    ConvexPolyhedron: fs,
    Cuboid: to,
    Cylinder: ho,
    DebugRenderBuffers: bl,
    DebugRenderPipeline: yl,
    DynamicRayCastVehicleController: Ml,
    EventQueue: ap,
    get FeatureType() {
      return ki;
    },
    FixedImpulseJoint: Jc,
    FixedMultibodyJoint: al,
    GenericImpulseJoint: il,
    HalfSpace: gl,
    get HeightFieldFlags() {
      return Ca;
    },
    Heightfield: lo,
    ImpulseJoint: wn,
    ImpulseJointSet: sl,
    IntegrationParameters: $c,
    IslandManager: ul,
    get JointAxesMask() {
      return Ra;
    },
    JointData: In,
    get JointType() {
      return ke;
    },
    KinematicCharacterController: xl,
    get MassPropsMode() {
      return yi;
    },
    get MotorModel() {
      return Aa;
    },
    MultibodyJoint: ri,
    MultibodyJointSet: hl,
    NarrowPhase: _l,
    PhysicsPipeline: wl,
    get PidAxesMask() {
      return La;
    },
    PidController: Sl,
    PointColliderProjection: Dr,
    PointProjection: zr,
    Polyline: ao,
    PrismaticImpulseJoint: el,
    PrismaticMultibodyJoint: ol,
    Quaternion: Ma,
    get QueryFilterFlags() {
      return Na;
    },
    Ray: pl,
    RayColliderHit: Ss,
    RayColliderIntersection: Lr,
    RayIntersection: Br,
    RevoluteImpulseJoint: nl,
    RevoluteMultibodyJoint: cl,
    RigidBody: Ta,
    RigidBodyDesc: mn,
    RigidBodySet: Zc,
    get RigidBodyType() {
      return _n;
    },
    RopeImpulseJoint: Qc,
    RotationOps: Ut,
    RoundCone: fo,
    RoundConvexPolyhedron: _s,
    RoundCuboid: eo,
    RoundCylinder: uo,
    RoundTriangle: so,
    SdpMatrix3: Yc,
    SdpMatrix3Ops: Ea,
    Segment: io,
    SerializationPipeline: Ia,
    Shape: Ae,
    ShapeCastHit: Vi,
    ShapeContact: Hi,
    get ShapeType() {
      return Te;
    },
    get SolverFlags() {
      return Da;
    },
    SphericalImpulseJoint: rl,
    SphericalMultibodyJoint: ll,
    SpringImpulseJoint: tl,
    TempContactForceEvent: El,
    TempContactManifold: ml,
    TriMesh: co,
    get TriMeshFlags() {
      return Pa;
    },
    Triangle: ro,
    UnitImpulseJoint: $a,
    UnitMultibodyJoint: Ja,
    Vector3: gn,
    VectorOps: U,
    Voxels: oo,
    World: _o,
    reserveMemory: cp,
    version: op
  }, Symbol.toStringTag, {
    value: "Module"
  })), M1 = Object.freeze(Object.defineProperty({
    __proto__: null,
    get ActiveCollisionTypes() {
      return ws;
    },
    get ActiveEvents() {
      return ms;
    },
    get ActiveHooks() {
      return gs;
    },
    Ball: Qa,
    BroadPhase: fl,
    CCDSolver: dl,
    Capsule: no,
    CharacterCollision: vl,
    get CoefficientCombineRule() {
      return Ir;
    },
    Collider: Ua,
    ColliderDesc: be,
    ColliderSet: Tl,
    ColliderShapeCastHit: kr,
    Cone: po,
    ConvexPolyhedron: fs,
    Cuboid: to,
    Cylinder: ho,
    DebugRenderBuffers: bl,
    DebugRenderPipeline: yl,
    DynamicRayCastVehicleController: Ml,
    EventQueue: ap,
    get FeatureType() {
      return ki;
    },
    FixedImpulseJoint: Jc,
    FixedMultibodyJoint: al,
    GenericImpulseJoint: il,
    HalfSpace: gl,
    get HeightFieldFlags() {
      return Ca;
    },
    Heightfield: lo,
    ImpulseJoint: wn,
    ImpulseJointSet: sl,
    IntegrationParameters: $c,
    IslandManager: ul,
    get JointAxesMask() {
      return Ra;
    },
    JointData: In,
    get JointType() {
      return ke;
    },
    KinematicCharacterController: xl,
    get MassPropsMode() {
      return yi;
    },
    get MotorModel() {
      return Aa;
    },
    MultibodyJoint: ri,
    MultibodyJointSet: hl,
    NarrowPhase: _l,
    PhysicsPipeline: wl,
    get PidAxesMask() {
      return La;
    },
    PidController: Sl,
    PointColliderProjection: Dr,
    PointProjection: zr,
    Polyline: ao,
    PrismaticImpulseJoint: el,
    PrismaticMultibodyJoint: ol,
    Quaternion: Ma,
    get QueryFilterFlags() {
      return Na;
    },
    Ray: pl,
    RayColliderHit: Ss,
    RayColliderIntersection: Lr,
    RayIntersection: Br,
    RevoluteImpulseJoint: nl,
    RevoluteMultibodyJoint: cl,
    RigidBody: Ta,
    RigidBodyDesc: mn,
    RigidBodySet: Zc,
    get RigidBodyType() {
      return _n;
    },
    RopeImpulseJoint: Qc,
    RotationOps: Ut,
    RoundCone: fo,
    RoundConvexPolyhedron: _s,
    RoundCuboid: eo,
    RoundCylinder: uo,
    RoundTriangle: so,
    SdpMatrix3: Yc,
    SdpMatrix3Ops: Ea,
    Segment: io,
    SerializationPipeline: Ia,
    Shape: Ae,
    ShapeCastHit: Vi,
    ShapeContact: Hi,
    get ShapeType() {
      return Te;
    },
    get SolverFlags() {
      return Da;
    },
    SphericalImpulseJoint: rl,
    SphericalMultibodyJoint: ll,
    SpringImpulseJoint: tl,
    TempContactForceEvent: El,
    TempContactManifold: ml,
    TriMesh: co,
    get TriMeshFlags() {
      return Pa;
    },
    Triangle: ro,
    UnitImpulseJoint: $a,
    UnitMultibodyJoint: Ja,
    Vector3: gn,
    VectorOps: U,
    Voxels: oo,
    World: _o,
    default: S1,
    reserveMemory: cp,
    version: op
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  class E1 {
    constructor() {
      this.fixedDt = 1 / 60, this.accumulator = 0, this.world = new _o({
        x: 0,
        y: -9.82,
        z: 0
      }), this.createGround();
    }
    createGround() {
    }
    step(t) {
      const e = 0.03333333333333333, n = 1 / 240, i = Math.max(n, Math.min(t, e));
      this.world.timestep = i, this.world.step();
    }
  }
  class T1 {
    constructor() {
      this.container = document.createElement("div"), this.container.style.position = "absolute", this.container.style.top = "20px", this.container.style.left = "20px", this.container.style.padding = "12px 16px", this.container.style.background = "rgba(0, 0, 0, 0.6)", this.container.style.borderRadius = "8px", this.container.style.fontFamily = "Consolas, 'Courier New', monospace", this.container.style.fontSize = "12px", this.container.style.color = "#00ff9d", this.container.style.whiteSpace = "pre", this.container.style.pointerEvents = "none", this.container.style.zIndex = "100", document.body.appendChild(this.container), this.visible = false;
    }
    set visible(t) {
      this._visible = t, this.container && (this.container.style.display = t ? "block" : "none");
    }
    get visible() {
      return this._visible;
    }
    update(t) {
      if (!this._visible || !t) return;
      const e = [];
      e.push(`Speed: ${t.speedMph.toFixed(1)} mph`), e.push(`Local vel -> forward: ${t.forwardSpeed.toFixed(2)} m/s, lateral: ${t.lateralSpeed.toFixed(2)} m/s`), e.push(`Inputs -> throttle: ${t.engineInput.toFixed(2)}, brake: ${t.brakeInput.toFixed(2)}, steer: ${t.steerInput.toFixed(2)}`), e.push(`Gear: ${t.gear}  RPM: ${Math.round(t.rpm)}  EngineForce: ${t.engineForce.toFixed(1)}`), e.push(`Downforce: ${t.downforce.toFixed(1)}N  Drag: ${t.drag.toFixed(1)}N`), e.push("Wheels:"), t.wheels.forEach((n, i) => {
        e.push(`  ${n.label} | contact: ${n.inContact ? "yes" : "no"} | compression: ${n.compression.toFixed(3)}m | length: ${n.length.toFixed(3)}m`);
      }), this.container.textContent = e.join(`
`);
    }
  }
  function Yd(r, t) {
    if (t === hf) return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."), r;
    if (t === xc || t === bu) {
      let e = r.getIndex();
      if (e === null) {
        const a = [], o = r.getAttribute("position");
        if (o !== void 0) {
          for (let c = 0; c < o.count; c++) a.push(c);
          r.setIndex(a), e = r.getIndex();
        } else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), r;
      }
      const n = e.count - 2, i = [];
      if (t === xc) for (let a = 1; a <= n; a++) i.push(e.getX(0)), i.push(e.getX(a)), i.push(e.getX(a + 1));
      else for (let a = 0; a < n; a++) a % 2 === 0 ? (i.push(e.getX(a)), i.push(e.getX(a + 1)), i.push(e.getX(a + 2))) : (i.push(e.getX(a + 2)), i.push(e.getX(a + 1)), i.push(e.getX(a)));
      i.length / 3 !== n && console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
      const s = r.clone();
      return s.setIndex(i), s.clearGroups(), s;
    } else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", t), r;
  }
  class Al extends Or {
    constructor(t) {
      super(t), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register(function(e) {
        return new I1(e);
      }), this.register(function(e) {
        return new L1(e);
      }), this.register(function(e) {
        return new H1(e);
      }), this.register(function(e) {
        return new G1(e);
      }), this.register(function(e) {
        return new V1(e);
      }), this.register(function(e) {
        return new N1(e);
      }), this.register(function(e) {
        return new U1(e);
      }), this.register(function(e) {
        return new F1(e);
      }), this.register(function(e) {
        return new O1(e);
      }), this.register(function(e) {
        return new P1(e);
      }), this.register(function(e) {
        return new B1(e);
      }), this.register(function(e) {
        return new D1(e);
      }), this.register(function(e) {
        return new k1(e);
      }), this.register(function(e) {
        return new z1(e);
      }), this.register(function(e) {
        return new R1(e);
      }), this.register(function(e) {
        return new W1(e);
      }), this.register(function(e) {
        return new j1(e);
      });
    }
    load(t, e, n, i) {
      const s = this;
      let a;
      if (this.resourcePath !== "") a = this.resourcePath;
      else if (this.path !== "") {
        const l = as.extractUrlBase(t);
        a = as.resolveURL(l, this.path);
      } else a = as.extractUrlBase(t);
      this.manager.itemStart(t);
      const o = function(l) {
        i ? i(l) : console.error(l), s.manager.itemError(t), s.manager.itemEnd(t);
      }, c = new $u(this.manager);
      c.setPath(this.path), c.setResponseType("arraybuffer"), c.setRequestHeader(this.requestHeader), c.setWithCredentials(this.withCredentials), c.load(t, function(l) {
        try {
          s.parse(l, a, function(h) {
            e(h), s.manager.itemEnd(t);
          }, o);
        } catch (h) {
          o(h);
        }
      }, n, o);
    }
    setDRACOLoader(t) {
      return this.dracoLoader = t, this;
    }
    setDDSLoader() {
      throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".');
    }
    setKTX2Loader(t) {
      return this.ktx2Loader = t, this;
    }
    setMeshoptDecoder(t) {
      return this.meshoptDecoder = t, this;
    }
    register(t) {
      return this.pluginCallbacks.indexOf(t) === -1 && this.pluginCallbacks.push(t), this;
    }
    unregister(t) {
      return this.pluginCallbacks.indexOf(t) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(t), 1), this;
    }
    parse(t, e, n, i) {
      let s;
      const a = {}, o = {}, c = new TextDecoder();
      if (typeof t == "string") s = JSON.parse(t);
      else if (t instanceof ArrayBuffer) if (c.decode(new Uint8Array(t, 0, 4)) === lp) {
        try {
          a[$t.KHR_BINARY_GLTF] = new X1(t);
        } catch (d) {
          i && i(d);
          return;
        }
        s = JSON.parse(a[$t.KHR_BINARY_GLTF].content);
      } else s = JSON.parse(c.decode(t));
      else s = t;
      if (s.asset === void 0 || s.asset.version[0] < 2) {
        i && i(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
        return;
      }
      const l = new sP(s, {
        path: e || this.resourcePath || "",
        crossOrigin: this.crossOrigin,
        requestHeader: this.requestHeader,
        manager: this.manager,
        ktx2Loader: this.ktx2Loader,
        meshoptDecoder: this.meshoptDecoder
      });
      l.fileLoader.setRequestHeader(this.requestHeader);
      for (let h = 0; h < this.pluginCallbacks.length; h++) {
        const d = this.pluginCallbacks[h](l);
        d.name || console.error("THREE.GLTFLoader: Invalid plugin found: missing name"), o[d.name] = d, a[d.name] = true;
      }
      if (s.extensionsUsed) for (let h = 0; h < s.extensionsUsed.length; ++h) {
        const d = s.extensionsUsed[h], u = s.extensionsRequired || [];
        switch (d) {
          case $t.KHR_MATERIALS_UNLIT:
            a[d] = new C1();
            break;
          case $t.KHR_DRACO_MESH_COMPRESSION:
            a[d] = new q1(s, this.dracoLoader);
            break;
          case $t.KHR_TEXTURE_TRANSFORM:
            a[d] = new K1();
            break;
          case $t.KHR_MESH_QUANTIZATION:
            a[d] = new Y1();
            break;
          default:
            u.indexOf(d) >= 0 && o[d] === void 0 && console.warn('THREE.GLTFLoader: Unknown extension "' + d + '".');
        }
      }
      l.setExtensions(a), l.setPlugins(o), l.parse(n, i);
    }
    parseAsync(t, e) {
      const n = this;
      return new Promise(function(i, s) {
        n.parse(t, e, i, s);
      });
    }
  }
  function A1() {
    let r = {};
    return {
      get: function(t) {
        return r[t];
      },
      add: function(t, e) {
        r[t] = e;
      },
      remove: function(t) {
        delete r[t];
      },
      removeAll: function() {
        r = {};
      }
    };
  }
  const $t = {
    KHR_BINARY_GLTF: "KHR_binary_glTF",
    KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
    KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
    KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
    KHR_MATERIALS_DISPERSION: "KHR_materials_dispersion",
    KHR_MATERIALS_IOR: "KHR_materials_ior",
    KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
    KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
    KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
    KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
    KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
    KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
    KHR_MATERIALS_VOLUME: "KHR_materials_volume",
    KHR_TEXTURE_BASISU: "KHR_texture_basisu",
    KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
    KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
    KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
    EXT_MATERIALS_BUMP: "EXT_materials_bump",
    EXT_TEXTURE_WEBP: "EXT_texture_webp",
    EXT_TEXTURE_AVIF: "EXT_texture_avif",
    EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
    EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing"
  };
  class R1 {
    constructor(t) {
      this.parser = t, this.name = $t.KHR_LIGHTS_PUNCTUAL, this.cache = {
        refs: {},
        uses: {}
      };
    }
    _markDefs() {
      const t = this.parser, e = this.parser.json.nodes || [];
      for (let n = 0, i = e.length; n < i; n++) {
        const s = e[n];
        s.extensions && s.extensions[this.name] && s.extensions[this.name].light !== void 0 && t._addNodeRef(this.cache, s.extensions[this.name].light);
      }
    }
    _loadLight(t) {
      const e = this.parser, n = "light:" + t;
      let i = e.cache.get(n);
      if (i) return i;
      const s = e.json, c = ((s.extensions && s.extensions[this.name] || {}).lights || [])[t];
      let l;
      const h = new Ct(16777215);
      c.color !== void 0 && h.setRGB(c.color[0], c.color[1], c.color[2], je);
      const d = c.range !== void 0 ? c.range : 0;
      switch (c.type) {
        case "directional":
          l = new Ac(h), l.target.position.set(0, 0, -1), l.add(l.target);
          break;
        case "point":
          l = new mb(h), l.distance = d;
          break;
        case "spot":
          l = new Qu(h), l.distance = d, c.spot = c.spot || {}, c.spot.innerConeAngle = c.spot.innerConeAngle !== void 0 ? c.spot.innerConeAngle : 0, c.spot.outerConeAngle = c.spot.outerConeAngle !== void 0 ? c.spot.outerConeAngle : Math.PI / 4, l.angle = c.spot.outerConeAngle, l.penumbra = 1 - c.spot.innerConeAngle / c.spot.outerConeAngle, l.target.position.set(0, 0, -1), l.add(l.target);
          break;
        default:
          throw new Error("THREE.GLTFLoader: Unexpected light type: " + c.type);
      }
      return l.position.set(0, 0, 0), l.decay = 2, Yn(l, c), c.intensity !== void 0 && (l.intensity = c.intensity), l.name = e.createUniqueName(c.name || "light_" + t), i = Promise.resolve(l), e.cache.add(n, i), i;
    }
    getDependency(t, e) {
      if (t === "light") return this._loadLight(e);
    }
    createNodeAttachment(t) {
      const e = this, n = this.parser, s = n.json.nodes[t], o = (s.extensions && s.extensions[this.name] || {}).light;
      return o === void 0 ? null : this._loadLight(o).then(function(c) {
        return n._getNodeRef(e.cache, o, c);
      });
    }
  }
  class C1 {
    constructor() {
      this.name = $t.KHR_MATERIALS_UNLIT;
    }
    getMaterialType() {
      return Nn;
    }
    extendParams(t, e, n) {
      const i = [];
      t.color = new Ct(1, 1, 1), t.opacity = 1;
      const s = e.pbrMetallicRoughness;
      if (s) {
        if (Array.isArray(s.baseColorFactor)) {
          const a = s.baseColorFactor;
          t.color.setRGB(a[0], a[1], a[2], je), t.opacity = a[3];
        }
        s.baseColorTexture !== void 0 && i.push(n.assignTexture(t, "map", s.baseColorTexture, Ke));
      }
      return Promise.all(i);
    }
  }
  class P1 {
    constructor(t) {
      this.parser = t, this.name = $t.KHR_MATERIALS_EMISSIVE_STRENGTH;
    }
    extendMaterialParams(t, e) {
      const i = this.parser.json.materials[t];
      if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
      const s = i.extensions[this.name].emissiveStrength;
      return s !== void 0 && (e.emissiveIntensity = s), Promise.resolve();
    }
  }
  class I1 {
    constructor(t) {
      this.parser = t, this.name = $t.KHR_MATERIALS_CLEARCOAT;
    }
    getMaterialType(t) {
      const n = this.parser.json.materials[t];
      return !n.extensions || !n.extensions[this.name] ? null : Bn;
    }
    extendMaterialParams(t, e) {
      const n = this.parser, i = n.json.materials[t];
      if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
      const s = [], a = i.extensions[this.name];
      if (a.clearcoatFactor !== void 0 && (e.clearcoat = a.clearcoatFactor), a.clearcoatTexture !== void 0 && s.push(n.assignTexture(e, "clearcoatMap", a.clearcoatTexture)), a.clearcoatRoughnessFactor !== void 0 && (e.clearcoatRoughness = a.clearcoatRoughnessFactor), a.clearcoatRoughnessTexture !== void 0 && s.push(n.assignTexture(e, "clearcoatRoughnessMap", a.clearcoatRoughnessTexture)), a.clearcoatNormalTexture !== void 0 && (s.push(n.assignTexture(e, "clearcoatNormalMap", a.clearcoatNormalTexture)), a.clearcoatNormalTexture.scale !== void 0)) {
        const o = a.clearcoatNormalTexture.scale;
        e.clearcoatNormalScale = new vt(o, o);
      }
      return Promise.all(s);
    }
  }
  class L1 {
    constructor(t) {
      this.parser = t, this.name = $t.KHR_MATERIALS_DISPERSION;
    }
    getMaterialType(t) {
      const n = this.parser.json.materials[t];
      return !n.extensions || !n.extensions[this.name] ? null : Bn;
    }
    extendMaterialParams(t, e) {
      const i = this.parser.json.materials[t];
      if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
      const s = i.extensions[this.name];
      return e.dispersion = s.dispersion !== void 0 ? s.dispersion : 0, Promise.resolve();
    }
  }
  class D1 {
    constructor(t) {
      this.parser = t, this.name = $t.KHR_MATERIALS_IRIDESCENCE;
    }
    getMaterialType(t) {
      const n = this.parser.json.materials[t];
      return !n.extensions || !n.extensions[this.name] ? null : Bn;
    }
    extendMaterialParams(t, e) {
      const n = this.parser, i = n.json.materials[t];
      if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
      const s = [], a = i.extensions[this.name];
      return a.iridescenceFactor !== void 0 && (e.iridescence = a.iridescenceFactor), a.iridescenceTexture !== void 0 && s.push(n.assignTexture(e, "iridescenceMap", a.iridescenceTexture)), a.iridescenceIor !== void 0 && (e.iridescenceIOR = a.iridescenceIor), e.iridescenceThicknessRange === void 0 && (e.iridescenceThicknessRange = [
        100,
        400
      ]), a.iridescenceThicknessMinimum !== void 0 && (e.iridescenceThicknessRange[0] = a.iridescenceThicknessMinimum), a.iridescenceThicknessMaximum !== void 0 && (e.iridescenceThicknessRange[1] = a.iridescenceThicknessMaximum), a.iridescenceThicknessTexture !== void 0 && s.push(n.assignTexture(e, "iridescenceThicknessMap", a.iridescenceThicknessTexture)), Promise.all(s);
    }
  }
  class N1 {
    constructor(t) {
      this.parser = t, this.name = $t.KHR_MATERIALS_SHEEN;
    }
    getMaterialType(t) {
      const n = this.parser.json.materials[t];
      return !n.extensions || !n.extensions[this.name] ? null : Bn;
    }
    extendMaterialParams(t, e) {
      const n = this.parser, i = n.json.materials[t];
      if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
      const s = [];
      e.sheenColor = new Ct(0, 0, 0), e.sheenRoughness = 0, e.sheen = 1;
      const a = i.extensions[this.name];
      if (a.sheenColorFactor !== void 0) {
        const o = a.sheenColorFactor;
        e.sheenColor.setRGB(o[0], o[1], o[2], je);
      }
      return a.sheenRoughnessFactor !== void 0 && (e.sheenRoughness = a.sheenRoughnessFactor), a.sheenColorTexture !== void 0 && s.push(n.assignTexture(e, "sheenColorMap", a.sheenColorTexture, Ke)), a.sheenRoughnessTexture !== void 0 && s.push(n.assignTexture(e, "sheenRoughnessMap", a.sheenRoughnessTexture)), Promise.all(s);
    }
  }
  class U1 {
    constructor(t) {
      this.parser = t, this.name = $t.KHR_MATERIALS_TRANSMISSION;
    }
    getMaterialType(t) {
      const n = this.parser.json.materials[t];
      return !n.extensions || !n.extensions[this.name] ? null : Bn;
    }
    extendMaterialParams(t, e) {
      const n = this.parser, i = n.json.materials[t];
      if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
      const s = [], a = i.extensions[this.name];
      return a.transmissionFactor !== void 0 && (e.transmission = a.transmissionFactor), a.transmissionTexture !== void 0 && s.push(n.assignTexture(e, "transmissionMap", a.transmissionTexture)), Promise.all(s);
    }
  }
  class F1 {
    constructor(t) {
      this.parser = t, this.name = $t.KHR_MATERIALS_VOLUME;
    }
    getMaterialType(t) {
      const n = this.parser.json.materials[t];
      return !n.extensions || !n.extensions[this.name] ? null : Bn;
    }
    extendMaterialParams(t, e) {
      const n = this.parser, i = n.json.materials[t];
      if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
      const s = [], a = i.extensions[this.name];
      e.thickness = a.thicknessFactor !== void 0 ? a.thicknessFactor : 0, a.thicknessTexture !== void 0 && s.push(n.assignTexture(e, "thicknessMap", a.thicknessTexture)), e.attenuationDistance = a.attenuationDistance || 1 / 0;
      const o = a.attenuationColor || [
        1,
        1,
        1
      ];
      return e.attenuationColor = new Ct().setRGB(o[0], o[1], o[2], je), Promise.all(s);
    }
  }
  class O1 {
    constructor(t) {
      this.parser = t, this.name = $t.KHR_MATERIALS_IOR;
    }
    getMaterialType(t) {
      const n = this.parser.json.materials[t];
      return !n.extensions || !n.extensions[this.name] ? null : Bn;
    }
    extendMaterialParams(t, e) {
      const i = this.parser.json.materials[t];
      if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
      const s = i.extensions[this.name];
      return e.ior = s.ior !== void 0 ? s.ior : 1.5, Promise.resolve();
    }
  }
  class B1 {
    constructor(t) {
      this.parser = t, this.name = $t.KHR_MATERIALS_SPECULAR;
    }
    getMaterialType(t) {
      const n = this.parser.json.materials[t];
      return !n.extensions || !n.extensions[this.name] ? null : Bn;
    }
    extendMaterialParams(t, e) {
      const n = this.parser, i = n.json.materials[t];
      if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
      const s = [], a = i.extensions[this.name];
      e.specularIntensity = a.specularFactor !== void 0 ? a.specularFactor : 1, a.specularTexture !== void 0 && s.push(n.assignTexture(e, "specularIntensityMap", a.specularTexture));
      const o = a.specularColorFactor || [
        1,
        1,
        1
      ];
      return e.specularColor = new Ct().setRGB(o[0], o[1], o[2], je), a.specularColorTexture !== void 0 && s.push(n.assignTexture(e, "specularColorMap", a.specularColorTexture, Ke)), Promise.all(s);
    }
  }
  class z1 {
    constructor(t) {
      this.parser = t, this.name = $t.EXT_MATERIALS_BUMP;
    }
    getMaterialType(t) {
      const n = this.parser.json.materials[t];
      return !n.extensions || !n.extensions[this.name] ? null : Bn;
    }
    extendMaterialParams(t, e) {
      const n = this.parser, i = n.json.materials[t];
      if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
      const s = [], a = i.extensions[this.name];
      return e.bumpScale = a.bumpFactor !== void 0 ? a.bumpFactor : 1, a.bumpTexture !== void 0 && s.push(n.assignTexture(e, "bumpMap", a.bumpTexture)), Promise.all(s);
    }
  }
  class k1 {
    constructor(t) {
      this.parser = t, this.name = $t.KHR_MATERIALS_ANISOTROPY;
    }
    getMaterialType(t) {
      const n = this.parser.json.materials[t];
      return !n.extensions || !n.extensions[this.name] ? null : Bn;
    }
    extendMaterialParams(t, e) {
      const n = this.parser, i = n.json.materials[t];
      if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
      const s = [], a = i.extensions[this.name];
      return a.anisotropyStrength !== void 0 && (e.anisotropy = a.anisotropyStrength), a.anisotropyRotation !== void 0 && (e.anisotropyRotation = a.anisotropyRotation), a.anisotropyTexture !== void 0 && s.push(n.assignTexture(e, "anisotropyMap", a.anisotropyTexture)), Promise.all(s);
    }
  }
  class H1 {
    constructor(t) {
      this.parser = t, this.name = $t.KHR_TEXTURE_BASISU;
    }
    loadTexture(t) {
      const e = this.parser, n = e.json, i = n.textures[t];
      if (!i.extensions || !i.extensions[this.name]) return null;
      const s = i.extensions[this.name], a = e.options.ktx2Loader;
      if (!a) {
        if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
        return null;
      }
      return e.loadTextureImage(t, s.source, a);
    }
  }
  class G1 {
    constructor(t) {
      this.parser = t, this.name = $t.EXT_TEXTURE_WEBP, this.isSupported = null;
    }
    loadTexture(t) {
      const e = this.name, n = this.parser, i = n.json, s = i.textures[t];
      if (!s.extensions || !s.extensions[e]) return null;
      const a = s.extensions[e], o = i.images[a.source];
      let c = n.textureLoader;
      if (o.uri) {
        const l = n.options.manager.getHandler(o.uri);
        l !== null && (c = l);
      }
      return this.detectSupport().then(function(l) {
        if (l) return n.loadTextureImage(t, a.source, c);
        if (i.extensionsRequired && i.extensionsRequired.indexOf(e) >= 0) throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
        return n.loadTexture(t);
      });
    }
    detectSupport() {
      return this.isSupported || (this.isSupported = new Promise(function(t) {
        const e = new Image();
        e.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", e.onload = e.onerror = function() {
          t(e.height === 1);
        };
      })), this.isSupported;
    }
  }
  class V1 {
    constructor(t) {
      this.parser = t, this.name = $t.EXT_TEXTURE_AVIF, this.isSupported = null;
    }
    loadTexture(t) {
      const e = this.name, n = this.parser, i = n.json, s = i.textures[t];
      if (!s.extensions || !s.extensions[e]) return null;
      const a = s.extensions[e], o = i.images[a.source];
      let c = n.textureLoader;
      if (o.uri) {
        const l = n.options.manager.getHandler(o.uri);
        l !== null && (c = l);
      }
      return this.detectSupport().then(function(l) {
        if (l) return n.loadTextureImage(t, a.source, c);
        if (i.extensionsRequired && i.extensionsRequired.indexOf(e) >= 0) throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");
        return n.loadTexture(t);
      });
    }
    detectSupport() {
      return this.isSupported || (this.isSupported = new Promise(function(t) {
        const e = new Image();
        e.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=", e.onload = e.onerror = function() {
          t(e.height === 1);
        };
      })), this.isSupported;
    }
  }
  class W1 {
    constructor(t) {
      this.name = $t.EXT_MESHOPT_COMPRESSION, this.parser = t;
    }
    loadBufferView(t) {
      const e = this.parser.json, n = e.bufferViews[t];
      if (n.extensions && n.extensions[this.name]) {
        const i = n.extensions[this.name], s = this.parser.getDependency("buffer", i.buffer), a = this.parser.options.meshoptDecoder;
        if (!a || !a.supported) {
          if (e.extensionsRequired && e.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
          return null;
        }
        return s.then(function(o) {
          const c = i.byteOffset || 0, l = i.byteLength || 0, h = i.count, d = i.byteStride, u = new Uint8Array(o, c, l);
          return a.decodeGltfBufferAsync ? a.decodeGltfBufferAsync(h, d, u, i.mode, i.filter).then(function(p) {
            return p.buffer;
          }) : a.ready.then(function() {
            const p = new ArrayBuffer(h * d);
            return a.decodeGltfBuffer(new Uint8Array(p), h, d, u, i.mode, i.filter), p;
          });
        });
      } else return null;
    }
  }
  class j1 {
    constructor(t) {
      this.name = $t.EXT_MESH_GPU_INSTANCING, this.parser = t;
    }
    createNodeMesh(t) {
      const e = this.parser.json, n = e.nodes[t];
      if (!n.extensions || !n.extensions[this.name] || n.mesh === void 0) return null;
      const i = e.meshes[n.mesh];
      for (const l of i.primitives) if (l.mode !== fn.TRIANGLES && l.mode !== fn.TRIANGLE_STRIP && l.mode !== fn.TRIANGLE_FAN && l.mode !== void 0) return null;
      const a = n.extensions[this.name].attributes, o = [], c = {};
      for (const l in a) o.push(this.parser.getDependency("accessor", a[l]).then((h) => (c[l] = h, c[l])));
      return o.length < 1 ? null : (o.push(this.parser.createNodeMesh(t)), Promise.all(o).then((l) => {
        const h = l.pop(), d = h.isGroup ? h.children : [
          h
        ], u = l[0].count, p = [];
        for (const w of d) {
          const b = new Ht(), m = new L(), _ = new Ve(), E = new L(1, 1, 1), v = new $0(w.geometry, w.material, u);
          for (let T = 0; T < u; T++) c.TRANSLATION && m.fromBufferAttribute(c.TRANSLATION, T), c.ROTATION && _.fromBufferAttribute(c.ROTATION, T), c.SCALE && E.fromBufferAttribute(c.SCALE, T), v.setMatrixAt(T, b.compose(m, _, E));
          for (const T in c) if (T === "_COLOR_0") {
            const O = c[T];
            v.instanceColor = new Ec(O.array, O.itemSize, O.normalized);
          } else T !== "TRANSLATION" && T !== "ROTATION" && T !== "SCALE" && w.geometry.setAttribute(T, c[T]);
          _e.prototype.copy.call(v, w), this.parser.assignFinalMaterial(v), p.push(v);
        }
        return h.isGroup ? (h.clear(), h.add(...p), h) : p[0];
      }));
    }
  }
  const lp = "glTF", Qr = 12, Zd = {
    JSON: 1313821514,
    BIN: 5130562
  };
  class X1 {
    constructor(t) {
      this.name = $t.KHR_BINARY_GLTF, this.content = null, this.body = null;
      const e = new DataView(t, 0, Qr), n = new TextDecoder();
      if (this.header = {
        magic: n.decode(new Uint8Array(t.slice(0, 4))),
        version: e.getUint32(4, true),
        length: e.getUint32(8, true)
      }, this.header.magic !== lp) throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
      if (this.header.version < 2) throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
      const i = this.header.length - Qr, s = new DataView(t, Qr);
      let a = 0;
      for (; a < i; ) {
        const o = s.getUint32(a, true);
        a += 4;
        const c = s.getUint32(a, true);
        if (a += 4, c === Zd.JSON) {
          const l = new Uint8Array(t, Qr + a, o);
          this.content = n.decode(l);
        } else if (c === Zd.BIN) {
          const l = Qr + a;
          this.body = t.slice(l, l + o);
        }
        a += o;
      }
      if (this.content === null) throw new Error("THREE.GLTFLoader: JSON content not found.");
    }
  }
  class q1 {
    constructor(t, e) {
      if (!e) throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
      this.name = $t.KHR_DRACO_MESH_COMPRESSION, this.json = t, this.dracoLoader = e, this.dracoLoader.preload();
    }
    decodePrimitive(t, e) {
      const n = this.json, i = this.dracoLoader, s = t.extensions[this.name].bufferView, a = t.extensions[this.name].attributes, o = {}, c = {}, l = {};
      for (const h in a) {
        const d = Cc[h] || h.toLowerCase();
        o[d] = a[h];
      }
      for (const h in t.attributes) {
        const d = Cc[h] || h.toLowerCase();
        if (a[h] !== void 0) {
          const u = n.accessors[t.attributes[h]], p = yr[u.componentType];
          l[d] = p.name, c[d] = u.normalized === true;
        }
      }
      return e.getDependency("bufferView", s).then(function(h) {
        return new Promise(function(d, u) {
          i.decodeDracoFile(h, function(p) {
            for (const w in p.attributes) {
              const b = p.attributes[w], m = c[w];
              m !== void 0 && (b.normalized = m);
            }
            d(p);
          }, o, l, je, u);
        });
      });
    }
  }
  class K1 {
    constructor() {
      this.name = $t.KHR_TEXTURE_TRANSFORM;
    }
    extendTexture(t, e) {
      return (e.texCoord === void 0 || e.texCoord === t.channel) && e.offset === void 0 && e.rotation === void 0 && e.scale === void 0 || (t = t.clone(), e.texCoord !== void 0 && (t.channel = e.texCoord), e.offset !== void 0 && t.offset.fromArray(e.offset), e.rotation !== void 0 && (t.rotation = e.rotation), e.scale !== void 0 && t.repeat.fromArray(e.scale), t.needsUpdate = true), t;
    }
  }
  class Y1 {
    constructor() {
      this.name = $t.KHR_MESH_QUANTIZATION;
    }
  }
  class hp extends vs {
    constructor(t, e, n, i) {
      super(t, e, n, i);
    }
    copySampleValue_(t) {
      const e = this.resultBuffer, n = this.sampleValues, i = this.valueSize, s = t * i * 3 + i;
      for (let a = 0; a !== i; a++) e[a] = n[s + a];
      return e;
    }
    interpolate_(t, e, n, i) {
      const s = this.resultBuffer, a = this.sampleValues, o = this.valueSize, c = o * 2, l = o * 3, h = i - e, d = (n - e) / h, u = d * d, p = u * d, w = t * l, b = w - l, m = -2 * p + 3 * u, _ = p - u, E = 1 - m, v = _ - u + d;
      for (let T = 0; T !== o; T++) {
        const O = a[b + T + o], R = a[b + T + c] * h, P = a[w + T + o], z = a[w + T] * h;
        s[T] = E * O + v * R + m * P + _ * z;
      }
      return s;
    }
  }
  const Z1 = new Ve();
  class $1 extends hp {
    interpolate_(t, e, n, i) {
      const s = super.interpolate_(t, e, n, i);
      return Z1.fromArray(s).normalize().toArray(s), s;
    }
  }
  const fn = {
    POINTS: 0,
    LINES: 1,
    LINE_LOOP: 2,
    LINE_STRIP: 3,
    TRIANGLES: 4,
    TRIANGLE_STRIP: 5,
    TRIANGLE_FAN: 6
  }, yr = {
    5120: Int8Array,
    5121: Uint8Array,
    5122: Int16Array,
    5123: Uint16Array,
    5125: Uint32Array,
    5126: Float32Array
  }, $d = {
    9728: en,
    9729: dn,
    9984: du,
    9985: da,
    9986: ts,
    9987: Zn
  }, Jd = {
    33071: wi,
    33648: fa,
    10497: Oi
  }, pc = {
    SCALAR: 1,
    VEC2: 2,
    VEC3: 3,
    VEC4: 4,
    MAT2: 4,
    MAT3: 9,
    MAT4: 16
  }, Cc = {
    POSITION: "position",
    NORMAL: "normal",
    TANGENT: "tangent",
    TEXCOORD_0: "uv",
    TEXCOORD_1: "uv1",
    TEXCOORD_2: "uv2",
    TEXCOORD_3: "uv3",
    COLOR_0: "color",
    WEIGHTS_0: "skinWeight",
    JOINTS_0: "skinIndex"
  }, fi = {
    scale: "scale",
    translation: "position",
    rotation: "quaternion",
    weights: "morphTargetInfluences"
  }, J1 = {
    CUBICSPLINE: void 0,
    LINEAR: ls,
    STEP: cs
  }, fc = {
    OPAQUE: "OPAQUE",
    MASK: "MASK",
    BLEND: "BLEND"
  };
  function Q1(r) {
    return r.DefaultMaterial === void 0 && (r.DefaultMaterial = new Un({
      color: 16777215,
      emissive: 0,
      metalness: 1,
      roughness: 1,
      transparent: false,
      depthTest: true,
      side: Jn
    })), r.DefaultMaterial;
  }
  function Di(r, t, e) {
    for (const n in e.extensions) r[n] === void 0 && (t.userData.gltfExtensions = t.userData.gltfExtensions || {}, t.userData.gltfExtensions[n] = e.extensions[n]);
  }
  function Yn(r, t) {
    t.extras !== void 0 && (typeof t.extras == "object" ? Object.assign(r.userData, t.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + t.extras));
  }
  function tP(r, t, e) {
    let n = false, i = false, s = false;
    for (let l = 0, h = t.length; l < h; l++) {
      const d = t[l];
      if (d.POSITION !== void 0 && (n = true), d.NORMAL !== void 0 && (i = true), d.COLOR_0 !== void 0 && (s = true), n && i && s) break;
    }
    if (!n && !i && !s) return Promise.resolve(r);
    const a = [], o = [], c = [];
    for (let l = 0, h = t.length; l < h; l++) {
      const d = t[l];
      if (n) {
        const u = d.POSITION !== void 0 ? e.getDependency("accessor", d.POSITION) : r.attributes.position;
        a.push(u);
      }
      if (i) {
        const u = d.NORMAL !== void 0 ? e.getDependency("accessor", d.NORMAL) : r.attributes.normal;
        o.push(u);
      }
      if (s) {
        const u = d.COLOR_0 !== void 0 ? e.getDependency("accessor", d.COLOR_0) : r.attributes.color;
        c.push(u);
      }
    }
    return Promise.all([
      Promise.all(a),
      Promise.all(o),
      Promise.all(c)
    ]).then(function(l) {
      const h = l[0], d = l[1], u = l[2];
      return n && (r.morphAttributes.position = h), i && (r.morphAttributes.normal = d), s && (r.morphAttributes.color = u), r.morphTargetsRelative = true, r;
    });
  }
  function eP(r, t) {
    if (r.updateMorphTargets(), t.weights !== void 0) for (let e = 0, n = t.weights.length; e < n; e++) r.morphTargetInfluences[e] = t.weights[e];
    if (t.extras && Array.isArray(t.extras.targetNames)) {
      const e = t.extras.targetNames;
      if (r.morphTargetInfluences.length === e.length) {
        r.morphTargetDictionary = {};
        for (let n = 0, i = e.length; n < i; n++) r.morphTargetDictionary[e[n]] = n;
      } else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.");
    }
  }
  function nP(r) {
    let t;
    const e = r.extensions && r.extensions[$t.KHR_DRACO_MESH_COMPRESSION];
    if (e ? t = "draco:" + e.bufferView + ":" + e.indices + ":" + _c(e.attributes) : t = r.indices + ":" + _c(r.attributes) + ":" + r.mode, r.targets !== void 0) for (let n = 0, i = r.targets.length; n < i; n++) t += ":" + _c(r.targets[n]);
    return t;
  }
  function _c(r) {
    let t = "";
    const e = Object.keys(r).sort();
    for (let n = 0, i = e.length; n < i; n++) t += e[n] + ":" + r[e[n]] + ";";
    return t;
  }
  function Pc(r) {
    switch (r) {
      case Int8Array:
        return 1 / 127;
      case Uint8Array:
        return 1 / 255;
      case Int16Array:
        return 1 / 32767;
      case Uint16Array:
        return 1 / 65535;
      default:
        throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.");
    }
  }
  function iP(r) {
    return r.search(/\.jpe?g($|\?)/i) > 0 || r.search(/^data\:image\/jpeg/) === 0 ? "image/jpeg" : r.search(/\.webp($|\?)/i) > 0 || r.search(/^data\:image\/webp/) === 0 ? "image/webp" : "image/png";
  }
  const rP = new Ht();
  class sP {
    constructor(t = {}, e = {}) {
      this.json = t, this.extensions = {}, this.plugins = {}, this.options = e, this.cache = new A1(), this.associations = /* @__PURE__ */ new Map(), this.primitiveCache = {}, this.nodeCache = {}, this.meshCache = {
        refs: {},
        uses: {}
      }, this.cameraCache = {
        refs: {},
        uses: {}
      }, this.lightCache = {
        refs: {},
        uses: {}
      }, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {};
      let n = false, i = false, s = -1;
      typeof navigator < "u" && (n = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === true, i = navigator.userAgent.indexOf("Firefox") > -1, s = i ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1), typeof createImageBitmap > "u" || n || i && s < 98 ? this.textureLoader = new Ju(this.options.manager) : this.textureLoader = new bb(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new $u(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), this.options.crossOrigin === "use-credentials" && this.fileLoader.setWithCredentials(true);
    }
    setExtensions(t) {
      this.extensions = t;
    }
    setPlugins(t) {
      this.plugins = t;
    }
    parse(t, e) {
      const n = this, i = this.json, s = this.extensions;
      this.cache.removeAll(), this.nodeCache = {}, this._invokeAll(function(a) {
        return a._markDefs && a._markDefs();
      }), Promise.all(this._invokeAll(function(a) {
        return a.beforeRoot && a.beforeRoot();
      })).then(function() {
        return Promise.all([
          n.getDependencies("scene"),
          n.getDependencies("animation"),
          n.getDependencies("camera")
        ]);
      }).then(function(a) {
        const o = {
          scene: a[0][i.scene || 0],
          scenes: a[0],
          animations: a[1],
          cameras: a[2],
          asset: i.asset,
          parser: n,
          userData: {}
        };
        return Di(s, o, i), Yn(o, i), Promise.all(n._invokeAll(function(c) {
          return c.afterRoot && c.afterRoot(o);
        })).then(function() {
          for (const c of o.scenes) c.updateMatrixWorld();
          t(o);
        });
      }).catch(e);
    }
    _markDefs() {
      const t = this.json.nodes || [], e = this.json.skins || [], n = this.json.meshes || [];
      for (let i = 0, s = e.length; i < s; i++) {
        const a = e[i].joints;
        for (let o = 0, c = a.length; o < c; o++) t[a[o]].isBone = true;
      }
      for (let i = 0, s = t.length; i < s; i++) {
        const a = t[i];
        a.mesh !== void 0 && (this._addNodeRef(this.meshCache, a.mesh), a.skin !== void 0 && (n[a.mesh].isSkinnedMesh = true)), a.camera !== void 0 && this._addNodeRef(this.cameraCache, a.camera);
      }
    }
    _addNodeRef(t, e) {
      e !== void 0 && (t.refs[e] === void 0 && (t.refs[e] = t.uses[e] = 0), t.refs[e]++);
    }
    _getNodeRef(t, e, n) {
      if (t.refs[e] <= 1) return n;
      const i = n.clone(), s = (a, o) => {
        const c = this.associations.get(a);
        c != null && this.associations.set(o, c);
        for (const [l, h] of a.children.entries()) s(h, o.children[l]);
      };
      return s(n, i), i.name += "_instance_" + t.uses[e]++, i;
    }
    _invokeOne(t) {
      const e = Object.values(this.plugins);
      e.push(this);
      for (let n = 0; n < e.length; n++) {
        const i = t(e[n]);
        if (i) return i;
      }
      return null;
    }
    _invokeAll(t) {
      const e = Object.values(this.plugins);
      e.unshift(this);
      const n = [];
      for (let i = 0; i < e.length; i++) {
        const s = t(e[i]);
        s && n.push(s);
      }
      return n;
    }
    getDependency(t, e) {
      const n = t + ":" + e;
      let i = this.cache.get(n);
      if (!i) {
        switch (t) {
          case "scene":
            i = this.loadScene(e);
            break;
          case "node":
            i = this._invokeOne(function(s) {
              return s.loadNode && s.loadNode(e);
            });
            break;
          case "mesh":
            i = this._invokeOne(function(s) {
              return s.loadMesh && s.loadMesh(e);
            });
            break;
          case "accessor":
            i = this.loadAccessor(e);
            break;
          case "bufferView":
            i = this._invokeOne(function(s) {
              return s.loadBufferView && s.loadBufferView(e);
            });
            break;
          case "buffer":
            i = this.loadBuffer(e);
            break;
          case "material":
            i = this._invokeOne(function(s) {
              return s.loadMaterial && s.loadMaterial(e);
            });
            break;
          case "texture":
            i = this._invokeOne(function(s) {
              return s.loadTexture && s.loadTexture(e);
            });
            break;
          case "skin":
            i = this.loadSkin(e);
            break;
          case "animation":
            i = this._invokeOne(function(s) {
              return s.loadAnimation && s.loadAnimation(e);
            });
            break;
          case "camera":
            i = this.loadCamera(e);
            break;
          default:
            if (i = this._invokeOne(function(s) {
              return s != this && s.getDependency && s.getDependency(t, e);
            }), !i) throw new Error("Unknown type: " + t);
            break;
        }
        this.cache.add(n, i);
      }
      return i;
    }
    getDependencies(t) {
      let e = this.cache.get(t);
      if (!e) {
        const n = this, i = this.json[t + (t === "mesh" ? "es" : "s")] || [];
        e = Promise.all(i.map(function(s, a) {
          return n.getDependency(t, a);
        })), this.cache.add(t, e);
      }
      return e;
    }
    loadBuffer(t) {
      const e = this.json.buffers[t], n = this.fileLoader;
      if (e.type && e.type !== "arraybuffer") throw new Error("THREE.GLTFLoader: " + e.type + " buffer type is not supported.");
      if (e.uri === void 0 && t === 0) return Promise.resolve(this.extensions[$t.KHR_BINARY_GLTF].body);
      const i = this.options;
      return new Promise(function(s, a) {
        n.load(as.resolveURL(e.uri, i.path), s, void 0, function() {
          a(new Error('THREE.GLTFLoader: Failed to load buffer "' + e.uri + '".'));
        });
      });
    }
    loadBufferView(t) {
      const e = this.json.bufferViews[t];
      return this.getDependency("buffer", e.buffer).then(function(n) {
        const i = e.byteLength || 0, s = e.byteOffset || 0;
        return n.slice(s, s + i);
      });
    }
    loadAccessor(t) {
      const e = this, n = this.json, i = this.json.accessors[t];
      if (i.bufferView === void 0 && i.sparse === void 0) {
        const a = pc[i.type], o = yr[i.componentType], c = i.normalized === true, l = new o(i.count * a);
        return Promise.resolve(new rn(l, a, c));
      }
      const s = [];
      return i.bufferView !== void 0 ? s.push(this.getDependency("bufferView", i.bufferView)) : s.push(null), i.sparse !== void 0 && (s.push(this.getDependency("bufferView", i.sparse.indices.bufferView)), s.push(this.getDependency("bufferView", i.sparse.values.bufferView))), Promise.all(s).then(function(a) {
        const o = a[0], c = pc[i.type], l = yr[i.componentType], h = l.BYTES_PER_ELEMENT, d = h * c, u = i.byteOffset || 0, p = i.bufferView !== void 0 ? n.bufferViews[i.bufferView].byteStride : void 0, w = i.normalized === true;
        let b, m;
        if (p && p !== d) {
          const _ = Math.floor(u / p), E = "InterleavedBuffer:" + i.bufferView + ":" + i.componentType + ":" + _ + ":" + i.count;
          let v = e.cache.get(E);
          v || (b = new l(o, _ * p, i.count * p / h), v = new Hu(b, p / h), e.cache.add(E, v)), m = new ds(v, c, u % p / h, w);
        } else o === null ? b = new l(i.count * c) : b = new l(o, u, i.count * c), m = new rn(b, c, w);
        if (i.sparse !== void 0) {
          const _ = pc.SCALAR, E = yr[i.sparse.indices.componentType], v = i.sparse.indices.byteOffset || 0, T = i.sparse.values.byteOffset || 0, O = new E(a[1], v, i.sparse.count * _), R = new l(a[2], T, i.sparse.count * c);
          o !== null && (m = new rn(m.array.slice(), m.itemSize, m.normalized));
          for (let P = 0, z = O.length; P < z; P++) {
            const A = O[P];
            if (m.setX(A, R[P * c]), c >= 2 && m.setY(A, R[P * c + 1]), c >= 3 && m.setZ(A, R[P * c + 2]), c >= 4 && m.setW(A, R[P * c + 3]), c >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");
          }
        }
        return m;
      });
    }
    loadTexture(t) {
      const e = this.json, n = this.options, s = e.textures[t].source, a = e.images[s];
      let o = this.textureLoader;
      if (a.uri) {
        const c = n.manager.getHandler(a.uri);
        c !== null && (o = c);
      }
      return this.loadTextureImage(t, s, o);
    }
    loadTextureImage(t, e, n) {
      const i = this, s = this.json, a = s.textures[t], o = s.images[e], c = (o.uri || o.bufferView) + ":" + a.sampler;
      if (this.textureCache[c]) return this.textureCache[c];
      const l = this.loadImageSource(e, n).then(function(h) {
        h.flipY = false, h.name = a.name || o.name || "", h.name === "" && typeof o.uri == "string" && o.uri.startsWith("data:image/") === false && (h.name = o.uri);
        const u = (s.samplers || {})[a.sampler] || {};
        return h.magFilter = $d[u.magFilter] || dn, h.minFilter = $d[u.minFilter] || Zn, h.wrapS = Jd[u.wrapS] || Oi, h.wrapT = Jd[u.wrapT] || Oi, i.associations.set(h, {
          textures: t
        }), h;
      }).catch(function() {
        return null;
      });
      return this.textureCache[c] = l, l;
    }
    loadImageSource(t, e) {
      const n = this, i = this.json, s = this.options;
      if (this.sourceCache[t] !== void 0) return this.sourceCache[t].then((d) => d.clone());
      const a = i.images[t], o = self.URL || self.webkitURL;
      let c = a.uri || "", l = false;
      if (a.bufferView !== void 0) c = n.getDependency("bufferView", a.bufferView).then(function(d) {
        l = true;
        const u = new Blob([
          d
        ], {
          type: a.mimeType
        });
        return c = o.createObjectURL(u), c;
      });
      else if (a.uri === void 0) throw new Error("THREE.GLTFLoader: Image " + t + " is missing URI and bufferView");
      const h = Promise.resolve(c).then(function(d) {
        return new Promise(function(u, p) {
          let w = u;
          e.isImageBitmapLoader === true && (w = function(b) {
            const m = new Ne(b);
            m.needsUpdate = true, u(m);
          }), e.load(as.resolveURL(d, s.path), w, void 0, p);
        });
      }).then(function(d) {
        return l === true && o.revokeObjectURL(c), Yn(d, a), d.userData.mimeType = a.mimeType || iP(a.uri), d;
      }).catch(function(d) {
        throw console.error("THREE.GLTFLoader: Couldn't load texture", c), d;
      });
      return this.sourceCache[t] = h, h;
    }
    assignTexture(t, e, n, i) {
      const s = this;
      return this.getDependency("texture", n.index).then(function(a) {
        if (!a) return null;
        if (n.texCoord !== void 0 && n.texCoord > 0 && (a = a.clone(), a.channel = n.texCoord), s.extensions[$t.KHR_TEXTURE_TRANSFORM]) {
          const o = n.extensions !== void 0 ? n.extensions[$t.KHR_TEXTURE_TRANSFORM] : void 0;
          if (o) {
            const c = s.associations.get(a);
            a = s.extensions[$t.KHR_TEXTURE_TRANSFORM].extendTexture(a, o), s.associations.set(a, c);
          }
        }
        return i !== void 0 && (a.colorSpace = i), t[e] = a, a;
      });
    }
    assignFinalMaterial(t) {
      const e = t.geometry;
      let n = t.material;
      const i = e.attributes.tangent === void 0, s = e.attributes.color !== void 0, a = e.attributes.normal === void 0;
      if (t.isPoints) {
        const o = "PointsMaterial:" + n.uuid;
        let c = this.cache.get(o);
        c || (c = new Ku(), Rn.prototype.copy.call(c, n), c.color.copy(n.color), c.map = n.map, c.sizeAttenuation = false, this.cache.add(o, c)), n = c;
      } else if (t.isLine) {
        const o = "LineBasicMaterial:" + n.uuid;
        let c = this.cache.get(o);
        c || (c = new Ha(), Rn.prototype.copy.call(c, n), c.color.copy(n.color), c.map = n.map, this.cache.add(o, c)), n = c;
      }
      if (i || s || a) {
        let o = "ClonedMaterial:" + n.uuid + ":";
        i && (o += "derivative-tangents:"), s && (o += "vertex-colors:"), a && (o += "flat-shading:");
        let c = this.cache.get(o);
        c || (c = n.clone(), s && (c.vertexColors = true), a && (c.flatShading = true), i && (c.normalScale && (c.normalScale.y *= -1), c.clearcoatNormalScale && (c.clearcoatNormalScale.y *= -1)), this.cache.add(o, c), this.associations.set(c, this.associations.get(n))), n = c;
      }
      t.material = n;
    }
    getMaterialType() {
      return Un;
    }
    loadMaterial(t) {
      const e = this, n = this.json, i = this.extensions, s = n.materials[t];
      let a;
      const o = {}, c = s.extensions || {}, l = [];
      if (c[$t.KHR_MATERIALS_UNLIT]) {
        const d = i[$t.KHR_MATERIALS_UNLIT];
        a = d.getMaterialType(), l.push(d.extendParams(o, s, e));
      } else {
        const d = s.pbrMetallicRoughness || {};
        if (o.color = new Ct(1, 1, 1), o.opacity = 1, Array.isArray(d.baseColorFactor)) {
          const u = d.baseColorFactor;
          o.color.setRGB(u[0], u[1], u[2], je), o.opacity = u[3];
        }
        d.baseColorTexture !== void 0 && l.push(e.assignTexture(o, "map", d.baseColorTexture, Ke)), o.metalness = d.metallicFactor !== void 0 ? d.metallicFactor : 1, o.roughness = d.roughnessFactor !== void 0 ? d.roughnessFactor : 1, d.metallicRoughnessTexture !== void 0 && (l.push(e.assignTexture(o, "metalnessMap", d.metallicRoughnessTexture)), l.push(e.assignTexture(o, "roughnessMap", d.metallicRoughnessTexture))), a = this._invokeOne(function(u) {
          return u.getMaterialType && u.getMaterialType(t);
        }), l.push(Promise.all(this._invokeAll(function(u) {
          return u.extendMaterialParams && u.extendMaterialParams(t, o);
        })));
      }
      s.doubleSided === true && (o.side = Mn);
      const h = s.alphaMode || fc.OPAQUE;
      if (h === fc.BLEND ? (o.transparent = true, o.depthWrite = false) : (o.transparent = false, h === fc.MASK && (o.alphaTest = s.alphaCutoff !== void 0 ? s.alphaCutoff : 0.5)), s.normalTexture !== void 0 && a !== Nn && (l.push(e.assignTexture(o, "normalMap", s.normalTexture)), o.normalScale = new vt(1, 1), s.normalTexture.scale !== void 0)) {
        const d = s.normalTexture.scale;
        o.normalScale.set(d, d);
      }
      if (s.occlusionTexture !== void 0 && a !== Nn && (l.push(e.assignTexture(o, "aoMap", s.occlusionTexture)), s.occlusionTexture.strength !== void 0 && (o.aoMapIntensity = s.occlusionTexture.strength)), s.emissiveFactor !== void 0 && a !== Nn) {
        const d = s.emissiveFactor;
        o.emissive = new Ct().setRGB(d[0], d[1], d[2], je);
      }
      return s.emissiveTexture !== void 0 && a !== Nn && l.push(e.assignTexture(o, "emissiveMap", s.emissiveTexture, Ke)), Promise.all(l).then(function() {
        const d = new a(o);
        return s.name && (d.name = s.name), Yn(d, s), e.associations.set(d, {
          materials: t
        }), s.extensions && Di(i, d, s), d;
      });
    }
    createUniqueName(t) {
      const e = oe.sanitizeNodeName(t || "");
      return e in this.nodeNamesUsed ? e + "_" + ++this.nodeNamesUsed[e] : (this.nodeNamesUsed[e] = 0, e);
    }
    loadGeometries(t) {
      const e = this, n = this.extensions, i = this.primitiveCache;
      function s(o) {
        return n[$t.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(o, e).then(function(c) {
          return Qd(c, o, e);
        });
      }
      const a = [];
      for (let o = 0, c = t.length; o < c; o++) {
        const l = t[o], h = nP(l), d = i[h];
        if (d) a.push(d.promise);
        else {
          let u;
          l.extensions && l.extensions[$t.KHR_DRACO_MESH_COMPRESSION] ? u = s(l) : u = Qd(new sn(), l, e), i[h] = {
            primitive: l,
            promise: u
          }, a.push(u);
        }
      }
      return Promise.all(a);
    }
    loadMesh(t) {
      const e = this, n = this.json, i = this.extensions, s = n.meshes[t], a = s.primitives, o = [];
      for (let c = 0, l = a.length; c < l; c++) {
        const h = a[c].material === void 0 ? Q1(this.cache) : this.getDependency("material", a[c].material);
        o.push(h);
      }
      return o.push(e.loadGeometries(a)), Promise.all(o).then(function(c) {
        const l = c.slice(0, c.length - 1), h = c[c.length - 1], d = [];
        for (let p = 0, w = h.length; p < w; p++) {
          const b = h[p], m = a[p];
          let _;
          const E = l[p];
          if (m.mode === fn.TRIANGLES || m.mode === fn.TRIANGLE_STRIP || m.mode === fn.TRIANGLE_FAN || m.mode === void 0) _ = s.isSkinnedMesh === true ? new K0(b, E) : new fe(b, E), _.isSkinnedMesh === true && _.normalizeSkinWeights(), m.mode === fn.TRIANGLE_STRIP ? _.geometry = Yd(_.geometry, bu) : m.mode === fn.TRIANGLE_FAN && (_.geometry = Yd(_.geometry, xc));
          else if (m.mode === fn.LINES) _ = new Xu(b, E);
          else if (m.mode === fn.LINE_STRIP) _ = new zc(b, E);
          else if (m.mode === fn.LINE_LOOP) _ = new qu(b, E);
          else if (m.mode === fn.POINTS) _ = new J0(b, E);
          else throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + m.mode);
          Object.keys(_.geometry.morphAttributes).length > 0 && eP(_, s), _.name = e.createUniqueName(s.name || "mesh_" + t), Yn(_, s), m.extensions && Di(i, _, m), e.assignFinalMaterial(_), d.push(_);
        }
        for (let p = 0, w = d.length; p < w; p++) e.associations.set(d[p], {
          meshes: t,
          primitives: p
        });
        if (d.length === 1) return s.extensions && Di(i, d[0], s), d[0];
        const u = new Ye();
        s.extensions && Di(i, u, s), e.associations.set(u, {
          meshes: t
        });
        for (let p = 0, w = d.length; p < w; p++) u.add(d[p]);
        return u;
      });
    }
    loadCamera(t) {
      let e;
      const n = this.json.cameras[t], i = n[n.type];
      if (!i) {
        console.warn("THREE.GLTFLoader: Missing camera parameters.");
        return;
      }
      return n.type === "perspective" ? e = new tn(we.radToDeg(i.yfov), i.aspectRatio || 1, i.znear || 1, i.zfar || 2e6) : n.type === "orthographic" && (e = new Fc(-i.xmag, i.xmag, i.ymag, -i.ymag, i.znear, i.zfar)), n.name && (e.name = this.createUniqueName(n.name)), Yn(e, n), Promise.resolve(e);
    }
    loadSkin(t) {
      const e = this.json.skins[t], n = [];
      for (let i = 0, s = e.joints.length; i < s; i++) n.push(this._loadNodeShallow(e.joints[i]));
      return e.inverseBindMatrices !== void 0 ? n.push(this.getDependency("accessor", e.inverseBindMatrices)) : n.push(null), Promise.all(n).then(function(i) {
        const s = i.pop(), a = i, o = [], c = [];
        for (let l = 0, h = a.length; l < h; l++) {
          const d = a[l];
          if (d) {
            o.push(d);
            const u = new Ht();
            s !== null && u.fromArray(s.array, l * 16), c.push(u);
          } else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', e.joints[l]);
        }
        return new Bc(o, c);
      });
    }
    loadAnimation(t) {
      const e = this.json, n = this, i = e.animations[t], s = i.name ? i.name : "animation_" + t, a = [], o = [], c = [], l = [], h = [];
      for (let d = 0, u = i.channels.length; d < u; d++) {
        const p = i.channels[d], w = i.samplers[p.sampler], b = p.target, m = b.node, _ = i.parameters !== void 0 ? i.parameters[w.input] : w.input, E = i.parameters !== void 0 ? i.parameters[w.output] : w.output;
        b.node !== void 0 && (a.push(this.getDependency("node", m)), o.push(this.getDependency("accessor", _)), c.push(this.getDependency("accessor", E)), l.push(w), h.push(b));
      }
      return Promise.all([
        Promise.all(a),
        Promise.all(o),
        Promise.all(c),
        Promise.all(l),
        Promise.all(h)
      ]).then(function(d) {
        const u = d[0], p = d[1], w = d[2], b = d[3], m = d[4], _ = [];
        for (let E = 0, v = u.length; E < v; E++) {
          const T = u[E], O = p[E], R = w[E], P = b[E], z = m[E];
          if (T === void 0) continue;
          T.updateMatrix && T.updateMatrix();
          const A = n._createAnimationTracks(T, O, R, P, z);
          if (A) for (let S = 0; S < A.length; S++) _.push(A[S]);
        }
        return new ab(s, void 0, _);
      });
    }
    createNodeMesh(t) {
      const e = this.json, n = this, i = e.nodes[t];
      return i.mesh === void 0 ? null : n.getDependency("mesh", i.mesh).then(function(s) {
        const a = n._getNodeRef(n.meshCache, i.mesh, s);
        return i.weights !== void 0 && a.traverse(function(o) {
          if (o.isMesh) for (let c = 0, l = i.weights.length; c < l; c++) o.morphTargetInfluences[c] = i.weights[c];
        }), a;
      });
    }
    loadNode(t) {
      const e = this.json, n = this, i = e.nodes[t], s = n._loadNodeShallow(t), a = [], o = i.children || [];
      for (let l = 0, h = o.length; l < h; l++) a.push(n.getDependency("node", o[l]));
      const c = i.skin === void 0 ? Promise.resolve(null) : n.getDependency("skin", i.skin);
      return Promise.all([
        s,
        Promise.all(a),
        c
      ]).then(function(l) {
        const h = l[0], d = l[1], u = l[2];
        u !== null && h.traverse(function(p) {
          p.isSkinnedMesh && p.bind(u, rP);
        });
        for (let p = 0, w = d.length; p < w; p++) h.add(d[p]);
        return h;
      });
    }
    _loadNodeShallow(t) {
      const e = this.json, n = this.extensions, i = this;
      if (this.nodeCache[t] !== void 0) return this.nodeCache[t];
      const s = e.nodes[t], a = s.name ? i.createUniqueName(s.name) : "", o = [], c = i._invokeOne(function(l) {
        return l.createNodeMesh && l.createNodeMesh(t);
      });
      return c && o.push(c), s.camera !== void 0 && o.push(i.getDependency("camera", s.camera).then(function(l) {
        return i._getNodeRef(i.cameraCache, s.camera, l);
      })), i._invokeAll(function(l) {
        return l.createNodeAttachment && l.createNodeAttachment(t);
      }).forEach(function(l) {
        o.push(l);
      }), this.nodeCache[t] = Promise.all(o).then(function(l) {
        let h;
        if (s.isBone === true ? h = new Wu() : l.length > 1 ? h = new Ye() : l.length === 1 ? h = l[0] : h = new _e(), h !== l[0]) for (let d = 0, u = l.length; d < u; d++) h.add(l[d]);
        if (s.name && (h.userData.name = s.name, h.name = a), Yn(h, s), s.extensions && Di(n, h, s), s.matrix !== void 0) {
          const d = new Ht();
          d.fromArray(s.matrix), h.applyMatrix4(d);
        } else s.translation !== void 0 && h.position.fromArray(s.translation), s.rotation !== void 0 && h.quaternion.fromArray(s.rotation), s.scale !== void 0 && h.scale.fromArray(s.scale);
        return i.associations.has(h) || i.associations.set(h, {}), i.associations.get(h).nodes = t, h;
      }), this.nodeCache[t];
    }
    loadScene(t) {
      const e = this.extensions, n = this.json.scenes[t], i = this, s = new Ye();
      n.name && (s.name = i.createUniqueName(n.name)), Yn(s, n), n.extensions && Di(e, s, n);
      const a = n.nodes || [], o = [];
      for (let c = 0, l = a.length; c < l; c++) o.push(i.getDependency("node", a[c]));
      return Promise.all(o).then(function(c) {
        for (let h = 0, d = c.length; h < d; h++) s.add(c[h]);
        const l = (h) => {
          const d = /* @__PURE__ */ new Map();
          for (const [u, p] of i.associations) (u instanceof Rn || u instanceof Ne) && d.set(u, p);
          return h.traverse((u) => {
            const p = i.associations.get(u);
            p != null && d.set(u, p);
          }), d;
        };
        return i.associations = l(s), s;
      });
    }
    _createAnimationTracks(t, e, n, i, s) {
      const a = [], o = t.name ? t.name : t.uuid, c = [];
      fi[s.path] === fi.weights ? t.traverse(function(u) {
        u.morphTargetInfluences && c.push(u.name ? u.name : u.uuid);
      }) : c.push(o);
      let l;
      switch (fi[s.path]) {
        case fi.weights:
          l = Rr;
          break;
        case fi.rotation:
          l = Cr;
          break;
        case fi.position:
        case fi.scale:
          l = Pr;
          break;
        default:
          switch (n.itemSize) {
            case 1:
              l = Rr;
              break;
            case 2:
            case 3:
            default:
              l = Pr;
              break;
          }
          break;
      }
      const h = i.interpolation !== void 0 ? J1[i.interpolation] : ls, d = this._getArrayFromAccessor(n);
      for (let u = 0, p = c.length; u < p; u++) {
        const w = new l(c[u] + "." + fi[s.path], e.array, d, h);
        i.interpolation === "CUBICSPLINE" && this._createCubicSplineTrackInterpolant(w), a.push(w);
      }
      return a;
    }
    _getArrayFromAccessor(t) {
      let e = t.array;
      if (t.normalized) {
        const n = Pc(e.constructor), i = new Float32Array(e.length);
        for (let s = 0, a = e.length; s < a; s++) i[s] = e[s] * n;
        e = i;
      }
      return e;
    }
    _createCubicSplineTrackInterpolant(t) {
      t.createInterpolant = function(n) {
        const i = this instanceof Cr ? $1 : hp;
        return new i(this.times, this.values, this.getValueSize() / 3, n);
      }, t.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;
    }
  }
  function aP(r, t, e) {
    const n = t.attributes, i = new Fn();
    if (n.POSITION !== void 0) {
      const o = e.json.accessors[n.POSITION], c = o.min, l = o.max;
      if (c !== void 0 && l !== void 0) {
        if (i.set(new L(c[0], c[1], c[2]), new L(l[0], l[1], l[2])), o.normalized) {
          const h = Pc(yr[o.componentType]);
          i.min.multiplyScalar(h), i.max.multiplyScalar(h);
        }
      } else {
        console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
        return;
      }
    } else return;
    const s = t.targets;
    if (s !== void 0) {
      const o = new L(), c = new L();
      for (let l = 0, h = s.length; l < h; l++) {
        const d = s[l];
        if (d.POSITION !== void 0) {
          const u = e.json.accessors[d.POSITION], p = u.min, w = u.max;
          if (p !== void 0 && w !== void 0) {
            if (c.setX(Math.max(Math.abs(p[0]), Math.abs(w[0]))), c.setY(Math.max(Math.abs(p[1]), Math.abs(w[1]))), c.setZ(Math.max(Math.abs(p[2]), Math.abs(w[2]))), u.normalized) {
              const b = Pc(yr[u.componentType]);
              c.multiplyScalar(b);
            }
            o.max(c);
          } else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
        }
      }
      i.expandByVector(o);
    }
    r.boundingBox = i;
    const a = new On();
    i.getCenter(a.center), a.radius = i.min.distanceTo(i.max) / 2, r.boundingSphere = a;
  }
  function Qd(r, t, e) {
    const n = t.attributes, i = [];
    function s(a, o) {
      return e.getDependency("accessor", a).then(function(c) {
        r.setAttribute(o, c);
      });
    }
    for (const a in n) {
      const o = Cc[a] || a.toLowerCase();
      o in r.attributes || i.push(s(n[a], o));
    }
    if (t.indices !== void 0 && !r.index) {
      const a = e.getDependency("accessor", t.indices).then(function(o) {
        r.setIndex(o);
      });
      i.push(a);
    }
    return ie.workingColorSpace !== je && "COLOR_0" in n && console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${ie.workingColorSpace}" not supported.`), Yn(r, t), aP(r, t, e), Promise.all(i).then(function() {
      return t.targets !== void 0 ? tP(r, t.targets, e) : r;
    });
  }
  const oP = "/src/assets/models/car/nissan_detailed/", cP = [
    "tire_fl.glb",
    "tire_fr.glb",
    "tire_bl.glb",
    "tire_br.glb"
  ], dp = (r) => `${oP}${r}`;
  function lP(r) {
    const t = {
      x: 1,
      y: 0.35,
      z: 2
    }, e = new Cn(t.x * 2, t.y * 2, t.z * 2), n = new Un({
      color: 3368703
    }), i = new fe(e, n);
    i.castShadow = true, i.receiveShadow = true;
    const s = new Ga(r, r, 0.4, 16);
    s.rotateZ(Math.PI / 2);
    const a = new Un({
      color: 1118481
    }), o = Array.from({
      length: 4
    }, () => {
      const c = new fe(s, a);
      return c.castShadow = true, c.receiveShadow = true, c;
    });
    return {
      chassisMesh: i,
      wheelMeshes: o
    };
  }
  function hP(r = 1) {
    const t = new Al();
    return Promise.all(cP.map((e, n) => {
      const i = dp(e);
      return new Promise((s) => {
        t.load(i, (a) => {
          var _a2;
          const o = a.scene || ((_a2 = a.scenes) == null ? void 0 : _a2[0]);
          if (!o) {
            console.warn(`Wheel GLB missing scene: ${e}`), s(null);
            return;
          }
          o.scale.set(r, r, r), o.position.set(0, 0, 0), o.rotation.set(0, 0, 0), o.traverse((h) => {
            h.isMesh && (h.castShadow = true, h.receiveShadow = true);
          });
          const c = new Ye();
          c.add(o), o.updateWorldMatrix(true, true);
          const l = new Fn().setFromObject(o);
          if (!l.isEmpty()) {
            const h = l.getCenter(new L());
            o.position.sub(h), o.updateWorldMatrix(true, true);
          }
          s(c);
        }, void 0, (a) => {
          console.error(`Failed to load wheel model ${e}`, a), s(null);
        });
      });
    }));
  }
  function dP() {
    const r = new Al(), t = dp("car.glb");
    return new Promise((e, n) => {
      r.load(t, (i) => {
        var _a2;
        const s = i.scene || ((_a2 = i.scenes) == null ? void 0 : _a2[0]);
        if (!s) {
          n(new Error("No scene found in car GLB"));
          return;
        }
        const a = 1;
        s.scale.set(a, a, a), s.position.y = -0.5, s.traverse((o) => {
          o.isMesh && (o.castShadow = true, o.receiveShadow = true);
        }), hP(a).then((o) => {
          e({
            chassisMesh: s,
            wheelMeshes: o
          });
        }).catch(n);
      }, void 0, (i) => n(i));
    });
  }
  function uP({ detailed: r = false, wheelRadius: t = 0.5 } = {}) {
    return r ? dP() : Promise.resolve(lP(t));
  }
  class tu {
    constructor(t, e, n = false, i = {}) {
      const { enableKeyboard: s = true } = i;
      this.physics = t, this.world = t.world, this.scene = e, this.enableKeyboard = s, this.group = new Ye(), this.scene.add(this.group), this.debugPanel = new T1(), this.debugPanel.visible = false, this.maxEngineForce = 500, this.maxBrakeForce = 50, this.maxSteer = 0.7, this.suspensionRestLength = 0.35, this.wheelRadius = 0.5, this.frontWheelForwardOffset = this.wheelRadius * 0.75, this.chassisVisualDrop = this.wheelRadius * 0.7, this.leftWheelInwardOffset = this.wheelRadius * 0.75, this.rpm = 1e3, this.idleRpm = 1e3, this.maxRpm = 8e3, this.currentGear = 1, this.gearRatios = {
        "-1": 3,
        0: 0,
        1: 3.27,
        2: 2.13,
        3: 1.52,
        4: 1.16,
        5: 0.97,
        6: 0.77
      }, this.finalDrive = 3.4, this.shiftUpRpm = 7200, this.shiftDownRpm = 3e3, this.lastShiftTime = 0, this.shiftDuration = 0.2, this.engineBaseForce = 1500, this.throttleResponseTime = 0.3, this.launchFullSpeedMs = 18, this.minLaunchScale = 0.15, this.dragCoeff = 0.02, this.downforceCoeff = 0.1, this.sleepSpeedThreshold = 0.12, this.sleepInputThreshold = 0.05;
      const a = {
        x: 1.5,
        y: 0.35,
        z: 3.5
      };
      this.chassisHalfExtents = a;
      const o = mn.dynamic().setTranslation(0, 5, 0).setLinearDamping(0.1).setAngularDamping(0.5);
      this.chassisBody = this.world.createRigidBody(o);
      const c = be.cuboid(a.x, a.y, a.z).setTranslation(0, -0.25, 0).setFriction(1).setMass(800);
      this.world.createCollider(c, this.chassisBody), this.chassisMesh = null, this.vehicle = this.world.createVehicleController(this.chassisBody), this.vehicle.indexUpAxis = 1, this.vehicle.setIndexForwardAxis = 2;
      const l = new gn(0, -1, 0), h = new gn(-1, 0, 0), d = -0.1, u = [
        {
          pos: new gn(1.1700000000000002, d, 1.7999999999999998),
          steering: true
        },
        {
          pos: new gn(-1.1700000000000002, d, 1.7999999999999998),
          steering: true
        },
        {
          pos: new gn(1.1700000000000002, d, -1.7999999999999998),
          steering: false
        },
        {
          pos: new gn(-1.1700000000000002, d, -1.7999999999999998),
          steering: false
        }
      ];
      this.wheels = u, u.forEach(({ pos: w }) => {
        this.vehicle.addWheel(w, l, h, this.suspensionRestLength, this.wheelRadius);
      });
      const p = this.vehicle.numWheels();
      for (let w = 0; w < p; w++) {
        const b = w < 2, m = !b;
        this.vehicle.setWheelSuspensionRestLength(w, this.suspensionRestLength), this.vehicle.setWheelSuspensionStiffness(w, m ? 50 : 40), this.vehicle.setWheelSuspensionCompression(w, m ? 5 : 4), this.vehicle.setWheelSuspensionRelaxation(w, m ? 6 : 5), this.vehicle.setWheelMaxSuspensionForce(w, m ? 4e3 : 3e3), this.vehicle.setWheelMaxSuspensionTravel(w, 0.35), this.vehicle.setWheelFrictionSlip(w, 4), this.vehicle.setWheelSideFrictionStiffness(w, b ? 5 : 4), this.vehicle.setWheelBrake(w, 0), this.vehicle.setWheelEngineForce(w, 0), this.vehicle.setWheelSteering(w, 0);
      }
      this.wheelSlots = [], this.wheelSteerPivots = [], this.wheelRollPivots = [];
      for (let w = 0; w < p; w++) {
        const b = new Ye(), m = new Ye(), _ = new Ye();
        m.add(_), b.add(m), this.group.add(b), this.wheelSlots.push(b), this.wheelSteerPivots.push(m), this.wheelRollPivots.push(_);
      }
      uP({
        detailed: n,
        wheelRadius: this.wheelRadius
      }).then(({ chassisMesh: w, wheelMeshes: b }) => {
        w && (this.chassisMesh = w, this.chassisMesh.position.x += 0.1, this.chassisMesh.position.y -= this.chassisVisualDrop, this.group.add(w)), Array.isArray(b) && b.forEach((m, _) => {
          const E = this.wheelRollPivots[_];
          !m || !E || E.add(m);
        });
      }).catch((w) => {
        console.error("Error loading car model:", w);
      }), this.keys = {}, this.rawEngineInput = 0, this.engineInput = 0, this.steerInput = 0, this.brakeInput = 0, this.controlProvider = null, this.enableKeyboard && (this.keyDownHandler = (w) => {
        this.keys[w.code] = true, w.code === "F3" && (this.debugPanel.visible = !this.debugPanel.visible);
      }, this.keyUpHandler = (w) => {
        this.keys[w.code] = false;
      }, window.addEventListener("keydown", this.keyDownHandler), window.addEventListener("keyup", this.keyUpHandler));
    }
    setControlProvider(t) {
      this.controlProvider = t;
    }
    getControlInputs(t) {
      return this.controlProvider ? typeof this.controlProvider == "function" ? this.controlProvider(t) || null : this.controlProvider : null;
    }
    getDirectionofMotion() {
      const t = this.getCarMph();
      if (this.chassisBody === null || t < 5) return this.getCarOrientation();
      const e = this.chassisBody.linvel();
      return Math.atan2(e.x, e.z);
    }
    getCarOrientation() {
      const t = this.group.quaternion;
      return new Pn().setFromQuaternion(t, "YXZ").y;
    }
    getPosition() {
      const t = this.chassisBody.translation();
      return new L(t.x, t.y, t.z);
    }
    getCarMph() {
      const t = this.chassisBody.linvel();
      return Math.sqrt(t.x * t.x + t.y * t.y + t.z * t.z) * 2.23694;
    }
    handleInput() {
      const t = this.keys;
      let e = 0, n = 0, i = 0;
      t.KeyW && (e += 1), t.KeyS && (e -= 1), t.KeyA && (n += 1), t.KeyD && (n -= 1), t.Space && (i = 1), this.rawEngineInput = e, this.steerInput = n, this.brakeInput = i;
    }
    getRPM() {
      return this.rpm;
    }
    getGear() {
      return this.currentGear;
    }
    update(t) {
      const e = this.getControlInputs(t);
      let n = 0;
      if (e) {
        const { engine: J = 0, steer: $ = 0, brake: ut = 0 } = e;
        n = we.clamp(J, -1, 1), this.steerInput = we.clamp($, -1, 1), this.brakeInput = we.clamp(ut, 0, 1);
      } else this.enableKeyboard ? (this.handleInput(), n = this.rawEngineInput) : (n = 0, this.steerInput = 0, this.brakeInput = 0);
      this.rawEngineInput = n;
      const i = this.throttleResponseTime > 0 && t > 0 ? Math.min(1, t / this.throttleResponseTime) : 1;
      this.engineInput = we.lerp(this.engineInput, this.rawEngineInput, i);
      const s = performance.now() / 1e3, a = this.getCarMph(), o = a * 0.44704, c = this.rawEngineInput;
      c < 0 && a < 3 && this.currentGear > 0 ? this.currentGear = -1 : c > 0 && this.currentGear <= 0 && (this.currentGear = 1), this.currentGear > 0 && s - this.lastShiftTime > 0.5 && (this.rpm > this.shiftUpRpm && this.currentGear < 6 ? (this.currentGear++, this.lastShiftTime = s) : this.rpm < this.shiftDownRpm && this.currentGear > 1 && (this.currentGear--, this.lastShiftTime = s));
      const l = s - this.lastShiftTime < this.shiftDuration, h = o < this.sleepSpeedThreshold && Math.abs(this.engineInput) < this.sleepInputThreshold && Math.abs(this.steerInput) < this.sleepInputThreshold && Math.abs(this.brakeInput) < this.sleepInputThreshold;
      h || this.chassisBody.wakeUp();
      const u = o / this.wheelRadius * 9.5493, p = this.gearRatios[String(this.currentGear)] || 0;
      let w = Math.abs(u * p * this.finalDrive);
      w < this.idleRpm && (w = this.idleRpm, Math.abs(a) < 1.5 && this.engineInput !== 0 && (w += Math.abs(this.engineInput) * 4e3)), this.rpm = we.lerp(this.rpm, w, 0.15), this.rpm > this.maxRpm && (this.rpm = this.maxRpm);
      let m = 1 - 0.4 * ((this.rpm - this.idleRpm) / (this.maxRpm - this.idleRpm));
      m < 0.1 && (m = 0.1);
      let _ = 0;
      this.currentGear !== 0 && !l && (_ = we.clamp(o / this.launchFullSpeedMs, this.minLaunchScale, 1) * this.engineInput * this.engineBaseForce * m * Math.abs(p) * this.finalDrive);
      const E = this.brakeInput ? this.maxBrakeForce : 0, v = this.maxSteer * this.steerInput, T = this.vehicle.numWheels();
      for (let J = 0; J < T; J++) J >= 2 ? this.vehicle.setWheelEngineForce(J, _) : this.vehicle.setWheelEngineForce(J, 0), J < 2 ? this.vehicle.setWheelSteering(J, v) : this.vehicle.setWheelSteering(J, 0), this.vehicle.setWheelBrake(J, E);
      if (this.vehicle.updateVehicle(t), h) {
        const J = new gn(0, 0, 0);
        this.chassisBody.setLinvel(J, true), this.chassisBody.setAngvel(J, true), this.chassisBody.sleep();
      }
      const O = this.chassisBody.translation(), R = this.chassisBody.rotation();
      this.group.position.set(O.x, O.y, O.z), this.group.quaternion.set(R.x, R.y, R.z, R.w);
      const P = new L(O.x, O.y, O.z), A = new Ve(R.x, R.y, R.z, R.w).clone().invert(), S = this.chassisBody.linvel(), W = new L(S.x, S.y, S.z).clone().applyQuaternion(A), V = W.z, Z = W.x, tt = [], Y = [
        "FL",
        "FR",
        "RL",
        "RR"
      ];
      for (let J = 0; J < T; J++) {
        const $ = this.vehicle.wheelHardPoint(J), ut = this.vehicle.wheelSuspensionLength(J), mt = Math.max(0, this.suspensionRestLength - Math.min(this.suspensionRestLength, ut)), gt = ut < this.suspensionRestLength - 2e-3;
        tt[J] = {
          label: Y[J] || `W${J}`,
          length: ut,
          compression: mt,
          inContact: gt
        };
        const qt = $.x, ee = $.y - ut, Q = $.z, _t = new L(qt, ee, Q).clone().sub(P).applyQuaternion(A), lt = this.wheelSlots[J], kt = this.wheelSteerPivots[J], Dt = this.wheelRollPivots[J];
        J < 2 && (_t.z += this.frontWheelForwardOffset), lt.position.copy(_t);
        const Kt = this.vehicle.wheelSteering(J), D = -this.vehicle.wheelRotation(J), Yt = new Ve().setFromAxisAngle(new L(0, 1, 0), Kt), jt = new Ve().setFromAxisAngle(new L(-1, 0, 0), D);
        kt.quaternion.copy(Yt), Dt.quaternion.copy(jt);
      }
      if (this.debugPanel) {
        const J = this.dragCoeff * o * o, $ = this.downforceCoeff * o * o;
        this.debugPanel.update({
          speedMph: a,
          forwardSpeed: V,
          lateralSpeed: Z,
          engineInput: this.engineInput,
          brakeInput: this.brakeInput,
          steerInput: this.steerInput,
          gear: this.currentGear,
          rpm: this.rpm,
          engineForce: _,
          downforce: $,
          drag: J,
          wheels: tt
        });
      }
    }
  }
  class eu {
    constructor({ kp: t = 0, ki: e = 0, kd: n = 0, integralClamp: i = 1 } = {}) {
      this.kp = t, this.ki = e, this.kd = n, this.integralClamp = Math.max(0, i), this.integral = 0, this.prevError = 0;
    }
    reset() {
      this.integral = 0, this.prevError = 0;
    }
    update(t, e) {
      const n = e > 0 ? e : 0.016666666666666666;
      this.integral += t * n, this.integral = we.clamp(this.integral, -this.integralClamp, this.integralClamp);
      const i = (t - this.prevError) / n;
      return this.prevError = t, this.kp * t + this.ki * this.integral + this.kd * i;
    }
  }
  const mc = new L(), xn = new L(), oa = new L(), _i = new L(), ca = new L(), nu = new L(), qn = new L(), la = new L();
  class pP {
    constructor({ waypoints: t = [], waypointAdvanceDistance: e = 10, targetSpeedMph: n = 40, lookAheadDistance: i = 20, steerPid: s = {
      kp: 1,
      ki: 0,
      kd: 0.4,
      integralClamp: 0.5
    }, speedPid: a = {
      kp: 0.6,
      ki: 0.05,
      kd: 0.05,
      integralClamp: 1
    }, playerCar: o = null, avoidanceDistance: c = 12, avoidanceStrength: l = 0.5, physicsWorld: h = null, wallDetectionDistance: d = 8 } = {}) {
      if (!Array.isArray(t) || t.length < 2) throw new Error("AIDriver requires at least two waypoints");
      this.waypoints = t.map((u) => u.clone()), this.advanceDistance = e, this.advanceDistanceSq = e ** 2, this.targetSpeedMph = n, this.lookAheadDistance = i, this.currentIndex = 0, this.steerController = new eu(s), this.speedController = new eu(a), this.playerCar = o, this.avoidanceDistance = c, this.avoidanceDistanceSq = c * c, this.avoidanceStrength = l, this.physicsWorld = h, this.wallDetectionDistance = d, this.lookAheadPoint = new L(), this.debugCurrentTarget = null, this.debugLookAhead = null;
    }
    setPlayerCar(t) {
      this.playerCar = t;
    }
    initializeWaypointIndex(t, e) {
      this.waypoints.length && (this.currentIndex = this.findForwardWaypointIndex(t, e));
    }
    findForwardWaypointIndex(t, e) {
      if (!this.waypoints.length) return 0;
      let n = this.currentIndex, i = -1 / 0;
      for (let s = 0; s < this.waypoints.length; s++) {
        const a = this.waypoints[s];
        qn.copy(a).sub(t);
        const o = qn.lengthSq();
        if (o < 0.25) continue;
        const c = Math.sqrt(o);
        qn.multiplyScalar(1 / c);
        const l = e.dot(qn);
        if (l < 0.1) continue;
        const h = l * (120 / c);
        h > i && (i = h, n = s);
      }
      return i > -1 / 0 ? n : this.currentIndex;
    }
    nextWaypoint(t, e = null) {
      if (!this.waypoints.length) return null;
      if (e) {
        let s = this.currentIndex, a = -1 / 0;
        for (let o = 0; o < this.waypoints.length; o++) {
          const c = (this.currentIndex + o) % this.waypoints.length, l = this.waypoints[c], h = new L().subVectors(l, t), d = h.lengthSq(), u = Math.sqrt(d);
          if (u < 0.1) continue;
          h.normalize();
          const p = e.dot(h);
          if (p < 0.2) continue;
          const w = p * (100 / u);
          if (w > a && (a = w, s = c), u > this.lookAheadDistance * 2) break;
        }
        a > 0 && (this.currentIndex = s);
      } else {
        let s = this.currentIndex, a = 1 / 0;
        for (let o = 0; o < this.waypoints.length; o++) {
          const c = t.distanceToSquared(this.waypoints[o]);
          c < a && (a = c, s = o);
        }
        this.currentIndex = s;
      }
      const n = this.waypoints[this.currentIndex];
      if (!n) return null;
      xn.copy(n).sub(t);
      const i = xn.lengthSq();
      if (e && i > this.advanceDistanceSq && i > 1e-4) {
        const s = qn.copy(xn).normalize();
        if (e.dot(s) < -0.2) return this.currentIndex = (this.currentIndex + 1) % this.waypoints.length, this.waypoints[this.currentIndex];
      }
      if (i <= this.advanceDistanceSq) {
        const s = (this.currentIndex + 1) % this.waypoints.length, a = this.waypoints[s];
        if (la.copy(a).sub(t), la.lengthSq() > 1e-4 && la.normalize(), !e || e.dot(la) > 0.1) return this.currentIndex = s, this.waypoints[this.currentIndex];
      }
      return n;
    }
    projectPointOnSegment(t, e, n, i) {
      ca.copy(n).sub(e);
      const s = ca.lengthSq();
      if (s === 0) return i.copy(e), 0;
      nu.copy(t).sub(e);
      const a = we.clamp(nu.dot(ca) / s, 0, 1);
      return i.copy(e).addScaledVector(ca, a), a;
    }
    findLookAheadPoint(t) {
      const e = this.waypoints.length;
      if (!e) return null;
      const n = this.lookAheadPoint, i = (this.currentIndex - 1 + e) % e, s = this.waypoints[i], a = this.waypoints[this.currentIndex];
      this.projectPointOnSegment(t, s, a, n);
      let o = this.lookAheadDistance;
      const c = a.distanceTo(n);
      if (c >= o && c > 1e-4) return qn.copy(a).sub(n).setLength(o), n.add(qn), n;
      o -= c;
      let l = this.currentIndex;
      for (let h = 0; h < e && o > 0; h++) {
        const d = (l + 1) % e, u = this.waypoints[l], p = this.waypoints[d], w = u.distanceTo(p);
        if (w < 1e-3) {
          l = d;
          continue;
        }
        if (o <= w) return qn.copy(p).sub(u).setLength(o), n.copy(u).add(qn), n;
        o -= w, l = d;
      }
      return n.copy(a), n;
    }
    calculateAvoidance(t, e) {
      if (!this.playerCar) return 0;
      const n = this.playerCar.group.position;
      _i.copy(n).sub(t);
      const i = _i.lengthSq();
      if (i > this.avoidanceDistanceSq || i < 1e-3) return 0;
      const s = Math.sqrt(i);
      _i.normalize();
      const a = e.dot(_i);
      if (a < 0) return 0;
      oa.copy(e).cross(_i);
      const o = Math.sign(oa.y), c = 1 - s / this.avoidanceDistance, l = Math.abs(a), h = o * c * l * this.avoidanceStrength;
      return we.clamp(h, -1, 1);
    }
    calculateWallAvoidance(t, e) {
      if (!this.physicsWorld) return 0;
      let n = 0;
      const i = this.wallDetectionDistance, s = [
        {
          angle: -0.4,
          weight: 1.5
        },
        {
          angle: 0,
          weight: 1
        },
        {
          angle: 0.4,
          weight: 1.5
        }
      ];
      for (const { angle: a, weight: o } of s) {
        const c = new L(e.x, 0, e.z), l = new L(-c.z, 0, c.x);
        c.addScaledVector(l, a).normalize();
        const h = new gn(t.x, t.y + 0.5, t.z), d = new gn(c.x, 0, c.z), u = new pl(h, d), p = this.physicsWorld.castRay(u, i, true);
        if (p) {
          const b = 1 - p.toi / i, m = -Math.sign(a) * b * o * 0.7;
          n += m;
        }
      }
      return we.clamp(n, -1, 1);
    }
    update(t, e) {
      if (!t) return {
        engine: 0,
        steer: 0,
        brake: 1
      };
      const n = t.group.position;
      mc.set(0, 0, 1).applyQuaternion(t.group.quaternion);
      const i = new L(mc.x, 0, mc.z).normalize();
      this.currentIndex === 0 && this.waypoints.length > 0 && this.initializeWaypointIndex(n, i);
      const s = this.waypoints[this.currentIndex];
      if (s) {
        xn.copy(s).sub(n);
        const v = xn.lengthSq();
        if (v > 0.25) {
          const T = 1 / Math.sqrt(v);
          xn.multiplyScalar(T), i.dot(xn) < 0.05 && (this.currentIndex = this.findForwardWaypointIndex(n, i));
        }
      }
      this.nextWaypoint(n, i);
      const a = this.findLookAheadPoint(n);
      if (!a) return {
        engine: 0,
        steer: 0,
        brake: 1
      };
      this.debugCurrentTarget = this.waypoints[this.currentIndex], this.debugLookAhead = a, xn.copy(a).sub(n);
      const o = xn.length();
      if (o === 0) return {
        engine: 0,
        steer: 0,
        brake: 1
      };
      const c = new L(xn.x, 0, xn.z).normalize();
      oa.copy(i).cross(c), we.clamp(i.dot(c), -1, 1);
      const l = Math.asin(we.clamp(oa.y, -1, 1));
      let h = this.steerController.update(l, e);
      const d = this.calculateWallAvoidance(n, i);
      h += d * 0.6, h += this.calculateAvoidance(n, i) * 0.4;
      let u = this.targetSpeedMph;
      const p = Math.abs(l);
      if (p < 0.12) {
        const v = we.lerp(1, 1.3, 1 - p / 0.12);
        u *= v;
      }
      if (p > 0.25) {
        const v = Math.max(0.4, 1 - p / Math.PI * 0.9);
        u *= v;
      }
      if (o < 12) {
        const v = we.clamp(o / 12, 0.35, 1);
        u = Math.min(u, this.targetSpeedMph * v);
      }
      if (this.playerCar) {
        const v = this.playerCar.group.position;
        _i.copy(v).sub(n);
        const T = _i.lengthSq();
        if (i.dot(_i.normalize()) > 0.5 && T < this.avoidanceDistanceSq) {
          const R = 1 - Math.sqrt(T) / this.avoidanceDistance;
          u *= Math.max(0.2, 1 - R * 0.7);
        }
      }
      const w = u - t.getCarMph();
      let b = this.speedController.update(w, e);
      const m = we.clamp(Math.max(0, b), 0, 1), _ = we.clamp(Math.max(0, -b), 0, 1), E = we.clamp(h, -1, 1);
      return {
        engine: m,
        steer: E,
        brake: _
      };
    }
  }
  class mo extends fe {
    constructor() {
      const t = mo.SkyShader, e = new Qn({
        name: t.name,
        uniforms: Iu.clone(t.uniforms),
        vertexShader: t.vertexShader,
        fragmentShader: t.fragmentShader,
        side: nn,
        depthWrite: false
      });
      super(new Cn(1, 1, 1), e), this.isSky = true;
    }
  }
  mo.SkyShader = {
    name: "SkyShader",
    uniforms: {
      turbidity: {
        value: 2
      },
      rayleigh: {
        value: 1
      },
      mieCoefficient: {
        value: 5e-3
      },
      mieDirectionalG: {
        value: 0.8
      },
      sunPosition: {
        value: new L()
      },
      up: {
        value: new L(0, 1, 0)
      }
    },
    vertexShader: `
		uniform vec3 sunPosition;
		uniform float rayleigh;
		uniform float turbidity;
		uniform float mieCoefficient;
		uniform vec3 up;

		varying vec3 vWorldPosition;
		varying vec3 vSunDirection;
		varying float vSunfade;
		varying vec3 vBetaR;
		varying vec3 vBetaM;
		varying float vSunE;

		// constants for atmospheric scattering
		const float e = 2.71828182845904523536028747135266249775724709369995957;
		const float pi = 3.141592653589793238462643383279502884197169;

		// wavelength of used primaries, according to preetham
		const vec3 lambda = vec3( 680E-9, 550E-9, 450E-9 );
		// this pre-calcuation replaces older TotalRayleigh(vec3 lambda) function:
		// (8.0 * pow(pi, 3.0) * pow(pow(n, 2.0) - 1.0, 2.0) * (6.0 + 3.0 * pn)) / (3.0 * N * pow(lambda, vec3(4.0)) * (6.0 - 7.0 * pn))
		const vec3 totalRayleigh = vec3( 5.804542996261093E-6, 1.3562911419845635E-5, 3.0265902468824876E-5 );

		// mie stuff
		// K coefficient for the primaries
		const float v = 4.0;
		const vec3 K = vec3( 0.686, 0.678, 0.666 );
		// MieConst = pi * pow( ( 2.0 * pi ) / lambda, vec3( v - 2.0 ) ) * K
		const vec3 MieConst = vec3( 1.8399918514433978E14, 2.7798023919660528E14, 4.0790479543861094E14 );

		// earth shadow hack
		// cutoffAngle = pi / 1.95;
		const float cutoffAngle = 1.6110731556870734;
		const float steepness = 1.5;
		const float EE = 1000.0;

		float sunIntensity( float zenithAngleCos ) {
			zenithAngleCos = clamp( zenithAngleCos, -1.0, 1.0 );
			return EE * max( 0.0, 1.0 - pow( e, -( ( cutoffAngle - acos( zenithAngleCos ) ) / steepness ) ) );
		}

		vec3 totalMie( float T ) {
			float c = ( 0.2 * T ) * 10E-18;
			return 0.434 * c * MieConst;
		}

		void main() {

			vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
			vWorldPosition = worldPosition.xyz;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
			gl_Position.z = gl_Position.w; // set z to camera.far

			vSunDirection = normalize( sunPosition );

			vSunE = sunIntensity( dot( vSunDirection, up ) );

			vSunfade = 1.0 - clamp( 1.0 - exp( ( sunPosition.y / 450000.0 ) ), 0.0, 1.0 );

			float rayleighCoefficient = rayleigh - ( 1.0 * ( 1.0 - vSunfade ) );

			// extinction (absorbtion + out scattering)
			// rayleigh coefficients
			vBetaR = totalRayleigh * rayleighCoefficient;

			// mie coefficients
			vBetaM = totalMie( turbidity ) * mieCoefficient;

		}`,
    fragmentShader: `
		varying vec3 vWorldPosition;
		varying vec3 vSunDirection;
		varying float vSunfade;
		varying vec3 vBetaR;
		varying vec3 vBetaM;
		varying float vSunE;

		uniform float mieDirectionalG;
		uniform vec3 up;

		// constants for atmospheric scattering
		const float pi = 3.141592653589793238462643383279502884197169;

		const float n = 1.0003; // refractive index of air
		const float N = 2.545E25; // number of molecules per unit volume for air at 288.15K and 1013mb (sea level -45 celsius)

		// optical length at zenith for molecules
		const float rayleighZenithLength = 8.4E3;
		const float mieZenithLength = 1.25E3;
		// 66 arc seconds -> degrees, and the cosine of that
		const float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;

		// 3.0 / ( 16.0 * pi )
		const float THREE_OVER_SIXTEENPI = 0.05968310365946075;
		// 1.0 / ( 4.0 * pi )
		const float ONE_OVER_FOURPI = 0.07957747154594767;

		float rayleighPhase( float cosTheta ) {
			return THREE_OVER_SIXTEENPI * ( 1.0 + pow( cosTheta, 2.0 ) );
		}

		float hgPhase( float cosTheta, float g ) {
			float g2 = pow( g, 2.0 );
			float inverse = 1.0 / pow( 1.0 - 2.0 * g * cosTheta + g2, 1.5 );
			return ONE_OVER_FOURPI * ( ( 1.0 - g2 ) * inverse );
		}

		void main() {

			vec3 direction = normalize( vWorldPosition - cameraPosition );

			// optical length
			// cutoff angle at 90 to avoid singularity in next formula.
			float zenithAngle = acos( max( 0.0, dot( up, direction ) ) );
			float inverse = 1.0 / ( cos( zenithAngle ) + 0.15 * pow( 93.885 - ( ( zenithAngle * 180.0 ) / pi ), -1.253 ) );
			float sR = rayleighZenithLength * inverse;
			float sM = mieZenithLength * inverse;

			// combined extinction factor
			vec3 Fex = exp( -( vBetaR * sR + vBetaM * sM ) );

			// in scattering
			float cosTheta = dot( direction, vSunDirection );

			float rPhase = rayleighPhase( cosTheta * 0.5 + 0.5 );
			vec3 betaRTheta = vBetaR * rPhase;

			float mPhase = hgPhase( cosTheta, mieDirectionalG );
			vec3 betaMTheta = vBetaM * mPhase;

			vec3 Lin = pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * ( 1.0 - Fex ), vec3( 1.5 ) );
			Lin *= mix( vec3( 1.0 ), pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * Fex, vec3( 1.0 / 2.0 ) ), clamp( pow( 1.0 - dot( up, vSunDirection ), 5.0 ), 0.0, 1.0 ) );

			// nightsky
			float theta = acos( direction.y ); // elevation --> y-axis, [-pi/2, pi/2]
			float phi = atan( direction.z, direction.x ); // azimuth --> x-axis [-pi/2, pi/2]
			vec2 uv = vec2( phi, theta ) / vec2( 2.0 * pi, pi ) + vec2( 0.5, 0.0 );
			vec3 L0 = vec3( 0.1 ) * Fex;

			// composition + solar disc
			float sundisk = smoothstep( sunAngularDiameterCos, sunAngularDiameterCos + 0.00002, cosTheta );
			L0 += ( vSunE * 19000.0 * Fex ) * sundisk;

			vec3 texColor = ( Lin + L0 ) * 0.04 + vec3( 0.0, 0.0003, 0.00075 );

			vec3 retColor = pow( texColor, vec3( 1.0 / ( 1.2 + ( 1.2 * vSunfade ) ) ) );

			gl_FragColor = vec4( retColor, 1.0 );

			#include <tonemapping_fragment>
			#include <colorspace_fragment>

		}`
  };
  class fP {
    constructor(t, e, n, i = {}) {
      this.scene = t, this.renderer = e, this.sunLight = n, this.sky = new mo(), this.sky.scale.setScalar(45e4), this.scene.add(this.sky), this.sun = new L();
      const s = {
        turbidity: 8.4,
        rayleigh: 3.066,
        mieCoefficient: 4e-3,
        mieDirectionalG: 0.963,
        elevation: 64.6,
        azimuth: 36.8,
        exposure: 0.3
      };
      this.settings = {
        ...s,
        ...i
      }, this._applySettings();
    }
    _applySettings() {
      const { turbidity: t, rayleigh: e, mieCoefficient: n, mieDirectionalG: i, elevation: s, azimuth: a, exposure: o } = this.settings, c = this.sky.material.uniforms;
      c.turbidity.value = t, c.rayleigh.value = e, c.mieCoefficient.value = n, c.mieDirectionalG.value = i;
      const l = we.degToRad(90 - s), h = we.degToRad(a);
      if (this.sun.setFromSphericalCoords(1, l, h), c.sunPosition.value.copy(this.sun), this.renderer.toneMapping = lu, this.renderer.toneMappingExposure = o, this.sunLight) {
        const d = this.sun.clone().normalize();
        this.sunLight.position.copy(d).multiplyScalar(50), this.sunLight.target.position.set(0, 0, 0), this.sunLight.target.updateMatrixWorld();
      }
    }
  }
  class _P {
    constructor(t, e) {
      this.scene = t, this.width = e.width || 20, this.rows = e.rows || 5, this.hasRoof = e.hasRoof || false, this.crowdDensity = e.crowdDensity || 0.6, this.stepHeight = 0.6, this.stepDepth = 1.2, this.wrapper = new Ye(), e.position && this.wrapper.position.copy(e.position);
      const n = e.scale || 2.5;
      this.wrapper.scale.set(n, n, n), e.quaternion ? this.wrapper.quaternion.copy(e.quaternion) : e.rotationY && (this.wrapper.rotation.y = e.rotationY), this.meshGroup = new Ye(), this.wrapper.add(this.meshGroup), this.materials = {
        concrete: new Un({
          color: 7829367,
          roughness: 0.9
        }),
        roof: new Un({
          color: 14540253,
          side: Mn
        }),
        pillar: new Un({
          color: 4473924,
          metalness: 0.6
        })
      }, this.crowdTexture = this._generateCrowdTexture(), this._buildStructure(), this.hasRoof && this._buildRoof(), this._populateCrowd(), this.scene.add(this.wrapper);
    }
    _generateCrowdTexture() {
      const t = document.createElement("canvas");
      t.width = 64, t.height = 128;
      const e = t.getContext("2d");
      e.fillStyle = "#ffffff", e.beginPath(), e.arc(32, 20, 18, 0, Math.PI * 2), e.fill(), e.fillStyle = "#ffffff", e.fillRect(4, 40, 56, 88);
      const n = new Q0(t);
      return n.colorSpace = Ke, n;
    }
    _buildStructure() {
      for (let i = 0; i < this.rows; i++) {
        const s = new Cn(this.width, this.stepHeight, this.stepDepth), a = new fe(s, this.materials.concrete);
        a.position.y = i * this.stepHeight + this.stepHeight / 2, a.position.z = -i * this.stepDepth, a.receiveShadow = true, a.castShadow = true, this.meshGroup.add(a);
      }
      const t = this.rows * this.stepHeight, e = new Cn(this.width, t, 0.5), n = new fe(e, this.materials.concrete);
      n.position.z = -(this.rows * this.stepDepth) + this.stepDepth / 2, n.position.y = t / 2, this.meshGroup.add(n);
    }
    _buildRoof() {
      const t = this.rows * this.stepDepth, e = this.rows * this.stepHeight, n = new Cn(this.width, 0.2, t + 2), i = new fe(n, this.materials.roof);
      i.position.y = e + 3.5, i.position.z = -(t / 2 - 1), i.rotation.x = 0.1, i.castShadow = true, this.meshGroup.add(i);
      const s = new Ga(0.3, 0.3, e + 4), a = new fe(s, this.materials.pillar), o = new fe(s, this.materials.pillar), c = -t + 1, l = (e + 4) / 2;
      a.position.set(-this.width / 2 + 1, l, c), o.position.set(this.width / 2 - 1, l, c), this.meshGroup.add(a), this.meshGroup.add(o);
    }
    _populateCrowd() {
      const t = Math.floor(this.width / 1);
      for (let e = 0; e < this.rows; e++) for (let n = 0; n < t; n++) {
        if (Math.random() > this.crowdDensity) continue;
        const i = new Ct().setHSL(Math.random(), 0.3, 0.2), s = new Gu({
          map: this.crowdTexture,
          color: i
        }), a = new X0(s), o = n * 1 - this.width / 2 + 0.5, c = e * this.stepHeight + this.stepHeight + 0.5, l = -e * this.stepDepth;
        a.position.set(o + Math.random() * 0.2, c, l + Math.random() * 0.2), a.scale.set(0.8, 1.6, 1), this.meshGroup.add(a);
      }
    }
  }
  const up = "/src/assets/models/racetrack/", mP = (r, t = up) => `${t.endsWith("/") ? t : `${t}/`}${r}`;
  function gP(r = {}) {
    const { assetBaseUrl: t = up, loadingManager: e, extraObjects: n = [], world: i = null, onObjectLoaded: s } = r, a = new Ye();
    a.name = "RaceTrack";
    const o = new Al(e), l = [
      ...[
        {
          name: "race_track",
          file: "demo_track/demo-racetrack.glb"
        },
        {
          name: "grandstand_spawns",
          file: "demo_track/grandstand-spawns.glb"
        },
        {
          name: "barriers",
          file: "demo_track/barrier.glb"
        },
        {
          name: "waypoints",
          file: "demo_track/waypoints.glb"
        }
      ],
      ...n
    ];
    a.userData.colliders = [], a.userData.objectsByName = {};
    const h = l.map((d) => {
      const u = mP(d.file, t);
      return new Promise((p, w) => {
        o.load(u, (b) => {
          var _a2;
          const m = b.scene || ((_a2 = b.scenes) == null ? void 0 : _a2[0]);
          if (!m) {
            w(new Error(`No scene in GLB: ${u}`));
            return;
          }
          m.name = d.name, a.add(m), d.name === "grandstand_spawns" && wP(m, a), i && (console.log("Adding static mesh colliders for", d.name), bP(m, i, a)), s && s({
            def: d,
            gltf: b,
            object: m,
            trackGroup: a,
            world: i,
            RAPIER: M1
          }), a.userData.objectsByName[d.name] = m, p(m);
        }, void 0, (b) => w(b));
      });
    });
    return a.userData.loadPromise = Promise.all(h).catch((d) => {
      console.error("Error loading race track objects:", d);
    }), a;
  }
  function wP(r, t) {
    if (!r) return;
    console.log("--- Processing Grandstand Spawns ---");
    const e = new Ve();
    r.updateWorldMatrix(true, true), r.traverse((n) => {
      var _a2;
      if (n.name.includes("Spawn")) {
        const i = n.getWorldPosition(new L()), s = n.getWorldQuaternion(e), a = ((_a2 = n.userData) == null ? void 0 : _a2.grandstand) ?? {};
        let o = 1, c = -1;
        const l = n.name.match(/Spawn(\d+)/);
        l ? c = parseInt(l[1], 10) : n.name === "Spawn" && (c = 0), c === 0 ? o = 7 : [
          2,
          3,
          5,
          6,
          7
        ].includes(c) ? o = 2 : c === 4 && (o = 3);
        const h = new Ve().setFromAxisAngle(new L(0, 1, 0), Math.PI / 2);
        s.multiply(h), new _P(t, {
          width: (a.width ?? 25) * o,
          rows: a.rows ?? 10,
          hasRoof: typeof a.hasRoof == "boolean" ? a.hasRoof : true,
          crowdDensity: a.crowdDensity ?? 0.5,
          position: i,
          quaternion: s
        });
      }
    }), r.visible = false;
  }
  function bP(r, t, e) {
    r.updateWorldMatrix(true, true), r.traverse((n) => {
      if (!n.isMesh || !n.geometry) return;
      const i = n.geometry, s = i.attributes.position;
      if (!s) return;
      const a = new L(), o = new Ve(), c = new L();
      n.matrixWorld.decompose(a, o, c);
      const l = new Float32Array(s.count * 3);
      for (let p = 0; p < s.count; p++) l[p * 3 + 0] = s.getX(p) * c.x, l[p * 3 + 1] = s.getY(p) * c.y, l[p * 3 + 2] = s.getZ(p) * c.z;
      let h;
      if (i.index) {
        const p = i.index;
        h = new Uint32Array(p.count);
        for (let w = 0; w < p.count; w++) h[w] = p.getX(w);
      } else {
        h = new Uint32Array(s.count);
        for (let p = 0; p < s.count; p++) h[p] = p;
      }
      const d = be.trimesh(l, h);
      d.setTranslation(a.x, a.y, a.z), d.setRotation({
        x: o.x,
        y: o.y,
        z: o.z,
        w: o.w
      });
      const u = t.createCollider(d);
      e.userData.colliders.push(u);
    });
  }
  class yP {
    constructor() {
      this.container = document.createElement("div"), this.container.style.position = "absolute", this.container.style.bottom = "30px", this.container.style.right = "30px", this.container.style.width = "500px", this.container.style.height = "280px", this.container.style.userSelect = "none", this.container.style.pointerEvents = "none", this.canvas = document.createElement("canvas"), this.canvas.width = 500, this.canvas.height = 280, this.container.appendChild(this.canvas), this.ctx = this.canvas.getContext("2d"), document.body.appendChild(this.container), this.currentSpeed = 0, this.targetSpeed = 0, this.rpm = 0, this.currentGear = 1;
    }
    set visible(t) {
      this.container.style.display = t ? "block" : "none";
    }
    updateSpeed(t) {
      this.targetSpeed = Math.abs(t), this.currentSpeed += (this.targetSpeed - this.currentSpeed) * 0.15;
    }
    updateRPM(t) {
      this.rpm = t;
    }
    draw() {
      const t = this.ctx;
      t.clearRect(0, 0, 500, 280), this.drawRPMGauge(t, 120, 140, 110), this.drawSpeedometer(t, 370, 140, 125), this.drawGear(t, 250, 200);
    }
    drawRPMGauge(t, e, n, i) {
      const s = t.createRadialGradient(e, n, i - 20, e, n, i + 10);
      s.addColorStop(0, "#2a2a2a"), s.addColorStop(0.8, "#1a1a1a"), s.addColorStop(1, "#0a0a0a"), t.fillStyle = s, t.beginPath(), t.arc(e, n, i + 10, 0, Math.PI * 2), t.fill();
      const a = t.createRadialGradient(e, n, 0, e, n, i);
      a.addColorStop(0, "#1a1a1a"), a.addColorStop(1, "#000000"), t.fillStyle = a, t.beginPath(), t.arc(e, n, i, 0, Math.PI * 2), t.fill();
      const o = 8, c = Math.PI * 0.75, h = Math.PI * 2.25 - c;
      for (let p = 0; p <= o; p++) {
        const w = c + p / o * h, b = 15, m = e + Math.cos(w) * (i - 8), _ = n + Math.sin(w) * (i - 8), E = e + Math.cos(w) * (i - 8 - b), v = n + Math.sin(w) * (i - 8 - b);
        t.strokeStyle = p >= 7 ? "#ff0000" : "#ffffff", t.lineWidth = 3, t.beginPath(), t.moveTo(m, _), t.lineTo(E, v), t.stroke(), t.fillStyle = p >= 7 ? "#ff0000" : "#ffffff", t.font = "italic bold 18px Arial", t.textAlign = "center", t.textBaseline = "middle";
        const T = i - 35, O = e + Math.cos(w) * T, R = n + Math.sin(w) * T;
        t.fillText(p.toString(), O, R);
      }
      const d = c + Math.min(this.rpm / 1e3, o) / o * h;
      t.strokeStyle = "rgba(0, 0, 0, 0.5)", t.lineWidth = 4, t.lineCap = "round", t.beginPath(), t.moveTo(e + 2, n + 2), t.lineTo(e + Math.cos(d) * (i - 25) + 2, n + Math.sin(d) * (i - 25) + 2), t.stroke(), t.strokeStyle = "#ff0000", t.lineWidth = 3, t.shadowColor = "#ff0000", t.shadowBlur = 15, t.lineCap = "round", t.beginPath(), t.moveTo(e, n), t.lineTo(e + Math.cos(d) * (i - 25), n + Math.sin(d) * (i - 25)), t.stroke(), t.shadowBlur = 0;
      const u = t.createRadialGradient(e, n, 0, e, n, 12);
      u.addColorStop(0, "#444444"), u.addColorStop(1, "#1a1a1a"), t.fillStyle = u, t.beginPath(), t.arc(e, n, 12, 0, Math.PI * 2), t.fill(), t.fillStyle = "#ff0000", t.beginPath(), t.arc(e, n, 4, 0, Math.PI * 2), t.fill(), t.fillStyle = "#999999", t.font = "italic bold 11px Arial", t.textAlign = "center", t.fillText("RPM x1000", e, n + 55);
    }
    drawGear(t, e, n) {
      const i = this.currentGear;
      t.fillStyle = "#ffffff", t.font = "bold 48px Arial", t.textAlign = "center", t.textBaseline = "middle", t.fillText(i.toString(), e, n);
    }
    drawSpeedometer(t, e, n, i) {
      const s = t.createRadialGradient(e, n, i - 20, e, n, i + 10);
      s.addColorStop(0, "#2a2a2a"), s.addColorStop(0.8, "#1a1a1a"), s.addColorStop(1, "#0a0a0a"), t.fillStyle = s, t.beginPath(), t.arc(e, n, i + 10, 0, Math.PI * 2), t.fill();
      const a = t.createRadialGradient(e, n, 0, e, n, i);
      a.addColorStop(0, "#1a1a1a"), a.addColorStop(1, "#000000"), t.fillStyle = a, t.beginPath(), t.arc(e, n, i, 0, Math.PI * 2), t.fill();
      const o = 180, c = Math.PI * 0.75, h = Math.PI * 2.25 - c;
      t.save();
      for (let p = 0; p <= o; p += 10) {
        const w = c + p / o * h, b = p % 20 === 0, m = b ? 20 : 12, _ = e + Math.cos(w) * (i - 8), E = n + Math.sin(w) * (i - 8), v = e + Math.cos(w) * (i - 8 - m), T = n + Math.sin(w) * (i - 8 - m);
        if (p > 140 ? t.strokeStyle = "#ff0000" : t.strokeStyle = "#ffffff", t.lineWidth = b ? 3 : 2, t.beginPath(), t.moveTo(_, E), t.lineTo(v, T), t.stroke(), b && p % 20 === 0) {
          t.fillStyle = "#ffffff", t.font = "italic bold 18px Arial", t.textAlign = "center", t.textBaseline = "middle";
          const O = i - 45, R = e + Math.cos(w) * O, P = n + Math.sin(w) * O;
          t.fillText(p.toString(), R, P);
        }
      }
      t.restore();
      const d = c + Math.min(this.currentSpeed, o) / o * h;
      t.strokeStyle = "rgba(0, 0, 0, 0.5)", t.lineWidth = 5, t.lineCap = "round", t.beginPath(), t.moveTo(e + 2, n + 2), t.lineTo(e + Math.cos(d) * (i - 25) + 2, n + Math.sin(d) * (i - 25) + 2), t.stroke(), t.strokeStyle = "#ff0000", t.lineWidth = 4, t.shadowColor = "#ff0000", t.shadowBlur = 15, t.lineCap = "round", t.beginPath(), t.moveTo(e, n), t.lineTo(e + Math.cos(d) * (i - 25), n + Math.sin(d) * (i - 25)), t.stroke(), t.shadowBlur = 0;
      const u = t.createRadialGradient(e, n, 0, e, n, 15);
      u.addColorStop(0, "#444444"), u.addColorStop(1, "#1a1a1a"), t.fillStyle = u, t.beginPath(), t.arc(e, n, 15, 0, Math.PI * 2), t.fill(), t.fillStyle = "#ff0000", t.beginPath(), t.arc(e, n, 5, 0, Math.PI * 2), t.fill(), t.fillStyle = "rgba(0, 0, 0, 0.9)", t.fillRect(e - 45, n + 80, 90, 32), t.fillStyle = "#00ff00", t.shadowColor = "#00ff00", t.shadowBlur = 8, t.font = "bold 28px 'Courier New', monospace", t.textAlign = "center", t.textBaseline = "middle", t.fillText(Math.round(this.currentSpeed).toString(), e, n + 96), t.shadowBlur = 0, t.fillStyle = "#999999", t.font = "italic bold 11px Arial", t.fillText("MPH", e, n + 70);
    }
  }
  class vP {
    constructor() {
      this.container = document.createElement("div"), this.container.id = "racing-hud", this.currentLap = 1, this.totalLaps = 3, this.position = 1, this.totalCars = 2, this.currentLapTime = 0, this.bestLapTime = null, this.lastLapTime = null, this.raceTime = 0, this.setupStyles(), this.setupContent(), document.body.appendChild(this.container);
    }
    setupStyles() {
      const t = document.createElement("style");
      t.textContent = `
            #racing-hud {
                position: fixed;
                top: 20px;
                left: 20px;
                color: white;
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                user-select: none;
                pointer-events: none;
                z-index: 100;
            }

            .hud-panel {
                background: rgba(0, 0, 0, 0.6);
                backdrop-filter: blur(10px);
                border: 2px solid rgba(255, 255, 255, 0.2);
                border-radius: 8px;
                padding: 1rem;
                margin-bottom: 1rem;
                min-width: 250px;
            }

            .hud-title {
                font-size: 0.8rem;
                text-transform: uppercase;
                letter-spacing: 0.1em;
                opacity: 0.7;
                margin-bottom: 0.5rem;
            }

            .hud-value {
                font-size: 1.8rem;
                font-weight: bold;
                line-height: 1;
            }

            .lap-info {
                display: flex;
                align-items: baseline;
                gap: 0.5rem;
            }

            .lap-current {
                font-size: 3rem;
                font-weight: bold;
                color: #4a90e2;
            }

            .lap-total {
                font-size: 1.2rem;
                opacity: 0.6;
            }

            .position-display {
                font-size: 3rem;
                font-weight: bold;
                color: #f39c12;
            }

            .position-suffix {
                font-size: 1.5rem;
                margin-left: 0.2rem;
            }

            .time-value {
                font-family: 'Courier New', monospace;
                font-size: 1.5rem;
                color: #2ecc71;
            }

            .time-label {
                font-size: 0.7rem;
                opacity: 0.6;
                margin-right: 0.5rem;
            }

            .best-lap {
                color: #e74c3c;
            }

            .last-lap {
                color: #9b59b6;
            }

            .hud-row {
                display: flex;
                align-items: baseline;
                margin-top: 0.5rem;
            }

            #hud-countdown {
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                font-size: 6rem;
                font-weight: bold;
                color: #ffffff;
                text-shadow: 0 0 10px rgba(0, 0, 0, 0.8),
                             0 0 20px rgba(0, 0, 0, 0.6);
                letter-spacing: 0.1em;
                pointer-events: none;
                z-index: 200;
                opacity: 0;
                transition: opacity 0.2s ease-out, transform 0.2s ease-out;
            }

            #hud-countdown.visible {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
        `, document.head.appendChild(t);
    }
    setupContent() {
      this.container.innerHTML = `
            <div class="hud-panel">
                <div class="hud-title">Lap</div>
                <div class="lap-info">
                    <span class="lap-current" id="hud-current-lap">1</span>
                    <span class="lap-total" id="hud-total-laps">/ 3</span>
                </div>
            </div>

            <div class="hud-panel">
                <div class="hud-title">Position</div>
                <div class="position-display">
                    <span id="hud-position">1</span><span class="position-suffix" id="hud-position-suffix">st</span>
                    <span style="font-size: 1.2rem; opacity: 0.6; margin-left: 0.3rem;" id="hud-total-cars">/ 2</span>
                </div>
            </div>

            <div class="hud-panel">
                <div class="hud-title">Current Lap</div>
                <div class="time-value" id="hud-current-time">0:00.000</div>
                
                <div class="hud-row">
                    <span class="time-label">Last:</span>
                    <span class="time-value last-lap" id="hud-last-lap">--:--.---</span>
                </div>
                
                <div class="hud-row">
                    <span class="time-label">Best:</span>
                    <span class="time-value best-lap" id="hud-best-lap">--:--.---</span>
                </div>
            </div>

            <div class="hud-panel">
                <div class="hud-title">Race Time</div>
                <div class="time-value" id="hud-race-time">0:00.000</div>
            </div>

            <div id="hud-countdown"></div>
        `, this.elements = {
        currentLap: this.container.querySelector("#hud-current-lap"),
        totalLaps: this.container.querySelector("#hud-total-laps"),
        position: this.container.querySelector("#hud-position"),
        positionSuffix: this.container.querySelector("#hud-position-suffix"),
        totalCars: this.container.querySelector("#hud-total-cars"),
        currentTime: this.container.querySelector("#hud-current-time"),
        lastLap: this.container.querySelector("#hud-last-lap"),
        bestLap: this.container.querySelector("#hud-best-lap"),
        raceTime: this.container.querySelector("#hud-race-time"),
        countdown: this.container.querySelector("#hud-countdown")
      };
    }
    formatTime(t) {
      if (t == null) return "--:--.---";
      const e = Math.floor(t / 60), n = t % 60;
      return `${e}:${n.toFixed(3).padStart(6, "0")}`;
    }
    getPositionSuffix(t) {
      const e = [
        "th",
        "st",
        "nd",
        "rd"
      ], n = t % 100;
      return e[(n - 20) % 10] || e[n] || e[0];
    }
    updateLap(t, e = this.totalLaps) {
      this.currentLap = t, this.totalLaps = e, this.elements.currentLap.textContent = t, this.elements.totalLaps.textContent = `/ ${e}`;
    }
    updatePosition(t, e = this.totalCars) {
      this.position = t, this.totalCars = e, this.elements.position.textContent = t, this.elements.positionSuffix.textContent = this.getPositionSuffix(t), this.elements.totalCars.textContent = `/ ${e}`;
    }
    updateCurrentLapTime(t) {
      this.currentLapTime = t, this.elements.currentTime.textContent = this.formatTime(t);
    }
    updateLastLapTime(t) {
      this.lastLapTime = t, this.elements.lastLap.textContent = this.formatTime(t);
    }
    updateBestLapTime(t) {
      this.bestLapTime = t, this.elements.bestLap.textContent = this.formatTime(t);
    }
    updateRaceTime(t) {
      this.raceTime = t, this.elements.raceTime.textContent = this.formatTime(t);
    }
    updateCountdown(t) {
      this.elements.countdown && (this.elements.countdown.textContent = t);
    }
    setCountdownVisible(t) {
      this.elements.countdown && (t ? this.elements.countdown.classList.add("visible") : this.elements.countdown.classList.remove("visible"));
    }
    set visible(t) {
      this.container.style.display = t ? "block" : "none";
    }
    reset() {
      this.currentLap = 1, this.currentLapTime = 0, this.lastLapTime = null, this.bestLapTime = null, this.raceTime = 0, this.updateLap(1), this.updatePosition(1), this.updateCurrentLapTime(0), this.updateLastLapTime(null), this.updateBestLapTime(null), this.updateRaceTime(0), this.elements.countdown && (this.elements.countdown.textContent = "", this.elements.countdown.classList.remove("visible"));
    }
  }
  class Fa {
    constructor({ position: t, totalLaps: e, raceTime: n, bestLapTime: i, onBackToMenu: s }) {
      this.onBackToMenu = s, this.container = document.createElement("div"), this.container.id = "results-screen", this.setupStyles(), this.setupContent({
        position: t,
        totalLaps: e,
        raceTime: n,
        bestLapTime: i
      }), document.body.appendChild(this.container);
    }
    setupStyles() {
      const t = document.createElement("style");
      t.textContent = `
            #results-screen {
                position: fixed;
                top: 0;
                left: 0;
                width: 100vw;
                height: 100vh;
                background: rgba(0, 0, 0, 0.75);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 1200;
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                color: white;
            }

            .results-panel {
                background: rgba(10, 10, 20, 0.95);
                border-radius: 16px;
                padding: 2.5rem 3.5rem;
                box-shadow: 0 20px 60px rgba(0, 0, 0, 0.6);
                min-width: 360px;
                text-align: center;
            }

            .results-title {
                font-size: 2.2rem;
                font-weight: bold;
                margin-bottom: 1.5rem;
                letter-spacing: 0.15em;
                text-transform: uppercase;
            }

            .results-position {
                font-size: 3.5rem;
                font-weight: bold;
                color: #f1c40f;
                margin-bottom: 0.5rem;
            }

            .results-detail {
                opacity: 0.8;
                margin-bottom: 1.5rem;
                font-size: 0.95rem;
            }

            .results-row {
                display: flex;
                justify-content: space-between;
                margin: 0.4rem 0;
                font-size: 0.95rem;
            }

            .results-label {
                opacity: 0.7;
            }

            .results-value {
                font-family: 'Courier New', monospace;
            }

            .results-button {
                margin-top: 2rem;
                padding: 0.8rem 2.6rem;
                border-radius: 999px;
                border: none;
                background: linear-gradient(135deg, #667eea, #764ba2);
                color: white;
                font-size: 0.95rem;
                font-weight: bold;
                letter-spacing: 0.12em;
                text-transform: uppercase;
                cursor: pointer;
                box-shadow: 0 10px 30px rgba(102, 126, 234, 0.6);
                transition: transform 0.2s ease, box-shadow 0.2s ease;
            }

            .results-button:hover {
                transform: translateY(-2px);
                box-shadow: 0 14px 40px rgba(102, 126, 234, 0.8);
            }
        `, document.head.appendChild(t);
    }
    static formatTime(t) {
      if (t == null) return "--:--.---";
      const e = Math.floor(t / 60), n = t % 60;
      return `${e}:${n.toFixed(3).padStart(6, "0")}`;
    }
    getPositionText(t) {
      return t === 1 ? "1st" : t === 2 ? "2nd" : t === 3 ? "3rd" : `${t}th`;
    }
    setupContent({ position: t, totalLaps: e, raceTime: n, bestLapTime: i }) {
      const s = Fa.formatTime(n), a = Fa.formatTime(i);
      this.container.innerHTML = `
            <div class="results-panel">
                <div class="results-title">Race Finished</div>
                <div class="results-position">${this.getPositionText(t)}</div>
                <div class="results-detail">${e} lap race</div>

                <div class="results-row">
                    <span class="results-label">Total Time</span>
                    <span class="results-value">${s}</span>
                </div>
                <div class="results-row">
                    <span class="results-label">Best Lap</span>
                    <span class="results-value">${a}</span>
                </div>

                <button class="results-button">Back to Main Menu</button>
            </div>
        `, this.container.querySelector(".results-button").addEventListener("click", () => {
        this.onBackToMenu ? this.onBackToMenu() : window.location.reload();
      });
    }
  }
  class xP {
    constructor(t, e, n) {
      this.scene = t, this.camera = e, this.renderer = n, this.physics = new E1();
      const i = new Sd(60);
      this.scene.add(i), this.sky = new fP(this.scene, this.renderer, this.sunLight, {}), this.minFov = this.camera.fov || 70, this.maxFov = this.minFov + 15, this.fovSpeedRange = {
        min: 0,
        max: 140
      }, this.raceStartTime = null, this.currentLapStartTime = null, this.lapTimes = [], this.bestLapTime = null, this.currentLap = 1, this.totalLaps = 3, this.finishLineZ = 0, this.lastPlayerZ = 0, this.lastAiZ = 0, this.racePhase = "countdown", this.countdownStartTime = 0, this.countdownDuration = 3, this.trackWaypoints = null, this.trackLights = [], this.difficulty = "medium", this.waypointLoop = null, this.totalWaypoints = 0, this.finishWaypointIndex = 0, this.playerWaypointIndex = 0, this.aiWaypointIndex = 0, this.playerLapCount = 0, this.aiLapCount = 0, this.segmentLengths = [], this.loopLength = 0, this.resultsScreen = null, this.showWaypoints = false;
    }
    async init(t = false, e = "medium", n = 3) {
      this.difficulty = e, typeof n == "number" && n > 0 && (this.totalLaps = n), this.setupLights(), this.setupGround(), await this.setupRaceTrack(), this.setupCars(t), this.setupWaypointDebugIndicator();
    }
    setupLights() {
      const t = new wb(16777215, 0.35);
      this.scene.add(t);
      const e = new pb(11657727, 1907997, 0.5);
      e.position.set(0, 40, 0), this.scene.add(e), this.sunLight = new Ac(16777215, 5), this.sunLight.castShadow = true, this.sunLight.position.set(80, 100, 40), this.sunLight.shadow.mapSize.width = 2048, this.sunLight.shadow.mapSize.height = 2048, this.sunLight.shadow.camera.near = 1, this.sunLight.shadow.camera.far = 200, this.sunLight.shadow.camera.left = -100, this.sunLight.shadow.camera.right = 100, this.sunLight.shadow.camera.top = 100, this.sunLight.shadow.camera.bottom = -100, this.scene.add(this.sunLight), this.scene.add(this.sunLight.target);
      const n = new Ac(16771280, 1.2);
      n.position.set(-60, 60, -50), this.scene.add(n), this.setupTrackLights();
    }
    setupTrackLights() {
      [
        new L(40, 15, 20),
        new L(-45, 15, -10),
        new L(0, 15, -50),
        new L(60, 15, -90),
        new L(-70, 15, 50)
      ].forEach((n, i) => {
        const s = new Qu(16773829, 2.2, 140, Math.PI / 4, 0.35);
        s.position.copy(n), s.castShadow = true, s.shadow.mapSize.width = 1024, s.shadow.mapSize.height = 1024, s.shadow.camera.near = 5, s.shadow.camera.far = 200;
        const a = new _e();
        a.position.set(n.x, 0, n.z), this.scene.add(a), s.target = a, this.scene.add(s), this.trackLights.push({
          light: s,
          target: a
        });
      });
    }
    setupGround() {
      const t = new Ju(), e = t.load(new URL("/assets/Grass_001_COLOR-6oKnaf1c.jpg", import.meta.url).href), n = t.load(new URL("/assets/Grass_001_NORM-CPQSo9tw.jpg", import.meta.url).href), i = t.load(new URL("/assets/Grass_001_ROUGH-CTDwauKS.jpg", import.meta.url).href), s = t.load(new URL("/assets/Grass_001_OCC-D1DFG9nP.jpg", import.meta.url).href);
      [
        e,
        n,
        i,
        s
      ].forEach((l) => {
        l && (l.wrapS = l.wrapT = Oi, l.repeat.set(40, 40));
      });
      const a = new Un({
        map: e,
        normalMap: n,
        roughnessMap: i,
        aoMap: s
      }), o = new ys(1e3, 1e3), c = new fe(o, a);
      c.rotation.x = -Math.PI / 2, c.position.y = -0.05, c.receiveShadow = true, this.scene.add(c);
    }
    async setupRaceTrack() {
      const t = gP({
        world: this.physics.world,
        extraObjects: [
          {
            name: "waypoints",
            file: "demo_track/waypoints.glb"
          }
        ],
        onObjectLoaded: ({ def: e, object: n, trackGroup: i, RAPIER: s }) => {
          n.traverse((a) => {
            a.isMesh && (a.castShadow = true, a.receiveShadow = true, a.material && a.material.map && (a.material.map.anisotropy = this.renderer.capabilities.getMaxAnisotropy()));
          });
        }
      });
      this.scene.add(t), await t.userData.loadPromise, this.raceTrack = t, this.trackWaypoints = this.extractWaypointsFromTrack(t) || this.buildDefaultWaypoints();
    }
    setupCars(t = false) {
      this.playerCar = new tu(this.physics, this.scene, t, {
        enableKeyboard: true
      }), this.playerCar.chassisBody.setTranslation({
        x: -3,
        y: 5,
        z: 0
      }, true), this.camera.position.set(0, 6, 14), this.camera.lookAt(this.playerCar.group.position);
      const e = this.trackWaypoints || this.buildDefaultWaypoints();
      this.waypointLoop = e, this.totalWaypoints = e.length || 0, this.playerLapCount = 0, this.aiLapCount = 0, this.precomputeWaypointDistances();
      const n = {
        easy: {
          targetSpeedMph: 60,
          lookAheadDistance: 22,
          avoidanceDistance: 14,
          avoidanceStrength: 0.7
        },
        medium: {
          targetSpeedMph: 75,
          lookAheadDistance: 26,
          avoidanceDistance: 12,
          avoidanceStrength: 0.5
        },
        hard: {
          targetSpeedMph: 95,
          lookAheadDistance: 30,
          avoidanceDistance: 10,
          avoidanceStrength: 0.3
        }
      }, i = n[this.difficulty] || n.medium;
      this.aiDriver = e.length ? new pP({
        waypoints: e,
        waypointAdvanceDistance: 10,
        lookAheadDistance: i.lookAheadDistance,
        targetSpeedMph: i.targetSpeedMph,
        playerCar: this.playerCar,
        avoidanceDistance: i.avoidanceDistance,
        avoidanceStrength: i.avoidanceStrength,
        physicsWorld: this.physics.world,
        wallDetectionDistance: 8
      }) : null, this.aiCar = new tu(this.physics, this.scene, t, {
        enableKeyboard: false
      }), this.aiCar.chassisBody.setTranslation({
        x: 8,
        y: 5,
        z: -5
      }, true);
      const s = new Sd(3);
      if (s.position.y = 1, this.aiCar.group.add(s), this.aiDriver) {
        const a = new L(0, 0, 1).applyQuaternion(this.aiCar.group.quaternion);
        this.aiDriver.initializeWaypointIndex(this.aiCar.group.position.clone(), a);
      }
      if (this.aiCar.setControlProvider((a) => this.aiDriver ? this.aiDriver.update(this.aiCar, a) : null), this.vehicles = [
        this.playerCar,
        this.aiCar
      ], this.car = this.playerCar, this.speedometer = new yP(), this.speedometer.visible = true, this.racingHUD = new vP(), this.racingHUD.visible = true, this.racingHUD.updateLap(1, this.totalLaps), this.racingHUD.updatePosition(1, 2), this.racePhase = "countdown", this.countdownStartTime = performance.now() / 1e3, this.raceStartTime = null, this.currentLapStartTime = null, this.racingHUD.updateRaceTime(0), this.racingHUD.updateCurrentLapTime(0), this.racingHUD.updateCountdown("3"), this.racingHUD.setCountdownVisible(true), this.totalWaypoints > 0 && this.waypointLoop) {
        const a = this.getNearestWaypointIndex(this.playerCar.group.position), o = this.getNearestWaypointIndex(this.aiCar.group.position);
        this.playerWaypointIndex = a.index, this.aiWaypointIndex = o.index, this.finishWaypointIndex = a.index, this.addFinishLineMarker();
      }
      this.aiDebug = this.addWaypointDebug(e);
    }
    addWaypointDebug(t) {
      if (!(t == null ? void 0 : t.length)) return null;
      const e = new Ye();
      e.name = "WaypointDebug";
      const n = t.map((l, h) => {
        const d = new ss(0.5, 8, 8), u = new Nn({
          color: h % 2 === 0 ? 65416 : 39423,
          transparent: true,
          opacity: 0.4,
          depthWrite: false
        }), p = new fe(d, u);
        return p.position.copy(l), e.add(p), p;
      }), i = new sn().setFromPoints(t), s = new Ha({
        color: 16777215,
        transparent: true,
        opacity: 0.35
      }), a = new qu(i, s);
      e.add(a);
      const o = new fe(new ss(1, 10, 10), new Nn({
        color: 16776960
      })), c = new fe(new ss(1.2, 10, 10), new Nn({
        color: 16711680
      }));
      return e.add(o), e.add(c), this.scene.add(e), {
        group: e,
        dots: n,
        line: a,
        current: o,
        lookAhead: c
      };
    }
    extractWaypointsFromTrack(t) {
      const e = [], n = [], i = /Waypoint(\d+)_axis/i;
      return t.traverse((s) => {
        if (console.log(s.name), !s.name) return;
        const a = s.name.match(i);
        a && n.push({
          child: s,
          idx: parseInt(a[1], 10)
        });
      }), n.length ? (n.sort((s, a) => s.idx - a.idx).forEach(({ child: s }) => {
        const a = new L();
        s.getWorldPosition(a), a.y = 0.5, e.push(a);
      }), console.log(`Loaded ${e.length} Blender waypoints`), e) : (console.warn("No Blender waypoints found on track; using default ellipse"), null);
    }
    buildDefaultWaypoints() {
      const t = [];
      for (let a = 0; a < 24; a++) {
        const o = a / 24 * Math.PI * 2;
        t.push(new L(Math.cos(o) * 70, 0.5, Math.sin(o) * 120));
      }
      return t;
    }
    precomputeWaypointDistances() {
      const t = this.waypointLoop;
      if (!t || t.length < 2) {
        this.segmentLengths = [], this.loopLength = 0;
        return;
      }
      const e = t.length;
      this.segmentLengths = new Array(e);
      let n = 0;
      for (let i = 0; i < e; i++) {
        const s = t[i], a = t[(i + 1) % e], o = s.distanceTo(a);
        this.segmentLengths[i] = o, n += o;
      }
      this.loopLength = n;
    }
    addFinishLineMarker() {
      const t = this.waypointLoop || this.trackWaypoints;
      if (!t || t.length < 2) return;
      const e = t.length, n = Math.min(Math.max(this.finishWaypointIndex || 0, 0), e - 1), i = t[n].clone(), a = t[(n + 1) % e].clone().clone().sub(i);
      if (a.y = 0, a.lengthSq() === 0) return;
      a.normalize();
      const o = 12, c = 2.2, l = 0.08, h = new Cn(o, l, c), d = new Un({
        color: 16776960,
        metalness: 0,
        roughness: 0.25,
        emissive: new Ct(16776960),
        emissiveIntensity: 1
      }), u = new fe(h, d);
      u.position.copy(i), u.position.y = i.y + l * 0.5 + 0.05;
      const p = new Ve().setFromUnitVectors(new L(0, 0, 1), a);
      u.quaternion.copy(p), u.castShadow = false, u.receiveShadow = true, this.scene.add(u), this.finishLineMesh = u;
    }
    getNearestWaypointIndex(t) {
      const e = this.waypointLoop;
      if (!e || e.length === 0) return {
        index: 0,
        distanceSquared: 1 / 0
      };
      let n = 0, i = 1 / 0;
      for (let s = 0; s < e.length; s++) {
        const a = e[s], o = t.distanceToSquared(a);
        o < i && (i = o, n = s);
      }
      return {
        index: n,
        distanceSquared: i
      };
    }
    computeCarProgress(t, e) {
      const n = this.waypointLoop, i = this.totalWaypoints;
      if (!n || !i) return {
        lap: e,
        targetRel: 0,
        distToTarget: 0
      };
      const { index: s } = this.getNearestWaypointIndex(t.group.position), a = n[s], o = (s + 1) % i, l = n[o].clone().sub(a).normalize(), h = t.group.position.clone().sub(a), d = l.dot(h) > 0 ? o : s, u = this.finishWaypointIndex || 0;
      let p = (d - u + i) % i;
      if (p === 0) {
        const b = this.raceStartTime !== null ? performance.now() / 1e3 - this.raceStartTime : 0;
        (e > 0 || b > 10) && (p = i);
      }
      const w = t.group.position.distanceTo(n[d]);
      return {
        lap: e,
        targetRel: p,
        distToTarget: w
      };
    }
    isPlayerAhead(t, e) {
      return t.lap !== e.lap ? t.lap > e.lap : t.targetRel !== e.targetRel ? t.targetRel > e.targetRel : t.distToTarget < e.distToTarget;
    }
    setupWaypointDebugIndicator() {
      if (!(typeof document > "u")) {
        if (!document.getElementById("waypoint-toggle-style")) {
          const t = document.createElement("style");
          t.id = "waypoint-toggle-style", t.textContent = `
                #waypoint-debug-indicator {
                    position: absolute;
                    top: 10px;
                    right: 10px;
                    background: rgba(0, 0, 0, 0.5);
                    color: white;
                    padding: 5px 10px;
                    border-radius: 4px;
                    font-family: monospace;
                    font-size: 12px;
                    pointer-events: none;
                    user-select: none;
                    z-index: 1000;
                }
                #waypoint-debug-indicator.hidden {
                    display: none;
                }
            `, document.head.appendChild(t);
        }
        this.waypointToggleEl = document.createElement("div"), this.waypointToggleEl.id = "waypoint-debug-indicator", this.waypointToggleEl.textContent = "V: Waypoints ON", document.body.appendChild(this.waypointToggleEl), window.addEventListener("keydown", (t) => {
          t.key.toLowerCase() === "v" && this.toggleWaypoints();
        }), this.updateWaypointDebugVisibility();
      }
    }
    toggleWaypoints() {
      this.showWaypoints = !this.showWaypoints, this.updateWaypointDebugVisibility();
    }
    updateWaypointDebugVisibility() {
      this.waypointToggleEl && (this.waypointToggleEl.textContent = this.showWaypoints ? "V: Waypoints ON" : "V: Waypoints OFF", this.waypointToggleEl.style.color = this.showWaypoints ? "#00ff00" : "#ff0000"), this.aiDebug && this.aiDebug.group && (this.aiDebug.group.visible = this.showWaypoints);
    }
    update(t, e) {
      var _a2, _b2;
      const n = this.car.getCarMph(), i = this.car.getRPM();
      this.speedometer.updateSpeed(n), this.speedometer.updateRPM(i), this.speedometer.draw(), this.updateCameraFov(n);
      const s = performance.now() / 1e3;
      if (this.racePhase === "countdown") {
        const l = s - this.countdownStartTime;
        if (l < this.countdownDuration) {
          const h = this.countdownDuration - l, d = Math.ceil(h);
          d > 0 ? this.racingHUD.updateCountdown(String(d)) : this.racingHUD.updateCountdown("GO!"), this.physics.step(t);
          return;
        }
        this.racePhase = "racing", this.raceStartTime = s, this.currentLapStartTime = s, this.racingHUD.setCountdownVisible(false);
      }
      this.physics.step(t), (_a2 = this.playerCar) == null ? void 0 : _a2.update(t), (_b2 = this.aiCar) == null ? void 0 : _b2.update(t);
      const a = s, o = this.raceStartTime != null ? a - this.raceStartTime : 0, c = this.currentLapStartTime != null ? a - this.currentLapStartTime : 0;
      if (this.racingHUD.updateRaceTime(o), this.racingHUD.updateCurrentLapTime(c), this.waypointLoop && this.totalWaypoints > 0) {
        const l = this.totalWaypoints, h = this.finishWaypointIndex || 0, d = this.getNearestWaypointIndex(this.playerCar.group.position), u = this.getNearestWaypointIndex(this.aiCar.group.position), p = d.index, w = u.index, b = (this.playerWaypointIndex - h + l) % l, m = (p - h + l) % l, _ = (this.aiWaypointIndex - h + l) % l, E = (w - h + l) % l, v = l * 0.25, T = l * 0.75;
        if (this.racePhase === "racing") {
          if (b > T && m < v) {
            const P = c;
            if (this.currentLap > 1 || P > 5) {
              this.lapTimes.push(P), this.racingHUD.updateLastLapTime(P), (this.bestLapTime === null || P < this.bestLapTime) && (this.bestLapTime = P, this.racingHUD.updateBestLapTime(P)), this.currentLap++;
              const z = Math.min(this.currentLap, this.totalLaps);
              this.racingHUD.updateLap(z, this.totalLaps), this.currentLapStartTime = a, this.currentLap > this.totalLaps && (console.log("Race finished!"), this.racePhase = "finished", this.showResults());
            }
            this.playerLapCount++;
          }
          _ > T && E < v && this.aiLapCount++;
        }
        this.playerWaypointIndex = p, this.aiWaypointIndex = w;
        const O = this.computeCarProgress(this.playerCar, this.playerLapCount), R = this.computeCarProgress(this.aiCar, this.aiLapCount);
        this.isPlayerAhead(O, R), this.racingHUD.updatePosition(1, 2);
      } else this.playerCar.group.position.z, this.aiCar.group.position.z, this.racingHUD.updatePosition(1, 2);
      if (this.aiDriver && this.aiDebug) {
        const { current: l, lookAhead: h } = this.aiDebug;
        this.showWaypoints ? (this.aiDriver.debugCurrentTarget ? (l.position.copy(this.aiDriver.debugCurrentTarget), l.visible = true) : l.visible = false, this.aiDriver.debugLookAhead ? (h.position.copy(this.aiDriver.debugLookAhead), h.visible = true) : h.visible = false) : (l.visible = false, h.visible = false);
      }
    }
    showResults() {
      if (this.resultsScreen) return;
      const t = this.raceStartTime != null ? performance.now() / 1e3 - this.raceStartTime : 0, e = this.bestLapTime;
      let n = 1;
      this.waypointLoop && this.totalWaypoints > 0 && (this.computeCarProgress(this.playerCar, this.playerLapCount), this.computeCarProgress(this.aiCar, this.aiLapCount), n = 1), this.resultsScreen = new Fa({
        position: n,
        totalLaps: this.totalLaps,
        raceTime: t,
        bestLapTime: e,
        onBackToMenu: () => {
          window.location.reload();
        }
      });
    }
    updateCameraFov(t) {
      const { min: e, max: n } = this.fovSpeedRange, i = we.clamp((t - e) / (n - e || 1), 0, 1), s = we.lerp(this.minFov, this.maxFov, i);
      Math.abs(this.camera.fov - s) > 0.05 && (this.camera.fov = we.lerp(this.camera.fov, s, 0.1), this.camera.updateProjectionMatrix());
    }
  }
  class SP {
    constructor() {
      this.throttle = 0, this.throttleUp = false, this.throttleDown = false, this.forward = false, this.backward = false, this.left = false, this.right = false, this.handbrake = false, this.drive = 0, this.steer = 0, this.brake = false;
    }
  }
  class MP {
    constructor(t = window) {
      this.state = new SP(), this.target = t, this.throttleRate = 0.75, this.keyDownHandler = (e) => this.handleKey(e, true), this.keyUpHandler = (e) => this.handleKey(e, false), this.target.addEventListener("keydown", this.keyDownHandler), this.target.addEventListener("keyup", this.keyUpHandler);
    }
    dispose() {
      this.target.removeEventListener("keydown", this.keyDownHandler), this.target.removeEventListener("keyup", this.keyUpHandler);
    }
    handleKey(t, e) {
      if (!t.repeat) switch (t.code) {
        case "KeyW":
          console.log("Throttle Up:", e), this.state.throttleUp = e, this.state.forward = e, t.preventDefault();
          break;
        case "KeyS":
          console.log("Throttle Down:", e), this.state.throttleDown = e, this.state.backward = e, t.preventDefault();
          break;
        case "KeyA":
          this.state.left = e, t.preventDefault();
          break;
        case "KeyD":
          this.state.right = e, t.preventDefault();
          break;
        case "Space":
          this.state.handbrake = e, t.preventDefault();
          break;
      }
    }
    update(t) {
      const e = this.throttleRate * t;
      this.state.throttleUp && (this.state.throttle = Math.min(1, this.state.throttle + e)), this.state.throttleDown && (this.state.throttle = Math.max(0, this.state.throttle - e));
      const n = this.state.forward ? 1 : 0, i = this.state.backward ? 1 : 0;
      this.state.drive = Math.max(-1, Math.min(1, n - i));
      const s = this.state.left ? 1 : 0, a = this.state.right ? 1 : 0;
      return this.state.steer = Math.max(-1, Math.min(1, a - s)), this.state.brake = !!this.state.handbrake, this.state;
    }
  }
  const iu = {
    type: "change"
  }, gc = {
    type: "start"
  }, ru = {
    type: "end"
  }, ha = new bs(), su = new mi(), EP = Math.cos(70 * we.DEG2RAD);
  class TP extends Gi {
    constructor(t, e) {
      super(), this.object = t, this.domElement = e, this.domElement.style.touchAction = "none", this.enabled = true, this.target = new L(), this.cursor = new L(), this.minDistance = 0, this.maxDistance = 1 / 0, this.minZoom = 0, this.maxZoom = 1 / 0, this.minTargetRadius = 0, this.maxTargetRadius = 1 / 0, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.enableDamping = false, this.dampingFactor = 0.05, this.enableZoom = true, this.zoomSpeed = 1, this.enableRotate = true, this.rotateSpeed = 1, this.enablePan = true, this.panSpeed = 1, this.screenSpacePanning = true, this.keyPanSpeed = 7, this.zoomToCursor = false, this.autoRotate = false, this.autoRotateSpeed = 2, this.keys = {
        LEFT: "ArrowLeft",
        UP: "ArrowUp",
        RIGHT: "ArrowRight",
        BOTTOM: "ArrowDown"
      }, this.mouseButtons = {
        LEFT: Wi.ROTATE,
        MIDDLE: Wi.DOLLY,
        RIGHT: Wi.PAN
      }, this.touches = {
        ONE: ji.ROTATE,
        TWO: ji.DOLLY_PAN
      }, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this._domElementKeyEvents = null, this.getPolarAngle = function() {
        return o.phi;
      }, this.getAzimuthalAngle = function() {
        return o.theta;
      }, this.getDistance = function() {
        return this.object.position.distanceTo(this.target);
      }, this.listenToKeyEvents = function(y) {
        y.addEventListener("keydown", ct), this._domElementKeyEvents = y;
      }, this.stopListenToKeyEvents = function() {
        this._domElementKeyEvents.removeEventListener("keydown", ct), this._domElementKeyEvents = null;
      }, this.saveState = function() {
        n.target0.copy(n.target), n.position0.copy(n.object.position), n.zoom0 = n.object.zoom;
      }, this.reset = function() {
        n.target.copy(n.target0), n.object.position.copy(n.position0), n.object.zoom = n.zoom0, n.object.updateProjectionMatrix(), n.dispatchEvent(iu), n.update(), s = i.NONE;
      }, this.update = (function() {
        const y = new L(), q = new Ve().setFromUnitVectors(t.up, new L(0, 1, 0)), H = q.clone().invert(), K = new L(), nt = new Ve(), Mt = new L(), Nt = 2 * Math.PI;
        return function(Re = null) {
          const ne = n.object.position;
          y.copy(ne).sub(n.target), y.applyQuaternion(q), o.setFromVector3(y), n.autoRotate && s === i.NONE && W(S(Re)), n.enableDamping ? (o.theta += c.theta * n.dampingFactor, o.phi += c.phi * n.dampingFactor) : (o.theta += c.theta, o.phi += c.phi);
          let Ce = n.minAzimuthAngle, Pe = n.maxAzimuthAngle;
          isFinite(Ce) && isFinite(Pe) && (Ce < -Math.PI ? Ce += Nt : Ce > Math.PI && (Ce -= Nt), Pe < -Math.PI ? Pe += Nt : Pe > Math.PI && (Pe -= Nt), Ce <= Pe ? o.theta = Math.max(Ce, Math.min(Pe, o.theta)) : o.theta = o.theta > (Ce + Pe) / 2 ? Math.max(Ce, o.theta) : Math.min(Pe, o.theta)), o.phi = Math.max(n.minPolarAngle, Math.min(n.maxPolarAngle, o.phi)), o.makeSafe(), n.enableDamping === true ? n.target.addScaledVector(h, n.dampingFactor) : n.target.add(h), n.target.sub(n.cursor), n.target.clampLength(n.minTargetRadius, n.maxTargetRadius), n.target.add(n.cursor);
          let an = false;
          if (n.zoomToCursor && R || n.object.isOrthographicCamera) o.radius = mt(o.radius);
          else {
            const on = o.radius;
            o.radius = mt(o.radius * l), an = on != o.radius;
          }
          if (y.setFromSpherical(o), y.applyQuaternion(H), ne.copy(n.target).add(y), n.object.lookAt(n.target), n.enableDamping === true ? (c.theta *= 1 - n.dampingFactor, c.phi *= 1 - n.dampingFactor, h.multiplyScalar(1 - n.dampingFactor)) : (c.set(0, 0, 0), h.set(0, 0, 0)), n.zoomToCursor && R) {
            let on = null;
            if (n.object.isPerspectiveCamera) {
              const si = y.length();
              on = mt(si * l);
              const Mi = si - on;
              n.object.position.addScaledVector(T, Mi), n.object.updateMatrixWorld(), an = !!Mi;
            } else if (n.object.isOrthographicCamera) {
              const si = new L(O.x, O.y, 0);
              si.unproject(n.object);
              const Mi = n.object.zoom;
              n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom / l)), n.object.updateProjectionMatrix(), an = Mi !== n.object.zoom;
              const Ei = new L(O.x, O.y, 0);
              Ei.unproject(n.object), n.object.position.sub(Ei).add(si), n.object.updateMatrixWorld(), on = y.length();
            } else console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."), n.zoomToCursor = false;
            on !== null && (this.screenSpacePanning ? n.target.set(0, 0, -1).transformDirection(n.object.matrix).multiplyScalar(on).add(n.object.position) : (ha.origin.copy(n.object.position), ha.direction.set(0, 0, -1).transformDirection(n.object.matrix), Math.abs(n.object.up.dot(ha.direction)) < EP ? t.lookAt(n.target) : (su.setFromNormalAndCoplanarPoint(n.object.up, n.target), ha.intersectPlane(su, n.target))));
          } else if (n.object.isOrthographicCamera) {
            const on = n.object.zoom;
            n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom / l)), on !== n.object.zoom && (n.object.updateProjectionMatrix(), an = true);
          }
          return l = 1, R = false, an || K.distanceToSquared(n.object.position) > a || 8 * (1 - nt.dot(n.object.quaternion)) > a || Mt.distanceToSquared(n.target) > a ? (n.dispatchEvent(iu), K.copy(n.object.position), nt.copy(n.object.quaternion), Mt.copy(n.target), true) : false;
        };
      })(), this.dispose = function() {
        n.domElement.removeEventListener("contextmenu", bt), n.domElement.removeEventListener("pointerdown", ye), n.domElement.removeEventListener("pointercancel", x), n.domElement.removeEventListener("wheel", it), n.domElement.removeEventListener("pointermove", I), n.domElement.removeEventListener("pointerup", x), n.domElement.getRootNode().removeEventListener("keydown", St, {
          capture: true
        }), n._domElementKeyEvents !== null && (n._domElementKeyEvents.removeEventListener("keydown", ct), n._domElementKeyEvents = null);
      };
      const n = this, i = {
        NONE: -1,
        ROTATE: 0,
        DOLLY: 1,
        PAN: 2,
        TOUCH_ROTATE: 3,
        TOUCH_PAN: 4,
        TOUCH_DOLLY_PAN: 5,
        TOUCH_DOLLY_ROTATE: 6
      };
      let s = i.NONE;
      const a = 1e-6, o = new xd(), c = new xd();
      let l = 1;
      const h = new L(), d = new vt(), u = new vt(), p = new vt(), w = new vt(), b = new vt(), m = new vt(), _ = new vt(), E = new vt(), v = new vt(), T = new L(), O = new vt();
      let R = false;
      const P = [], z = {};
      let A = false;
      function S(y) {
        return y !== null ? 2 * Math.PI / 60 * n.autoRotateSpeed * y : 2 * Math.PI / 60 / 60 * n.autoRotateSpeed;
      }
      function F(y) {
        const q = Math.abs(y * 0.01);
        return Math.pow(0.95, n.zoomSpeed * q);
      }
      function W(y) {
        c.theta -= y;
      }
      function V(y) {
        c.phi -= y;
      }
      const Z = (function() {
        const y = new L();
        return function(H, K) {
          y.setFromMatrixColumn(K, 0), y.multiplyScalar(-H), h.add(y);
        };
      })(), tt = (function() {
        const y = new L();
        return function(H, K) {
          n.screenSpacePanning === true ? y.setFromMatrixColumn(K, 1) : (y.setFromMatrixColumn(K, 0), y.crossVectors(n.object.up, y)), y.multiplyScalar(H), h.add(y);
        };
      })(), Y = (function() {
        const y = new L();
        return function(H, K) {
          const nt = n.domElement;
          if (n.object.isPerspectiveCamera) {
            const Mt = n.object.position;
            y.copy(Mt).sub(n.target);
            let Nt = y.length();
            Nt *= Math.tan(n.object.fov / 2 * Math.PI / 180), Z(2 * H * Nt / nt.clientHeight, n.object.matrix), tt(2 * K * Nt / nt.clientHeight, n.object.matrix);
          } else n.object.isOrthographicCamera ? (Z(H * (n.object.right - n.object.left) / n.object.zoom / nt.clientWidth, n.object.matrix), tt(K * (n.object.top - n.object.bottom) / n.object.zoom / nt.clientHeight, n.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), n.enablePan = false);
        };
      })();
      function J(y) {
        n.object.isPerspectiveCamera || n.object.isOrthographicCamera ? l /= y : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), n.enableZoom = false);
      }
      function $(y) {
        n.object.isPerspectiveCamera || n.object.isOrthographicCamera ? l *= y : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), n.enableZoom = false);
      }
      function ut(y, q) {
        if (!n.zoomToCursor) return;
        R = true;
        const H = n.domElement.getBoundingClientRect(), K = y - H.left, nt = q - H.top, Mt = H.width, Nt = H.height;
        O.x = K / Mt * 2 - 1, O.y = -(nt / Nt) * 2 + 1, T.set(O.x, O.y, 1).unproject(n.object).sub(n.object.position).normalize();
      }
      function mt(y) {
        return Math.max(n.minDistance, Math.min(n.maxDistance, y));
      }
      function gt(y) {
        d.set(y.clientX, y.clientY);
      }
      function qt(y) {
        ut(y.clientX, y.clientX), _.set(y.clientX, y.clientY);
      }
      function ee(y) {
        w.set(y.clientX, y.clientY);
      }
      function Q(y) {
        u.set(y.clientX, y.clientY), p.subVectors(u, d).multiplyScalar(n.rotateSpeed);
        const q = n.domElement;
        W(2 * Math.PI * p.x / q.clientHeight), V(2 * Math.PI * p.y / q.clientHeight), d.copy(u), n.update();
      }
      function st(y) {
        E.set(y.clientX, y.clientY), v.subVectors(E, _), v.y > 0 ? J(F(v.y)) : v.y < 0 && $(F(v.y)), _.copy(E), n.update();
      }
      function _t(y) {
        b.set(y.clientX, y.clientY), m.subVectors(b, w).multiplyScalar(n.panSpeed), Y(m.x, m.y), w.copy(b), n.update();
      }
      function lt(y) {
        ut(y.clientX, y.clientY), y.deltaY < 0 ? $(F(y.deltaY)) : y.deltaY > 0 && J(F(y.deltaY)), n.update();
      }
      function kt(y) {
        let q = false;
        switch (y.code) {
          case n.keys.UP:
            y.ctrlKey || y.metaKey || y.shiftKey ? V(2 * Math.PI * n.rotateSpeed / n.domElement.clientHeight) : Y(0, n.keyPanSpeed), q = true;
            break;
          case n.keys.BOTTOM:
            y.ctrlKey || y.metaKey || y.shiftKey ? V(-2 * Math.PI * n.rotateSpeed / n.domElement.clientHeight) : Y(0, -n.keyPanSpeed), q = true;
            break;
          case n.keys.LEFT:
            y.ctrlKey || y.metaKey || y.shiftKey ? W(2 * Math.PI * n.rotateSpeed / n.domElement.clientHeight) : Y(n.keyPanSpeed, 0), q = true;
            break;
          case n.keys.RIGHT:
            y.ctrlKey || y.metaKey || y.shiftKey ? W(-2 * Math.PI * n.rotateSpeed / n.domElement.clientHeight) : Y(-n.keyPanSpeed, 0), q = true;
            break;
        }
        q && (y.preventDefault(), n.update());
      }
      function Dt(y) {
        if (P.length === 1) d.set(y.pageX, y.pageY);
        else {
          const q = zt(y), H = 0.5 * (y.pageX + q.x), K = 0.5 * (y.pageY + q.y);
          d.set(H, K);
        }
      }
      function Kt(y) {
        if (P.length === 1) w.set(y.pageX, y.pageY);
        else {
          const q = zt(y), H = 0.5 * (y.pageX + q.x), K = 0.5 * (y.pageY + q.y);
          w.set(H, K);
        }
      }
      function D(y) {
        const q = zt(y), H = y.pageX - q.x, K = y.pageY - q.y, nt = Math.sqrt(H * H + K * K);
        _.set(0, nt);
      }
      function Yt(y) {
        n.enableZoom && D(y), n.enablePan && Kt(y);
      }
      function jt(y) {
        n.enableZoom && D(y), n.enableRotate && Dt(y);
      }
      function ue(y) {
        if (P.length == 1) u.set(y.pageX, y.pageY);
        else {
          const H = zt(y), K = 0.5 * (y.pageX + H.x), nt = 0.5 * (y.pageY + H.y);
          u.set(K, nt);
        }
        p.subVectors(u, d).multiplyScalar(n.rotateSpeed);
        const q = n.domElement;
        W(2 * Math.PI * p.x / q.clientHeight), V(2 * Math.PI * p.y / q.clientHeight), d.copy(u);
      }
      function At(y) {
        if (P.length === 1) b.set(y.pageX, y.pageY);
        else {
          const q = zt(y), H = 0.5 * (y.pageX + q.x), K = 0.5 * (y.pageY + q.y);
          b.set(H, K);
        }
        m.subVectors(b, w).multiplyScalar(n.panSpeed), Y(m.x, m.y), w.copy(b);
      }
      function Qt(y) {
        const q = zt(y), H = y.pageX - q.x, K = y.pageY - q.y, nt = Math.sqrt(H * H + K * K);
        E.set(0, nt), v.set(0, Math.pow(E.y / _.y, n.zoomSpeed)), J(v.y), _.copy(E);
        const Mt = (y.pageX + q.x) * 0.5, Nt = (y.pageY + q.y) * 0.5;
        ut(Mt, Nt);
      }
      function Xt(y) {
        n.enableZoom && Qt(y), n.enablePan && At(y);
      }
      function Ft(y) {
        n.enableZoom && Qt(y), n.enableRotate && ue(y);
      }
      function ye(y) {
        n.enabled !== false && (P.length === 0 && (n.domElement.setPointerCapture(y.pointerId), n.domElement.addEventListener("pointermove", I), n.domElement.addEventListener("pointerup", x)), !pt(y) && (Zt(y), y.pointerType === "touch" ? Ot(y) : X(y)));
      }
      function I(y) {
        n.enabled !== false && (y.pointerType === "touch" ? at(y) : et(y));
      }
      function x(y) {
        switch (Pt(y), P.length) {
          case 0:
            n.domElement.releasePointerCapture(y.pointerId), n.domElement.removeEventListener("pointermove", I), n.domElement.removeEventListener("pointerup", x), n.dispatchEvent(ru), s = i.NONE;
            break;
          case 1:
            const q = P[0], H = z[q];
            Ot({
              pointerId: q,
              pageX: H.x,
              pageY: H.y
            });
            break;
        }
      }
      function X(y) {
        let q;
        switch (y.button) {
          case 0:
            q = n.mouseButtons.LEFT;
            break;
          case 1:
            q = n.mouseButtons.MIDDLE;
            break;
          case 2:
            q = n.mouseButtons.RIGHT;
            break;
          default:
            q = -1;
        }
        switch (q) {
          case Wi.DOLLY:
            if (n.enableZoom === false) return;
            qt(y), s = i.DOLLY;
            break;
          case Wi.ROTATE:
            if (y.ctrlKey || y.metaKey || y.shiftKey) {
              if (n.enablePan === false) return;
              ee(y), s = i.PAN;
            } else {
              if (n.enableRotate === false) return;
              gt(y), s = i.ROTATE;
            }
            break;
          case Wi.PAN:
            if (y.ctrlKey || y.metaKey || y.shiftKey) {
              if (n.enableRotate === false) return;
              gt(y), s = i.ROTATE;
            } else {
              if (n.enablePan === false) return;
              ee(y), s = i.PAN;
            }
            break;
          default:
            s = i.NONE;
        }
        s !== i.NONE && n.dispatchEvent(gc);
      }
      function et(y) {
        switch (s) {
          case i.ROTATE:
            if (n.enableRotate === false) return;
            Q(y);
            break;
          case i.DOLLY:
            if (n.enableZoom === false) return;
            st(y);
            break;
          case i.PAN:
            if (n.enablePan === false) return;
            _t(y);
            break;
        }
      }
      function it(y) {
        n.enabled === false || n.enableZoom === false || s !== i.NONE || (y.preventDefault(), n.dispatchEvent(gc), lt(rt(y)), n.dispatchEvent(ru));
      }
      function rt(y) {
        const q = y.deltaMode, H = {
          clientX: y.clientX,
          clientY: y.clientY,
          deltaY: y.deltaY
        };
        switch (q) {
          case 1:
            H.deltaY *= 16;
            break;
          case 2:
            H.deltaY *= 100;
            break;
        }
        return y.ctrlKey && !A && (H.deltaY *= 10), H;
      }
      function St(y) {
        y.key === "Control" && (A = true, n.domElement.getRootNode().addEventListener("keyup", ht, {
          passive: true,
          capture: true
        }));
      }
      function ht(y) {
        y.key === "Control" && (A = false, n.domElement.getRootNode().removeEventListener("keyup", ht, {
          passive: true,
          capture: true
        }));
      }
      function ct(y) {
        n.enabled === false || n.enablePan === false || kt(y);
      }
      function Ot(y) {
        switch (Bt(y), P.length) {
          case 1:
            switch (n.touches.ONE) {
              case ji.ROTATE:
                if (n.enableRotate === false) return;
                Dt(y), s = i.TOUCH_ROTATE;
                break;
              case ji.PAN:
                if (n.enablePan === false) return;
                Kt(y), s = i.TOUCH_PAN;
                break;
              default:
                s = i.NONE;
            }
            break;
          case 2:
            switch (n.touches.TWO) {
              case ji.DOLLY_PAN:
                if (n.enableZoom === false && n.enablePan === false) return;
                Yt(y), s = i.TOUCH_DOLLY_PAN;
                break;
              case ji.DOLLY_ROTATE:
                if (n.enableZoom === false && n.enableRotate === false) return;
                jt(y), s = i.TOUCH_DOLLY_ROTATE;
                break;
              default:
                s = i.NONE;
            }
            break;
          default:
            s = i.NONE;
        }
        s !== i.NONE && n.dispatchEvent(gc);
      }
      function at(y) {
        switch (Bt(y), s) {
          case i.TOUCH_ROTATE:
            if (n.enableRotate === false) return;
            ue(y), n.update();
            break;
          case i.TOUCH_PAN:
            if (n.enablePan === false) return;
            At(y), n.update();
            break;
          case i.TOUCH_DOLLY_PAN:
            if (n.enableZoom === false && n.enablePan === false) return;
            Xt(y), n.update();
            break;
          case i.TOUCH_DOLLY_ROTATE:
            if (n.enableZoom === false && n.enableRotate === false) return;
            Ft(y), n.update();
            break;
          default:
            s = i.NONE;
        }
      }
      function bt(y) {
        n.enabled !== false && y.preventDefault();
      }
      function Zt(y) {
        P.push(y.pointerId);
      }
      function Pt(y) {
        delete z[y.pointerId];
        for (let q = 0; q < P.length; q++) if (P[q] == y.pointerId) {
          P.splice(q, 1);
          return;
        }
      }
      function pt(y) {
        for (let q = 0; q < P.length; q++) if (P[q] == y.pointerId) return true;
        return false;
      }
      function Bt(y) {
        let q = z[y.pointerId];
        q === void 0 && (q = new vt(), z[y.pointerId] = q), q.set(y.pageX, y.pageY);
      }
      function zt(y) {
        const q = y.pointerId === P[0] ? P[1] : P[0];
        return z[q];
      }
      n.domElement.addEventListener("contextmenu", bt), n.domElement.addEventListener("pointerdown", ye), n.domElement.addEventListener("pointercancel", x), n.domElement.addEventListener("wheel", it, {
        passive: false
      }), n.domElement.getRootNode().addEventListener("keydown", St, {
        passive: true,
        capture: true
      }), this.update();
    }
  }
  class AP {
    constructor(t, e) {
      this.camera = t, this.controls = new TP(this.camera, e), this.easeTime = 0.5, this.lastManualInput = 0, this.currentDistance = null, this.currentPolar = null, this.currentAzimuthal = null;
    }
    getAngleDiff(t, e) {
      let n = t - e;
      for (; n > Math.PI; ) n -= 2 * Math.PI;
      for (; n < -Math.PI; ) n += 2 * Math.PI;
      return n;
    }
    syncInternalState(t) {
      const e = new L().subVectors(this.camera.position, t);
      this.currentDistance = e.length(), this.currentPolar = Math.acos(we.clamp(e.y / this.currentDistance, -1, 1)), this.currentAzimuthal = Math.atan2(e.x, e.z);
    }
    update(t, e) {
      if (!this.camera || !this.controls || !e) return;
      const n = performance.now(), i = e.getPosition();
      this.controls.userIsInteracting && (this.lastManualInput = n);
      const a = n - this.lastManualInput < this.easeTime * 1e3;
      if (this.currentAzimuthal === null && this.syncInternalState(i), a) {
        this.controls.target.copy(i), this.controls.update(), this.syncInternalState(i);
        return;
      }
      const o = e.getDirectionofMotion(), c = this.getAngleDiff(o, this.currentAzimuthal), l = t * 3;
      this.currentAzimuthal += c * l, this.currentDistance += (50 - this.currentDistance) * l, this.currentPolar += (Math.PI / 4 - this.currentPolar) * l;
      const h = this.currentDistance * Math.sin(this.currentPolar) * Math.sin(this.currentAzimuthal), d = this.currentDistance * Math.cos(this.currentPolar), u = this.currentDistance * Math.sin(this.currentPolar) * Math.cos(this.currentAzimuthal);
      this.camera.position.set(i.x - h, i.y + d, i.z - u), this.camera.lookAt(i), this.controls.target.copy(i);
    }
  }
  class RP {
    constructor(t) {
      this.container = t, this.scene = new j0(), this.scene.background = new Ct(8900331), this.camera = new tn(50, t.clientWidth / t.clientHeight, 0.1, 5e3), this.renderer = new W0({
        antialias: true
      }), this.renderer.setSize(t.clientWidth, t.clientHeight), this.renderer.shadowMap.enabled = true, this.renderer.shadowMap.type = ou, t.appendChild(this.renderer.domElement), this.cameraController = new AP(this.camera, this.renderer.domElement), this.input = new MP(window), this.motionBlur = null, this.lastTime = 0, window.addEventListener("resize", () => this.onResize());
    }
    async init(t = false, e = "medium", n = 3) {
      this.world = new xP(this.scene, this.camera, this.renderer), await this.world.init(t, e, n);
    }
    onResize() {
      const t = this.container.clientWidth, e = this.container.clientHeight;
      this.camera.aspect = t / e, this.camera.updateProjectionMatrix(), this.renderer.setSize(t, e);
    }
    start() {
      this.lastTime = performance.now(), requestAnimationFrame((t) => this.loop(t));
    }
    loop(t) {
      var _a2;
      const e = (t - this.lastTime) / 1e3;
      this.lastTime = t;
      const n = this.input.update(e);
      this.world.update(e, n);
      const i = (_a2 = this.world) == null ? void 0 : _a2.car;
      i && this.cameraController && this.cameraController.update(e, i), this.motionBlur ? this.motionBlur.render(e) : this.renderer.render(this.scene, this.camera), requestAnimationFrame((s) => this.loop(s));
    }
  }
  class CP {
    constructor() {
      this.container = document.createElement("div"), this.container.id = "start-screen", this.setupStyles(), this.setupContent(), document.body.appendChild(this.container), this.onStart = null;
    }
    setupStyles() {
      const t = document.createElement("style");
      t.textContent = `
            #start-screen {
                position: fixed;
                top: 0;
                left: 0;
                width: 100vw;
                height: 100vh;
                background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                z-index: 1000;
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                color: white;
            }

            .start-screen-title {
                font-size: 4rem;
                font-weight: bold;
                margin-bottom: 1rem;
                text-shadow: 0 0 20px rgba(255, 255, 255, 0.3);
                letter-spacing: 0.1em;
            }

            .start-screen-subtitle {
                font-size: 1.2rem;
                margin-bottom: 3rem;
                opacity: 0.8;
            }

            .detail-selection {
                display: flex;
                gap: 2rem;
                margin-bottom: 3rem;
            }

            .detail-option {
                background: rgba(255, 255, 255, 0.1);
                border: 2px solid rgba(255, 255, 255, 0.3);
                border-radius: 12px;
                padding: 2rem 3rem;
                cursor: pointer;
                transition: all 0.3s ease;
                min-width: 200px;
                text-align: center;
            }

            .detail-option:hover {
                background: rgba(255, 255, 255, 0.2);
                border-color: rgba(255, 255, 255, 0.6);
                transform: translateY(-5px);
                box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            }

            .detail-option.selected {
                background: rgba(74, 144, 226, 0.3);
                border-color: #4a90e2;
                box-shadow: 0 0 20px rgba(74, 144, 226, 0.5);
            }

            .difficulty-selection {
                display: flex;
                gap: 1.5rem;
                margin-bottom: 2rem;
            }

            .difficulty-button {
                padding: 0.6rem 1.4rem;
                border-radius: 999px;
                border: 1px solid rgba(255, 255, 255, 0.3);
                background: rgba(0, 0, 0, 0.25);
                color: white;
                cursor: pointer;
                font-size: 0.9rem;
                letter-spacing: 0.08em;
                text-transform: uppercase;
                transition: all 0.2s ease;
            }

            .difficulty-button.selected {
                background: #4a90e2;
                border-color: #4a90e2;
                box-shadow: 0 0 14px rgba(74, 144, 226, 0.7);
            }

            .laps-selection {
                display: flex;
                align-items: center;
                gap: 1rem;
                margin-bottom: 2rem;
                font-size: 0.95rem;
                opacity: 0.9;
            }

            .laps-label {
                text-transform: uppercase;
                letter-spacing: 0.12em;
                font-size: 0.8rem;
                opacity: 0.8;
            }

            .laps-button {
                padding: 0.4rem 0.9rem;
                border-radius: 999px;
                border: 1px solid rgba(255, 255, 255, 0.3);
                background: rgba(0, 0, 0, 0.25);
                color: white;
                cursor: pointer;
                font-size: 0.9rem;
                letter-spacing: 0.08em;
                text-transform: uppercase;
                transition: all 0.2s ease;
            }

            .laps-button.selected {
                background: #4a90e2;
                border-color: #4a90e2;
                box-shadow: 0 0 14px rgba(74, 144, 226, 0.6);
            }

            .detail-title {
                font-size: 1.8rem;
                font-weight: bold;
                margin-bottom: 0.5rem;
            }

            .detail-description {
                font-size: 0.9rem;
                opacity: 0.7;
                line-height: 1.4;
            }

            .start-button {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                border: none;
                border-radius: 50px;
                padding: 1.2rem 4rem;
                font-size: 1.5rem;
                font-weight: bold;
                color: white;
                cursor: pointer;
                transition: all 0.3s ease;
                text-transform: uppercase;
                letter-spacing: 0.15em;
                box-shadow: 0 10px 30px rgba(102, 126, 234, 0.4);
            }

            .start-button:hover {
                transform: translateY(-3px);
                box-shadow: 0 15px 40px rgba(102, 126, 234, 0.6);
            }

            .start-button:active {
                transform: translateY(-1px);
            }

            .start-button:disabled {
                opacity: 0.5;
                cursor: not-allowed;
                transform: none;
            }

            .controls-info {
                position: absolute;
                bottom: 2rem;
                text-align: center;
                opacity: 0.6;
                font-size: 0.9rem;
            }

            .controls-info div {
                margin: 0.3rem 0;
            }
        `, document.head.appendChild(t);
    }
    setupContent() {
      this.container.innerHTML = `
            <div class="start-screen-title">RACING SIMULATOR</div>
            <div class="start-screen-subtitle">Select graphics quality and start your race</div>
            
            <div class="detail-selection">
                <div class="detail-option" data-detail="basic">
                    <div class="detail-title">Basic</div>
                    <div class="detail-description">
                        Simple car model<br/>
                        Better performance<br/>
                        Faster loading
                    </div>
                </div>
                <div class="detail-option" data-detail="detailed">
                    <div class="detail-title">Detailed</div>
                    <div class="detail-description">
                        High-quality car model<br/>
                        Enhanced visuals<br/>
                        Realistic appearance
                    </div>
                </div>
            </div>

            <div class="difficulty-selection">
                <button class="difficulty-button" data-difficulty="easy">Easy</button>
                <button class="difficulty-button selected" data-difficulty="medium">Medium</button>
                <button class="difficulty-button" data-difficulty="hard">Hard</button>
            </div>

            <div class="laps-selection">
                <span class="laps-label">Laps</span>
                <button class="laps-button" data-laps="1">1</button>
                <button class="laps-button selected" data-laps="3">3</button>
                <button class="laps-button" data-laps="5">5</button>
            </div>

            <button class="start-button" disabled>START RACE</button>

            <div class="controls-info">
                <div><strong>W/S</strong> - Throttle/Brake | <strong>A/D</strong> - Steer | <strong>Space</strong> - Handbrake</div>
                <div><strong>F3</strong> - Toggle Debug Panel | <strong>V</strong> - Toggle Viewpoints Debug</div>
            </div>
        `, this.selectedDetail = null, this.selectedDifficulty = "medium", this.selectedLaps = 3, this.startButton = this.container.querySelector(".start-button");
      const t = this.container.querySelectorAll(".detail-option");
      t.forEach((i) => {
        i.addEventListener("click", () => {
          this.selectDetail(i.dataset.detail), t.forEach((s) => s.classList.remove("selected")), i.classList.add("selected");
        });
      });
      const e = this.container.querySelectorAll(".difficulty-button");
      e.forEach((i) => {
        i.addEventListener("click", () => {
          this.selectedDifficulty = i.dataset.difficulty, e.forEach((s) => s.classList.toggle("selected", s === i));
        });
      });
      const n = this.container.querySelectorAll(".laps-button");
      n.forEach((i) => {
        i.addEventListener("click", () => {
          const s = parseInt(i.dataset.laps, 10) || 3;
          this.selectedLaps = s, n.forEach((a) => a.classList.toggle("selected", a === i));
        });
      }), this.startButton.addEventListener("click", () => {
        this.selectedDetail && this.onStart && (this.hide(), this.onStart(this.selectedDetail === "detailed", this.selectedDifficulty, this.selectedLaps));
      });
    }
    selectDetail(t) {
      this.selectedDetail = t, this.startButton.disabled = false;
    }
    hide() {
      this.container.style.display = "none";
    }
    show() {
      this.container.style.display = "flex";
    }
  }
  const PP = document.getElementById("app") || document.body;
  async function IP() {
    const r = new CP();
    r.onStart = async (t, e, n) => {
      console.log(`Starting game with ${t ? "detailed" : "basic"} model on ${e} difficulty, ${n} laps`);
      const i = new RP(PP);
      await i.init(t, e, n), i.start();
    };
  }
  IP();
})();
